<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="ICJJ Blog"><meta property="og:type" content="article"><meta property="og:image" content="img/site/小米汽车/原型车壁纸/2880x1280/2880x1280-06.png"><meta property="twitter:image" content="img/site/小米汽车/原型车壁纸/2880x1280/2880x1280-06.png"><meta name=title content="AMBA5 AXI 协议翻译"><meta property="og:title" content="AMBA5 AXI 协议翻译"><meta property="twitter:title" content="AMBA5 AXI 协议翻译"><meta name=description content="AMBA5 AXI的协议翻译"><meta property="og:description" content="AMBA5 AXI的协议翻译"><meta property="twitter:description" content="AMBA5 AXI的协议翻译"><meta property="twitter:card" content="summary"><meta name=keyword content="程建军, chengjianjun, ChengJianjun, , 程建军的网络日志, 程建军的博客, ChengJianjun Blog, 博客, 个人网站, AMBA, FPGA, SPINALHDL, PCIE"><link rel="shortcut icon" href=/icer/img/site/favicon.ico><title>AMBA5 AXI 协议翻译 | 程建军的博客 | ChengJianjun Blog</title>
<link rel=canonical href=/icer/post/amba5-axi-%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91/><link rel=stylesheet href=/icer/css/bootstrap.min.css><link rel=stylesheet href=/icer/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/icer/css/zanshang.css><link rel=stylesheet href=/icer/css/font-awesome.all.min.css><script src=/icer/js/jquery.min.js></script><script src=/icer/js/bootstrap.min.js></script><script src=/icer/js/hux-blog.min.js></script><script src=/icer/js/lazysizes.min.js></script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-FWR2FVFK68"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FWR2FVFK68")}</script><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/icer>ICJJ Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/icer>Posts</a></li><li><a href=/icer/categories/bus/>bus</a></li><li><a href=/icer/categories/tech/>tech</a></li><li><a href=/icer/categories/tips/>tips</a></li><li><a href=/icer/archive/>ARCHIVE</a></li><li><a href=/icer/about/>ABOUT</a></li><li><a href=/icer/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/icer/img/site/%e5%b0%8f%e7%b1%b3%e6%b1%bd%e8%bd%a6/%e5%8e%9f%e5%9e%8b%e8%bd%a6%e5%a3%81%e7%ba%b8/2880x1280/2880x1280-06.png)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/amba5 title=AMBA5>AMBA5
</a><a class=tag href=/tags/axi title=AXI>AXI
</a><a class=tag href=/tags/%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91 title=协议翻译>协议翻译</a></div><h1>AMBA5 AXI 协议翻译</h1><h2 class=subheading></h2><span class=meta>Posted by
程建军
on
Tuesday, April 23, 2024</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=amba-axi-协议规范>AMBA AXI 协议规范</h1><blockquote><p><a href=https://icjj.github.io/icer/document/IHI0022K_amba_axi_protocol_spec.pdf>IHI0022K_amba_axi_protocol_spec.pdf</a></p></blockquote><h2 id=ahb-协议规范>AHB 协议规范</h2><h3 id=a-id引言引言a><a id=引言>引言</a></h3><p>本前言描述了本规范中使用的内容组织和文档约定。</p><h4 id=a-id目标受众目标受众a><a id=目标受众>目标受众</a></h4><p>该规范是为希望熟悉AMBA协议的硬件和软件工程师编写的，旨在设计与AXI协议兼容的系统和模块</p><h4 id=a-id使用本规范使用本规范a><a id=使用本规范>使用本规范</a></h4><p>本规范中的信息分为几个部分，如本节所述：</p><p><strong>A部分 规范</strong></p><ul><li><em><a href="#a第1章 介绍">A第1章 介绍</a></em> ：介绍了本规格中使用的AXI协议架构和术语。</li><li><em><a href="#a第2章 信号列表">A第2章 信号列表</a></em> ：介绍了本规格中使用的AXI协议架构和术语。</li><li><em><a href="#a第3章 传输">A第3章 传输</a></em> ：提供有关AXI协议的基本操作的信息，例如读写事务、通道信令要求以及通道之间的关系。</li><li><em><a href="#a第4章 事务">A第4章 事务</a></em> ：包含有关AXI协议事务的信息，例如事务请求、事务响应、以及读写数据。</li><li><em><a href="#a第5章 请求属性">A第5章 请求属性</a></em> ：描述内存属性、内存类型、内存保护和多个区域接口。</li><li><em><a href="#a第6章 事务识别和顺序">A第6章 事务识别和顺序</a></em> ：描述事务ID信号、请求顺序、写数据和响应顺序 以及读数据顺序。</li><li><em><a href="#a第7章 原子操作">A第7章 原子操作</a></em> ：包含关于原子访问、单一和多副本原子性及独占访问的信息。</li><li><em><a href="#a第8章 请求操作码">A第8章 请求操作码</a></em> ：提供有关操作码字段的信息，该字段描述请求的功能并指示如何由从机处理。</li><li><em><a href="#a第9章 缓存">A第9章 缓存</a></em> ：描述了AXI协议中的缓存，包括I/O一致性、缓存可共享行以及使用特定事务管理缓存分配。</li><li><em><a href="#a第10章 缓存维护">A第10章 缓存维护</a></em> 提供有关使用缓存维护操作来控制缓存内容的信息，以确保数据的可见性。</li><li><em><a href="#a第11章 额外请求限定">A第11章 额外请求限定</a></em> ：描述AXI协议中的额外请求限定符，例如非安全访问标识符(NSAID)基于页面的硬件属性(PBHA)和子系统标识符。</li><li><em><a href="#a第12章 其他写事务">A第12章 其他写事务</a></em> ：包含有关AXI协议中其他写事务的信息，例如WriteDeferrable和WriteZero。</li><li><em><a href="#a第13章 同步监测、debug和user扩展">A第13章 同步监测、debug和user扩展</a></em> ：描述了AXI协议的系统调试、跟踪和监控功能，例如内存系统资源分区和监控（MPAM）、内存标记扩展（MTE）以及用户回环和用户定义信令。</li><li><em><a href="#a第14章 未翻译事务">A第14章 未翻译事务</a></em> ：描述了AXI如何支持在系统内存管理单元（SMMU）上游组件中使用虚拟地址和翻译缓存提示</li><li><em><a href="#a第15章 虚拟内存消息分布">A第15章 虚拟内存消息分布</a></em> ：描述AXI如何支持分布式系统MMU使用分布式虚拟内存DVM消息来维护虚拟内存系统中的所有MMU。</li><li><em><a href="#a第16章 唤醒信号">A第16章 唤醒信号</a></em> ：描述可用于接口时钟或电源控制的唤醒信号。</li><li><em><a href="#a第17章 接口和数据保护">A第17章 接口和数据保护</a></em> ：解释如何使用poison信号和奇偶校验信号来保护数据或接口。</li></ul><p><strong>B部分 附录</strong></p><ul><li><em><a href="#b1 接口类">B1 接口汇总</a></em> ：对所有AMBA 5 AXI接口类的描述，包括信号和属性表。</li><li><em><a href="#b2 约束总结">B2 约束总结</a></em> ：AXI协议中ID约束的总结。</li><li><em><a href="#b3 版本">B3 版本</a></em> ：本次规格与上一版本之间变化的详细信息。</li></ul><p><strong>C部分 术语</strong></p><ul><li><em><a href="#c1 术语表">C1 术语表</a></em></li></ul><h4 id=a-id约定约定a><a id=约定>约定</a></h4><p>本节描述了本规格使用的约定：</p><ul><li><a href=#排版>排版</a></li><li><a href=#时序图>时序图</a></li><li><a href=#信号>信号</a></li><li><a href=#数字>数字</a></li></ul><h5 id=a-id排版排版a><a id=排版>排版</a></h5><p>排版惯例是：</p><ul><li>italic(斜体)：突出重要笔记，介绍特殊术语，并指示内部交叉引用和引用。</li><li>bold(粗体)：表示信号名称，并用于描述性列表中的术语(如果适用)。</li><li>monospace(等宽)：该字体用于汇编程序语法描述、伪代码和源代码示例。</br>同时用于主要文本中的指令助记符，以及对出现在汇编程序语法描述、伪代码和源代码示例中的其他项目的引用。</li><li>SMALL CAPITALS(小写大写字母)：用于几个具有特定技术含义的术语。</li></ul><h5 id=a-id时序图时序图a><a id=时序图>时序图</a></h5><p>在时序图中使用的组件在 <em><a href="#图 1">图 1</a></em> 中进行了说明。当变化发生时，会有明确的标签。请不要假设图中没有明确的时序信息</p><p><a id="图 1">图 1</a>
<img src=https://icjj.github.io/icer/img/post/axi/Figure1_Key_to_timing_diagram_conventions.png alt></p><p>时序图有时将单比特信号同时显示为高和低，它们看起来与 <em><a href="#图 1">图 1</a></em> 显示的总线变化类似。
如果时序图以这种方式显示单比特信号，则其值不会影响附带的描述。</p><h5 id=a-id信号信号a><a id=信号>信号</a></h5><p>下面是关于信号方面的约定：</p><ul><li>信号电平：</br>断言信号的水平取决于信号是高有效还是低有效，断言意味着<ul><li>HIGH：表示高电平有效。</li><li>LOW：表示低电平有效。</li></ul></li><li>小写n：出现在信号名的开始或结束都表示低电平有效。</li><li>小写x：信号名称的第二个字母表示读取和写入的统称。例如<strong>AxCACHE</strong>既指<strong>ARCACHE</strong>信号也指<strong>AWCACHE</strong>信号。</li></ul><h5 id=a-id数字数字a><a id=数字>数字</a></h5><p>数字通常以十进制书写。二进制数字以0b开头，十六进制数字以0x开头。
在这两种情况下，前缀和相关的值都以monospace字体书写。例如0xFFFF0000。
为了提高可读性，较长的数字可以在每四个字符之间加下划线分隔。
例如0xFFFF_0000_0000_0000，在解释数字的值时忽略任何下划线。</p><h5 id=a-id伪代码描述伪代码描述a><a id=伪代码描述>伪代码描述</a></h5><p>本规范使用一种伪代码形式来提供对指定功能的精确描述。
该伪代码以等宽字体书写。伪代码语言在Arm®架构参考手册中描述，适用于A型架构。</p><h4 id=a-id额外阅读额外阅读a><a id=额外阅读>额外阅读</a></h4><p>本节列出了Arm和第三方的出版物。</p><p>查看Arm开发者网站<a href=http://developer.arm.com>http://developer.arm.com</a> 以获取Arm文档的访问权限。</p><p><a id=[1]>[1]</a> AMBA® AXI and ACE Protocol Specification. (ARM IHI 0022 H.c).<br><a id=[2]>[2]</a> AMBA® AXI Protocol Specification. (ARM IHI 0022 J).<br><a id=[3]>[3]</a> Arm® Architecture Reference Manual for A-profile architecture. (ARM DDI 0487).<br><a id=[4]>[4]</a> Arm® Realm Management Extension (RME) System Architecture. (ARM DEN 0129).<br><a id=[5]>[5]</a> AMBA® 5 CHI Architecture Specification. (ARM IHI 0050).<br><a id=[6]>[6]</a> Arm® Architecture Reference Manual Supplement, Memory System Resource Partitioning and Monitoring<br>(MPAM), for A-profile architecture. (ARM DDI 0598).<br><a id=[7]>[7]</a> Arm® System Memory Management Unit Architecture Specification, SMMU architecture version 3. (ARM IHI0070)</p><h4 id=a-id反馈反馈a><a id=反馈>反馈</a></h4><ul><li>请通过填写 <em><a href=https://developer.arm.com/feedback/survey>https://developer.arm.com/feedback/survey</a></em>
上的表单，提交关于Arm产品文档的反馈意见。</li><li>有关Arm产品、架构和规格的技术反馈、问题或咨询，请在 <em><a href=https://support.developer.arm.com/my-cases/open-case/>https://support.developer.arm.com/my-cases/open-case/</a></em>
上提交支持请求。</li></ul><h3 id=a-ida第1章-介绍a第1章-介绍a><a id="a第1章 介绍">A第1章 介绍</a></h3><p>本章介绍了AXI协议的架构和本规范中使用的术语。</p><p>它包含以下部分：</p><ul><li><em><a href="#1.1 关于axi协议">1.1 关于AXI协议</a></em></li><li><em><a href="#1.2 axi架构">1.2 AXI架构</a></em></li><li><em><a href="#1.3 术语">1.3 术语</a></em></li></ul><h4 id=a-ida11-关于axi协议a11-关于axi协议a><a id="a1.1 关于axi协议">A1.1 关于AXI协议</a></h4><p>AXI协议支持高性能、高频率的系统设计，用于主机与从机之间的通信。</p><p>AXI协议的特点包括：</p><ul><li>适用于高带宽和低延迟的设计。</li><li>无需使用复杂的桥接器，提供高频率操作。</li><li>该协议满足广泛组件的接口要求。</li><li>适用于具有高首次访问延迟的内存控制器。</li><li>提供互联架构实施的灵活性。</li><li>向后兼容AHB和APB接口。</li></ul><p>AXI协议的关键特性包括：</p><ul><li>独立的地址/控制和数据阶段。</li><li>支持使用字节时钟的非对齐数据传输。</li><li>仅发出起始地址的基于突发的事务。</li><li>分开的写和读数据通道，可以提供低成本的直接内存访问（DMA）。</li><li>支持发出多个未完成的地址。</li><li>支持无序事务完成。</li><li>允许轻松添加寄存器阶段以提供时序闭合。</li></ul><p>有关本规范的前期版本，请参见 <sup><em><a href=#[1]>[1]</a></em> </sup>和 <sup><em><a href=#[2]>[2]</a></em> </sup>。</p><h4 id=a-ida12-axi架构a12-axi架构a><a id="a1.2 axi架构">A1.2 AXI架构</a></h4><p>AXI协议是基于事务的，定义了五个独立的通道：</p><ul><li>写请求，其信号名称以AW开头</li><li>写数据，其信号名称以W开头</li><li>写响应，其信号名称以B开头</li><li>读请求，其信号名称以AR开头</li><li>读数据，其信号名称以R开头</li></ul><p>请求通道携带控制信息，描述要传输数据的性质。这个称为请求。</p><p>数据在主机和从机之间使用以下方式传输：</p><ul><li>写数据通道将数据从主机传输到从机。在写事务中，从机使用写响应通道向主机发出表示完成传输的信号。</li><li>读数据通道将数据从从机传输到主机。</li></ul><p>AXI协议：</p><ul><li>允许在实际数据传输之前发出地址信息。</li><li>支持多个未决事务。</li><li>支持事务的乱序完成。</li></ul><p><em><a href="#图 a1.1">图 A1.1</a></em> 展示了写事务如何使用写请求、写数据和写响应通道。</p><p><a id="图 a1.1">图 A1.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A1.1_Channel_architecture_of_writes.png alt></a></p><p><em><a href="#图 a1.1">图 a1.1</a></em></p><p><a id="图 a1.2">图 A1.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A1.2_Channel_architecture_of_reads.png alt></a></p><h5 id=a-ida121-通道定义a121-通道定义a><a id="a1.2.1 通道定义">A1.2.1 通道定义</a></h5><p>每个独立的五个通道由一组信息信号以及<strong>VALID</strong>和<strong>READY</strong>信号组成，
提供双向握手机制。信息源使用<strong>VALID</strong>信号来表示通道上何时有有效的地址、数据或控制信息可用。
目的地使用<strong>READY</strong>信号来表示何时可以接受这些信息。
读数据通道和写数据通道还包括<strong>LAST</strong>信号，以指示在事务中最后一个数据项的传输。</p><h6 id=a-ida1211-读写请求通道a1211-读写请求通道a><a id="a1.2.1.1 读写请求通道">A1.2.1.1 读写请求通道</a></h6><p>存在单独的写请求和读请求通道。适当的请求通道携带一个事务所需的所有地址和控制信息。</p><h6 id=a-ida1212-写数据通道a1212-写数据通道a><a id="a1.2.1.2 写数据通道">A1.2.1.2 写数据通道</a></h6><p>写数据通道将写数据从主机传输到从机，包括：</p><ul><li>数据信号<strong>WDATA</strong>，可以为8、16、32、64、128、256、512或1024位宽。宽度使用DATA_WIDTH属性表示。</li><li>每8个数据位都有一个字节通道时钟信号，指示有效的数据字节。</li></ul><p>写数据通道信息始终被视为缓存，这样主机可以在没有从机确认先前写操作的情况下执行写事务。</p><h6 id=a-ida1213-写响应通道a1213-写响应通道a><a id="a1.2.1.3 写响应通道">A1.2.1.3 写响应通道</a></h6><p>从机使用写响应通道来响应写事务。
所有写事务都需要在写响应通道上进行完成信号传输。
如 <a href="#图 a1.1">图 A1.1</a>所示，只有在完整事务中才会发出完成信号，而不是在事务中的每个数据传输中发出。</p><h6 id=a-ida1214-读数据通道a1214-读数据通道a><a id="a1.2.1.4 读数据通道">A1.2.1.4 读数据通道</a></h6><p>读取数据通道携带从从机到主机的读取数据和读取响应信息，包括：</p><ul><li>数据信号<strong>RDATA</strong>，其宽度可以是8、16、32、64、128、256、512或1024位。宽度通过DATA_WIDTH属性表示。</li><li>表示读取事务完成状态的读取响应信号。</li></ul><h5 id=a-ida122-接口与互联a122-接口与互联a><a id="a1.2.2 接口与互联">A1.2.2 接口与互联</a></h5><p>一个典型的系统由多个主机和从机组成，这些设备通过某种形式的连接相互连接，如 <em><a href="#图 a1.3">图 A1.3</a></em> 所示</p><p><a id="图 a1.3">图 A1.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A1.3_Interface_and_interconnect.png alt></a></p><p>AXI协议为以下接口之间提供了单一的接口定义：</p><ul><li>主机与互连之间</li><li>从机与互连之间</li><li>主机与从机之间</li></ul><p>此接口定义支持许多不同的互连实现。</p><p>设备之间的互连相当于另一个具有对称的主机和从机端口的设备，实际的主机和从机通过这一互联可以连接在一起。</p><h6 id=a-ida1221-典型系统拓扑a1221-典型系统拓扑a><a id="a1.2.2.1 典型系统拓扑">A1.2.2.1 典型系统拓扑</a></h6><p>大多数系统使用三种互连拓扑之一：</p><ul><li>共享请求和数据通道。</li><li>共享请求通道和多个数据通道。</li><li>多层次，具有多个请求和数据通道。</li></ul><p>在大多数系统中，请求通道的带宽需求显著低于数据通道的带宽需求。
这种系统可以通过使用一个共享请求通道和多个数据通道来实现系统性能和互连复杂性之间的良好平衡，从而启用并行数据传输。</p><h6 id=a-ida123-寄存器切片a123-寄存器切片a><a id="a1.2.3 寄存器切片">A1.2.3 寄存器切片</a></h6><p>每个AXI通道仅以单一方向传输信息，并且架构不要求通道之间有任何固定关系。
这些特性意味着可以在任意通道的几乎任何位置插入寄存器切片，代价是增加一个周期的延迟。
这些特性使以下情况成为可能：</p><ul><li>在延迟周期和最大操作频率之间进行权衡。</li><li>处理器与高性能内存之间的直接快速连接，同时使用简单的寄存器切片来隔离到性能要求较低外设的较长路径。</li></ul><h4 id=a-ida13-术语a13-术语a><a id="a1.3 术语">A1.3 术语</a></h4><p>本节总结了本规范中使用的术语，这些术语在 <em><a href="#c1 术语表">C1 术语表</a></em> 中或其他地方有定义。
在适当的情况下，本节中列出的术语链接到相应的术语表定义。</p><h5 id=a-ida131-axi组件和拓扑a131-axi组件和拓扑a><a id="a1.3.1 axi组件和拓扑">A1.3.1 AXI组件和拓扑</a></h5><p>以下术语描述了AXI组件：</p><ul><li><em><a href=#组件>组件</a></em></li><li><em><a href=#主机组件>主机组件</a></em></li><li><em><a href=#从机组件>从机组件</a></em> ，包括内存从机组件和外设从机组件</li><li><em><a href=#互联组件>互联组件</a></em></li></ul><p>对于特定的AXI事务，<em><a href=#上游>上游</a></em> 和 <em><a href=#下游>下游</a></em> 指的是AXI拓扑中AXI组件的相对位置。</p><h5 id=a-ida132-axi事务与传输a132-axi事务与传输a><a id="a1.3.2 axi事务与传输">A1.3.2 AXI事务与传输</a></h5><p>AXI传输是在AXI通道上一个周期内的通信。</p><p>AXI事务是AXI主机与AXI从机进行通信所需的传输集合。</p><p>例如，读事务由请求传输和一个或多个读数据传输组成。</p><h5 id=a-ida133-缓存与缓存操作a133-缓存与缓存操作a><a id="a1.3.3 缓存与缓存操作">A1.3.3 缓存与缓存操作</a></h5><p>本规范没有定义任何缓存参考书中定义的标准缓存术语。</p><p>然而，<em><a href=#缓存>缓存</a></em> 和 <em><a href=#缓存行>缓存行</a></em> 的词汇条目澄清了这些术语在本文档中的使用方式。</p><h5 id=a-ida134-时间描述a134-时间描述a><a id="a1.3.4 时间描述">A1.3.4 时间描述</a></h5><p>AXI规范使用了 <em><a href=#时间描述>时间描述</a></em> 的解释。</p><h3 id=a-ida第2章-信号列表a第2章-信号列表a><a id="a第2章 信号列表">A第2章 信号列表</a></h3><p>本章列出了本规范中描述的所有信号。
有些通道和信号是可选的，因此并不包含在每个接口中。
每个信号名称包含一个超链接，指向定义该信号的章节。
奇偶校验信号不包含在本章中，但在 <em><a href="#a17.2.3 校验检查信号">A17.2.3 校验检查信号</a></em> 中列出。</p><p>信号根据通道和类别分组，如以下各节所述。</p><ul><li><em><a href="#a2.1 写通道">A2.1 写通道</a></em></li><li><em><a href="#a2.2 读通道">A2.2 读通道</a></em></li><li><em><a href="#a2.3 snoop通道">A2.3 snoop通道</a></em></li><li><em><a href="#a2.4 接口信号">A2.4 接口信号</a></em></li></ul><h4 id=a-ida21-写通道a21-写通道a><a id="a2.1 写通道">A2.1 写通道</a></h4><p>写通道用于传输请求、数据和响应以进行写事务以及一些其他无数据事务。</p><h5 id=a-ida211-写请求通道a211-写请求通道a><a id="a2.1.1 写请求通道">A2.1.1 写请求通道</a></h5><p>写请求通道传输使用写通道的事务所需的所有地址和控制信息。该通道上的信号前缀为AW。</p><p><a id="表 a2.1">表 A2.1</a> 写请求通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>AWREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>AWID</strong></td><td>ID_W_WIDTH</td><td>主机</td><td>事务ID</td></tr><tr><td><strong>AWADDR</strong></td><td>ADDR_WIDTH</td><td>主机</td><td>地址</td></tr><tr><td><strong>AWREGION</strong></td><td>4</td><td>主机</td><td>区域ID</td></tr><tr><td><strong>AWLEN</strong></td><td>8</td><td>主机</td><td>长度</td></tr><tr><td><strong>AWSIZE</strong></td><td>3</td><td>主机</td><td>大小</td></tr><tr><td><strong>AWBURST</strong></td><td>2</td><td>主机</td><td>突发属性</td></tr><tr><td><strong>AWLOCK</strong></td><td>1</td><td>主机</td><td>锁定</td></tr><tr><td><strong>AWCACHE</strong></td><td>4</td><td>主机</td><td>缓存属性</td></tr><tr><td><strong>AWPROT</strong></td><td>3</td><td>主机</td><td>访问属性</td></tr><tr><td><strong>AWNSE</strong></td><td>1</td><td>主机</td><td>RME的非安全扩展bit</td></tr><tr><td><strong>AWQOS</strong></td><td>4</td><td>主机</td><td>Qos ID</td></tr><tr><td><strong>AWUSER</strong></td><td>USER_REQ_WIDTH</td><td>主机</td><td>user写请求</td></tr><tr><td><strong>AWDOMAIN</strong></td><td>2</td><td>主机</td><td>可共享域</td></tr><tr><td><strong>AWSNOOP</strong></td><td>AWSNOOP_WIDTH</td><td>主机</td><td>操作码</td></tr><tr><td><strong>AWSTASHNID</strong></td><td>11</td><td>主机</td><td>Stash 节点 ID</td></tr><tr><td><strong>AWSTASHNIDEN</strong></td><td>1</td><td>主机</td><td>Stash 节点 ID 使能</td></tr><tr><td><strong>AWSTASHLPID</strong></td><td>5</td><td>主机</td><td>Stash 逻辑处理器 ID</td></tr><tr><td><strong>AWSTASHLPIDEN</strong></td><td>1</td><td>主机</td><td>Stash 逻辑处理器 ID 使能</td></tr><tr><td><strong>AWTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr><tr><td><strong>AWLOOP</strong></td><td>LOOP_W_WIDTH</td><td>主机</td><td>环回信号</td></tr><tr><td><strong>AWMMUVALID</strong></td><td>1</td><td>主机</td><td>MMU有效</td></tr><tr><td><strong>AWMMUSECSID</strong></td><td>SECSID_WIDTH</td><td>主机</td><td>MMU安全流 ID</td></tr><tr><td><strong>AWMMUSID</strong></td><td>SID_WIDTH</td><td>主机</td><td>MMU流ID</td></tr><tr><td><strong>AWMMUSSIDV</strong></td><td>1</td><td>主机</td><td>MMU子流ID有效</td></tr><tr><td><strong>AWMMUSSID</strong></td><td>SSID_WIDTH</td><td>主机</td><td>MMU子流ID</td></tr><tr><td><strong>AWMMUATST</strong></td><td>1</td><td>主机</td><td>地址转换指示</td></tr><tr><td><strong>AWMMUFLOW</strong></td><td>2</td><td>主机</td><td>MMU flow type</td></tr><tr><td><strong>AWPBHA</strong></td><td>4</td><td>主机</td><td>Page-based 硬件属性</td></tr><tr><td><strong>AWNSAID</strong></td><td>4</td><td>主机</td><td>非安全访问 ID</td></tr><tr><td><strong>AWSUBSYSID</strong></td><td>SUBSYSID_WIDTH</td><td>主机</td><td>子系统 ID</td></tr><tr><td><strong>AWATOP</strong></td><td>6</td><td>主机</td><td>原子事务操作码</td></tr><tr><td><strong>AWMPAM</strong></td><td>MPAM_WIDTH</td><td>主机</td><td>MPAM 写请求</td></tr><tr><td><strong>AWIDUNQ</strong></td><td>1</td><td>主机</td><td>唯一ID</td></tr><tr><td><strong>AWCMO</strong></td><td>AWCMO_WIDTH</td><td>主机</td><td>CMO type</td></tr><tr><td><strong>AWTAGOP</strong></td><td>2</td><td>主机</td><td>内存标签</td></tr><tr><td><strong>AWMECID</strong></td><td>MECID_WIDTH</td><td>主机</td><td>内存加密ID</td></tr></tbody></table><h4 id=a-ida212-写数据通道a212-写数据通道a><a id="a2.1.2 写数据通道">A2.1.2 写数据通道</a></h4><p>写数据通道携带来自主机到从机的写数据和控制信息。该通道上的信号以W为前缀。</p><p><a id="表 a2.2">表 A2.2</a> 写数据通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>WVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>WREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>WDATA</strong></td><td>DATA_WIDTH</td><td>主机</td><td>写数据</td></tr><tr><td><strong>WSTRB</strong></td><td>DATA_WIDTH / 8</td><td>主机</td><td>strobes写</td></tr><tr><td><strong>WTAG</strong></td><td>ceil(DATA_WIDTH/128)*4</td><td>主机</td><td>内存Tag</td></tr><tr><td><strong>WTAGUPDATE</strong></td><td>ceil(DATA_WIDTH/128)</td><td>主机</td><td>内存Tag更新</td></tr><tr><td><strong>WLAST</strong></td><td>1</td><td>主机</td><td>最后写数据标识</td></tr><tr><td><strong>WUSER</strong></td><td>USER_DATA_WIDTH</td><td>主机</td><td>user写数据</td></tr><tr><td><strong>WPOISON</strong></td><td>ceil(DATA_WIDTH / 64)</td><td>主机</td><td>破坏标识</td></tr><tr><td><strong>WTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr></tbody></table><h4 id=a-ida写响应信号a写响应信号a><a id=a写响应信号>A写响应信号</a></h4><p>写响应通道用于传递从从机到主机的响应，适用于使用写数据通道的事务。该通道上的信号以字母B为前缀。</p><p><a id="表 a2.3">表 A2.3</a> 写响应通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>BVALID</strong></td><td>1</td><td>从机</td><td>有效</td></tr><tr><td><strong>BREADY</strong></td><td>1</td><td>主机</td><td>就绪</td></tr><tr><td><strong>BID</strong></td><td>ID_W_WIDTH</td><td>从机</td><td>事务ID</td></tr><tr><td><strong>BIDUNQ</strong></td><td>1</td><td>从机</td><td>唯一ID</td></tr><tr><td><strong>BRESP</strong></td><td>BRESP_WIDTH</td><td>从机</td><td>写响应</td></tr><tr><td><strong>BCOMP</strong></td><td>1</td><td>从机</td><td>完成标识</td></tr><tr><td><strong>BPERSIST</strong></td><td>1</td><td>从机</td><td>持久响应</td></tr><tr><td><strong>BTAGMATCH</strong></td><td>2</td><td>从机</td><td>内存标签匹配</td></tr><tr><td><strong>BUSER</strong></td><td>USER_RESP_WIDTH</td><td>从机</td><td>user写响应</td></tr><tr><td><strong>BTRACE</strong></td><td>1</td><td>从机</td><td>跟踪</td></tr><tr><td><strong>BLOOP</strong></td><td>LOOP_W_WIDTH</td><td>从机</td><td>回环</td></tr><tr><td><strong>BBUSY</strong></td><td>2</td><td>从机</td><td>繁忙</td></tr></tbody></table><h4 id=a-ida22-读通道a22-读通道a><a id="a2.2 读通道">A2.2 读通道</a></h4><p>读通道用于传输读取事务、缓存维护操作和DVM完成消息的请求、数据和响应。</p><h5 id=a-ida221-读请求通道a221-读请求通道a><a id="a2.2.1 读请求通道">A2.2.1 读请求通道</a></h5><p>读请求通道携带所有使用读取通道的事务所需的地址和控制信息。该通道上的信号以前缀AR开头。</p><p><a id="表 a2.4">表 A2.4</a> 读请求信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ARVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>ARREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>ARID</strong></td><td>ID_R_WIDTH</td><td>主机</td><td>ID</td></tr><tr><td><strong>ARADDR</strong></td><td>ADDR_WIDTH</td><td>主机</td><td>地址</td></tr><tr><td><strong>ARREGION</strong></td><td>4</td><td>主机</td><td>区域</td></tr><tr><td><strong>ARLEN</strong></td><td>8</td><td>主机</td><td>长度</td></tr><tr><td><strong>ARSIZE</strong></td><td>3</td><td>主机</td><td>大小</td></tr><tr><td><strong>ARBURST</strong></td><td>2</td><td>主机</td><td>突发</td></tr><tr><td><strong>ARLOCK</strong></td><td>1</td><td>主机</td><td>锁定</td></tr><tr><td><strong>ARCACHE</strong></td><td>4</td><td>主机</td><td>缓存属性</td></tr><tr><td><strong>ARPROT</strong></td><td>3</td><td>主机</td><td>访问属性</td></tr><tr><td><strong>ARNSE</strong></td><td>1</td><td>主机</td><td>RME的非安全扩展位</td></tr><tr><td><strong>ARQOS</strong></td><td>4</td><td>主机</td><td>QoS标识</td></tr><tr><td><strong>ARUSER</strong></td><td>USER_REQ_WIDTH</td><td>主机</td><td>user读请求</td></tr><tr><td><strong>ARDOMAIN</strong></td><td>2</td><td>主机</td><td>共享域</td></tr><tr><td><strong>ARSNOOP</strong></td><td>ARSNOOP_WIDTH</td><td>主机</td><td>操作码</td></tr><tr><td><strong>ARTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr><tr><td><strong>ARLOOP</strong></td><td>LOOP_R_WIDTH</td><td>主机</td><td>环回</td></tr><tr><td><strong>ARMMUVALID</strong></td><td>1</td><td>主机</td><td>MMU有效</td></tr><tr><td><strong>ARMMUSECSID</strong></td><td>SECSID_WIDTH</td><td>主机</td><td>MMU安全流ID</td></tr><tr><td><strong>ARMMUSID</strong></td><td>SID_WIDTH</td><td>主机</td><td>MMU流ID</td></tr><tr><td><strong>ARMMUSSIDV</strong></td><td>1</td><td>主机</td><td>MMU子流ID有效</td></tr><tr><td><strong>ARMMUSSID</strong></td><td>SSID_WIDTH</td><td>主机</td><td>MMU子流ID</td></tr><tr><td><strong>ARMMUATST</strong></td><td>1</td><td>主机</td><td>地址已转换</td></tr><tr><td><strong>ARMMUFLOW</strong></td><td>2</td><td>主机</td><td>MMU flow类型</td></tr><tr><td><strong>ARPBHA</strong></td><td>4</td><td>主机</td><td>Page-based硬件属性</td></tr><tr><td><strong>ARNSAID</strong></td><td>4</td><td>主机</td><td>非安全访问ID</td></tr><tr><td><strong>ARSUBSYSID</strong></td><td>SUBSYSID_WIDTH</td><td>主机</td><td>子系统ID</td></tr><tr><td><strong>ARMPAM</strong></td><td>MPAM_WIDTH</td><td>主机</td><td>带请求的MPAM信息</td></tr><tr><td><strong>ARCHUNKEN</strong></td><td>1</td><td>主机</td><td>chunk使能</td></tr><tr><td><strong>ARIDUNQ</strong></td><td>1</td><td>主机</td><td>唯一ID标识</td></tr><tr><td><strong>ARTAGOP</strong></td><td>2</td><td>主机</td><td>内存标签操作码</td></tr><tr><td><strong>ARMECID</strong></td><td>MECID_WIDTH</td><td>主机</td><td>内存加密标识</td></tr></tbody></table><h5 id=a-ida222-读数据通道a222-读数据通道a><a id="a2.2.2 读数据通道">A2.2.2 读数据通道</a></h5><p>读数据通道传输来自从机设备到管理器的读数据和响应。该通道上的信号以R为前缀。</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>RVALID</strong></td><td>1</td><td>从机</td><td>有效</td></tr><tr><td><strong>RREADY</strong></td><td>1</td><td>主机</td><td>就绪</td></tr><tr><td><strong>RID</strong></td><td>ID_R_WIDTH</td><td>从机</td><td>事务ID</td></tr><tr><td><strong>RIDUNQ</strong></td><td>1</td><td>从机</td><td>唯一ID指示</td></tr><tr><td><strong>RDATA</strong></td><td>DATA_WIDTH</td><td>从机</td><td>读取数据</td></tr><tr><td><strong>RTAG</strong></td><td>ceil(DATA_WIDTH/128)*4</td><td>从机</td><td>内存标签</td></tr><tr><td><strong>RRESP</strong></td><td>RRESP_WIDTH</td><td>从机</td><td>读取响应</td></tr><tr><td><strong>RLAST</strong></td><td>1</td><td>从机</td><td>最后读取标识</td></tr><tr><td><strong>RUSER</strong></td><td>USER_DATA_WIDTH + USER_RESP_WIDTH</td><td>从机</td><td>user的读取数据和响应</td></tr><tr><td><strong>RPOISON</strong></td><td>ceil(DATA_WIDTH / 64)</td><td>从机</td><td>破坏标识</td></tr><tr><td><strong>RTRACE</strong></td><td>1</td><td>从机</td><td>跟踪</td></tr><tr><td><strong>RLOOP</strong></td><td>LOOP_R_WIDTH</td><td>从机</td><td>回环</td></tr><tr><td><strong>RCHUNKV</strong></td><td>1</td><td>从机</td><td>chunk有效</td></tr><tr><td><strong>RCHUNKNUM</strong></td><td>RCHUNKNUM_WIDTH</td><td>从机</td><td>chunk编号</td></tr><tr><td><strong>RCHUNKSTRB</strong></td><td>RCHUNKSTRB_WIDTH</td><td>从机</td><td>chunk strobe</td></tr><tr><td><strong>RBUSY</strong></td><td>2</td><td>从机</td><td>繁忙</td></tr></tbody></table><h4 id=a-ida23-snoop通道a23-snoop通道a><a id="a2.3 snoop通道">A2.3 snoop通道</a></h4><p>在本规范中，旁路通道仅用于传输DVM消息。</p><h5 id=a-ida231-snoop请求通道a231-snoop请求通道a><a id="a2.3.1 snoop请求通道">A2.3.1 snoop请求通道</a></h5><p>snoop请求通道携带DVM消息请求的地址和控制信息。该通道上的信号具有前缀AC。</p><p><a id="表 a2.6">表 A2.6</a> snoop请求通道</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ACVALID</strong></td><td>1</td><td>从机</td><td>有效</td></tr><tr><td><strong>ACREADY</strong></td><td>1</td><td>主机</td><td>就绪</td></tr><tr><td><strong>ACADDR</strong></td><td>ADDR_WIDTH</td><td>从机</td><td>地址</td></tr><tr><td><strong>ACVMIDEXT</strong></td><td>4</td><td>从机</td><td>VMID</td></tr><tr><td><strong>ACTRACE</strong></td><td>1</td><td>从机</td><td>跟踪</td></tr></tbody></table><h5 id=a-ida232-snoop响应通道a232-snoop响应通道a><a id="a2.3.2 snoop响应通道">A2.3.2 snoop响应通道</a></h5><p>snoop响应通道承载对DVM消息的响应。该通道上的信号具有前缀CR.</p><p><a id="表 a2.7">表 A2.7</a> snoop响应通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>CRVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>CRREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>CRTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr></tbody></table><h4 id=a-ida24-接口信号a24-接口信号a><a id="a2.4 接口信号">A2.4 接口信号</a></h4><p>接口级信号是非信道信号。每个接口最多可以有一组信号。</p><h5 id=a-ida241-时钟和复位信号a241-时钟和复位信号a><a id="a2.4.1 时钟和复位信号">A2.4.1 时钟和复位信号</a></h5><p>接口上的所有信号与全局时钟同步，并通过全局复位信号进行复位。</p><p><a id="表 a2.8">表 A2.8</a> 时钟和复位信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ACLK</strong></td><td>1</td><td>时钟源</td><td>全局时钟</td></tr><tr><td><strong>ARESETn</strong></td><td>1</td><td>复位源</td><td>全局复位</td></tr></tbody></table><h5 id=a-ida242-唤醒信号a242-唤醒信号a><a id="a2.4.2 唤醒信号">A2.4.2 唤醒信号</a></h5><p><a id="表 a2.9">表 A2.9</a> 唤醒信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWAKEUP</strong></td><td>1</td><td>主机</td><td>读写通道唤醒</td></tr><tr><td><strong>WCWAKEUP</strong></td><td>1</td><td>从机</td><td>snoop通道唤醒</td></tr></tbody></table><h5 id=a-ida243-qos接收信号a243-qos接收信号a><a id="a2.4.3 Qos接收信号">A2.4.3 Qos接收信号</a></h5><p>QoS接受信号可以被从机接口用于指示它接受的请求的最小QoS值。</p><p><a id="表 a2.10">表 A2.10</a> Qos接收信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>VAWQOSACCEPT</strong></td><td>4</td><td>从机</td><td>写请求的Qos值</td></tr><tr><td><strong>VARQOSACCEPT</strong></td><td>4</td><td>从机</td><td>读请求的Qos值</td></tr></tbody></table><h5 id=a-ida244-连贯性连接信号a244-连贯性连接信号a><a id="a2.4.4 连贯性连接信号">A2.4.4 连贯性连接信号</a></h5><p>连贯性连接信号由主机使用，以控制其是否接收AC通道上的DVM消息。</p><p><a id="表 a2.11">表 A2.11</a> 连贯性连接信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>SYSCOREQ</strong></td><td>1</td><td>主机</td><td>连贯性连接请求</td></tr><tr><td><strong>SYSCOACK</strong></td><td>1</td><td>从机</td><td>连贯性连接回应</td></tr></tbody></table><h5 id=a-ida245-接口控制信号a245-接口控制信号a><a id="a2.4.5 接口控制信号">A2.4.5 接口控制信号</a></h5><p>接口控制信号是主机接口的静态输入，可用于配置接口行为。</p><p><a id="表 a2.12">表 A2.12</a> 接口控制信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>BROADCASTATOMIC</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于原子事务</td></tr><tr><td><strong>BROADCASTSHAREABLE</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于可共享事务</td></tr><tr><td><strong>BROADCASTCACHEMAINT</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于维护操作</td></tr><tr><td><strong>BROADCASTCMOPOPA</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于 CleanInvalidPoPA CMO</td></tr><tr><td><strong>BROADCASTPERSIST</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于 CleanSharedPersist and CleanSharedDeepPersist</td></tr></tbody></table><h4 id=a-ida22-传输a22-传输a><a id="a2.2 传输">A2.2 传输</a></h4><p>本章描述了AXI中使用的通道传输
它包含以下部分：</p><ul><li><em><a href="#a3.1 时钟和复位">A3.1 时钟和复位</a></em></li><li><em><a href="#a3.2 通道握手">A3.2 通道握手</a></em></li><li><em><a href="#a3.3 读写通道">A3.3 读写通道</a></em></li><li><em><a href="#a3.4 通道关系">A3.4 通道关系</a></em></li><li><em><a href="#a3.5 通道握手依赖">A3.5 通道握手依赖</a></em></li><li><em><a href="#a3.6 snoop通道">A3.6 snoop通道</a></em></li></ul><h4 id=a-ida31-时钟和复位a31-时钟和复位a><a id="a3.1 时钟和复位">A3.1 时钟和复位</a></h4><p>本节描述了实现AXI全局时钟和复位信号<strong>ACLK</strong>和<strong>ARESETn</strong>的要求。</p><h5 id=a-ida311-时钟a311-时钟a><a id="a3.1.1 时钟">A3.1.1 时钟</a></h5><p>每个AXI接口都有一个单一的时钟信号<strong>ACLK</strong>。
所有输入信号在<strong>ACLK</strong>的上升沿被采样。
所有输出信号的变化只能在<strong>ACLK</strong>的上升沿之后发生。</p><p>在主机和从机之间，输入和输出信号之间必须没有组合路径。</p><h5 id=a-ida312-复位a312-复位a><a id="a3.1.2 复位">A3.1.2 复位</a></h5><p>AXI协议使用一个单一的低电平有效复位信号<strong>ARESETn</strong>。
复位信号可以异步地被断言，但解除断言只能在<strong>ACLK</strong>上升沿同步进行。
在复位期间，以下接口要求适用：</p><ul><li>主机必须将<strong>AWVALID</strong>、<strong>WVALID</strong>和<strong>ARVALID</strong>驱动为低。</li><li>从机必须将<strong>BVALID</strong>和<strong>RVALID</strong>驱动为低。</li><li>所有其他信号可以被驱动为任何值。</li></ul><p>复位后，主机被允许开始将<strong>AWVALID</strong>、<strong>WVALID</strong>和<strong>ARVALID</strong>
驱动为高的最早时刻是在<strong>ARESETn</strong>高后的<strong>ACLK</strong>上升沿。</p><p><em><a href="#图 a3.1">图 A3.1</a></em> 显示了复位后<strong>AWVALID</strong>、<strong>WVALID</strong>和<strong>ARVALID</strong>
可以被驱动为高的最早时间点 <em>b</em>。</p><p><a id="图 a3.1">图 A3.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.1_Exit_from_reset.png alt></a></p><h4 id=a-ida32-通道握手a32-通道握手a><a id="a3.2 通道握手">A3.2 通道握手</a></h4><p>所有AXI通道使用相同的<strong>VALID</strong>/<strong>READY</strong>握手过程来传输地址、数据和控制信息。
这种双向流控制机制意味着主机和从机都可以控制信息在主机和从机之间移动的速率。
源生成<strong>VALID</strong>信号以指示地址、数据或控制信息可用。
目标生成<strong>READY</strong>信号以指示它可以接受信息。
仅当<strong>VALID</strong>和<strong>READY</strong>信号均为高电平时，传输才会发生。</p><p>在主机和从机之间，输入信号和输出信号之间必须没有组合路径。
<em><a href="#图 a3.2">图 A3.2</a></em> 到 <em><a href="#图 a3.4">图 A3.4</a></em> 展示了握手过程的示例。</p><p>源可以在<strong>READY</strong>被断言之前就断言<strong>VALID</strong>。</p><p>源在边缘1之后呈现信息，并如 <em><a href="#图 a3.2">图 A3.2</a></em> 所示声明<strong>VALID</strong>信号。
目标在边缘2之后声明<strong>READY</strong>信号。
源必须保持其信息稳定，直到在边缘3时发生传输，此时该声明被识别。</p><p><a id="图 a3.2">图 A3.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.2_VALID_before_READY_handshake.png alt></a></p><p>源不能在断言<strong>VALID</strong>之前去等待<strong>READY</strong>被断言。</p><blockquote><p>Note：
也就是说源不能依靠等待<strong>READY</strong>被断言之后才去断言<strong>VALID</strong>。</p></blockquote><p>当<strong>VALID</strong>被断言时，它必须保持断言状态直到握手发生，
握手发生在<strong>VALID</strong>和<strong>READY</strong>同时被断言的上升时钟边缘。</p><p>在 <em><a href="#图 a3.3">图 A3.3</a></em> 中，目标在边缘1之后断言<strong>READY</strong>，在地址、数据或控制信息有效之前。
这一确认表明它可以接受信息。源在边缘2之后提供信息并断言<strong>VALID</strong>，然后在边缘3时被识别时进行传输。
在这种情况下，传输发生在一个周期内。</p><p><a id="图 a3.3">图 A3.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.3_READY_before_VALID_handshake.png alt></a></p><p>允许目的在相应的<strong>READY</strong>断言之前等待<strong>VALID</strong>被断言。</p><p>如果<strong>READY</strong>被断言，它被允许<strong>VALID</strong>断言之前解除断言<strong>READY</strong>。
在 <em><a href="#图 a3.4">图 A3.4</a></em> 中，源和目的地恰好都表示它们在边缘1之后可以传送地址、数据或控制信息。
在这种情况下，传输发生在<strong>VALID</strong>和<strong>READY</strong>同时被断言的上升时钟边缘。这意味着传输发生在边缘2。</p><p><a id="图 a3.4">图 A3.4
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.4_VALID_with_READY_handshake.png alt></a></p><p>个别AXI通道握手机制在 <em><a href="#a3.4 通道关系">A3.4 通道关系</a></em> 中描述。</p><blockquote><p>Note：</p><ul><li><strong>VALID</strong>不能等待<strong>READY</strong>，</li><li><strong>READY</strong>可以等待<strong>VALID</strong>。</li></ul></blockquote><h4 id=a-ida33-读写通道a33-读写通道a><a id="a3.3 读写通道">A3.3 读写通道</a></h4><p>这一部分描述了AXI写通道和读通道。通道如下：</p><ul><li><em><a href="#a3.3.1 写请求通道">A3.3.1 写请求通道</a></em></li><li><em><a href="#a3.3.2 写数据通道">A3..3.2 写数据通道</a></em></li><li><em><a href="#a3.3.3 写响应通道">A3.3.3 写响应通道</a></em></li><li><em><a href="#a3.3.4 读请求通道">A3.3.4 读请求通道</a></em></li><li><em><a href="#a3.3.5 读数据通道">A3.3.5 读数据通道</a></em></li></ul><p>对于使用 <em><a href="#a15.3 dvm 消息">A15.3 dvm 消息</a></em> 的接口，额外有两个通道：</p><ul><li><em><a href="#a3.6.1 snoop请求通道（ac）">A3.6.1 snoop 请求通道（ac）</a></em></li><li><em><a href="#a3.6.2 snoop响应通道（cr）">A3.6.2 snoop响应通道（cr）</a></em></li></ul><h5 id=a-ida331-写请求通道awa331-写请求通道awa><a id="a3.3.1 写请求通道（aw）">A3.3.1 写请求通道（aw）</a></h5><p>写请求通道的控制信号如 <em><a href="#表 a3.1">表 A3.1</a></em> 所示。</p><p><a id="表 a3.1">表 A3.1</a> 写请求通道控制信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWVALID</strong></td><td>1</td><td>主机</td><td>写请求有效</td></tr><tr><td><strong>AWREADY</strong></td><td>1</td><td>从机</td><td>写请求就绪</td></tr></tbody></table><p>当主机驱动有效请求时，可以断言<strong>AWVALID</strong>信号。
当被断言时，<strong>AWVALID</strong>必须保持断言状态，直到从机在上升时钟边缘断言<strong>AWREADY</strong>。</p><p><strong>AWREADY</strong>的默认状态可以是高或低。
建议将<strong>AWREADY</strong>的默认状态设置为高。
当<strong>AWREADY</strong>为高时，从机必须能够接受呈现给它的任何有效请求。</p><p>不建议将<strong>AWREADY</strong>默认设置为低，因为这会强制传输至少需要两个周期，
一个周期用于断言<strong>AWVALID</strong>，另一个周期用于断言<strong>AWREADY</strong>。</p><h5 id=a-ida332-写数据通道wa332-写数据通道wa><a id="a3.3.2 写数据通道（w）">A3.3.2 写数据通道（w）</a></h5><p>写数据通道的控制信号如 <em><a href="#表 a3.2">表 A3.2</a></em> 所示。</p><p><a id="表 a3.2">表 A3.2</a> 写数据通道控制信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>WVALID</strong></td><td>1</td><td>主机</td><td>写数据有效</td></tr><tr><td><strong>WREADY</strong></td><td>1</td><td>从机</td><td>写数据就绪</td></tr><tr><td><strong>WLAST</strong></td><td>1</td><td>主机</td><td>写事务最后一个传输</td></tr></tbody></table><p>在写事务期间，主机只能在其驱动有效写数据时断言<strong>WVALID</strong>信号。
当断言时，<strong>WVALID</strong>必须保持断言状态，
直到从机断言<strong>WREADY</strong>之后的上升时钟边缘。</p><p><strong>WREADY</strong>的默认状态可以是高，但前提是从机始终能够在单个周期内接受写数据。</p><p>主机在驱动事务中的最后写传输时必须断言<strong>WLAST</strong>信号。</p><p>建议对于非活跃的字节通道，将<strong>WDATA</strong>驱动为零。</p><p>未使用<strong>WLAST</strong>的从机可以省略其接口中的输入。
属性WLAST_Present用于确定<strong>WLAST</strong>信号是否存在。</p><p><a id="表 a3.3">表 A3.3</a> WLAST_Present 属性</p><table><thead><tr><th>WLAST_Present</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>WLAST</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>WLAST</strong>不存在</td></tr></tbody></table><h5 id=a-ida333-写响应通道ba333-写响应通道ba><a id="a3.3.3 写响应通道（b）">A3.3.3 写响应通道（b）</a></h5><p>写响应通道的控制信号如 <em><a href="#表 a3.4">表 A3.4</a></em> 所示。</p><p><a id="表 a3.4">表 A3.4</a> 写响应通道控制信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>BVALID</strong></td><td>1</td><td>从机</td><td>写响应信号有效</td></tr><tr><td><strong>BREADY</strong></td><td>1</td><td>主机</td><td>写响应信号就绪</td></tr></tbody></table><p>从机只能在驱动有效写响应时断言<strong>BVALID</strong>信号。
当断言时，<strong>BVALID</strong>必须保持断言状态，
直到主机断言<strong>BREADY</strong>后的上升时钟边缘。</p><p><strong>BREADY</strong>BREADY的默认状态可以是高电平，但是前提是主机必须始终能在一个周期内接受写响应。</p><h5 id=a-ida334-读请求通道a334-读请求通道a><a id="a3.3.4 读请求通道">A3.3.4 读请求通道</a></h5><p>读取请求通道的控制信号如 <em><a href="#表 a3.5">表 A3.5</a></em> 所示。</p><p><a id="表 a3.5">表 A3.5</a> 读请求控制信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ARVALID</strong></td><td>1</td><td>主机</td><td>读请求有效</td></tr><tr><td><strong>ARREADY</strong></td><td>1</td><td>从机</td><td>读请求就绪</td></tr></tbody></table><p>主机只能在发出有效读请求时断言<strong>ARVALID</strong>信号。
一旦断言，<strong>ARVALID</strong>必须保持断言状态，直到从机在上升时钟边缘断言<strong>ARREADY</strong>信号。</p><p><strong>ARREADY</strong>的默认状态可以是高或低。
建议将<strong>ARREADY</strong>的默认状态设置为高。
如果<strong>ARREADY</strong>为高，则从机必须能够接受任何呈现给它的有效读请求。</p><p>不建议将<strong>ARREADY</strong>设为低，因为这会使传输至少需要两个周期，一个用于将<strong>ARVALID</strong>置为有效，
另一个用于将<strong>ARREADY</strong>置为有效</p><h5 id=a-ida235-读数据通道ra235-读数据通道ra><a id="a2.3.5 读数据通道（r）">A2.3.5 读数据通道（r）</a></h5><p>读取数据通道的控制信号如 <em><a href="#表 a3.6">表 A3.6</a></em> 所示</p><p><a id="表 a3.6 读数据通道控制信号">表 A3.6 读数据通道控制信号</a></p><table><thead><tr><th>信号名</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>RVALID</strong></td><td>1</td><td>从机</td><td>读数据有效</td></tr><tr><td><strong>RREADY</strong></td><td>1</td><td>主机</td><td>读数据就绪</td></tr><tr><td><strong>RLAST</strong></td><td>1</td><td>从机</td><td>读事务中的最后一个传输</td></tr></tbody></table><p>从机仅在驱动读取数据通道上的有效信号时才能断言<strong>RVALID</strong>信号。
当<strong>RVALID</strong>被断言时，它必须保持断言状态，直到主机断言<strong>ARREADY</strong>RREADY后的上升时钟边缘。
即使从机只有一个读取数据源，它也必须仅在响应请求时断言<strong>RVALID</strong>信号。</p><p>主机使用信号<strong>RREADY</strong>指示它接受数据。
<strong>RREADY</strong>的默认状态可以是高，但只有在主机能够在开始读取事务且立即接受读取数据时。</p><p>每当从机驱动事务中的最终读取传输时，必须断言<strong>RLAST</strong>信号。
建议对不活动的字节通道将<strong>RDATA</strong>驱动为零。</p><p>不使用<strong>RLAST</strong>的主机可以从其接口中省略该输入。属性RLAST_Present用于确定<strong>RLAST</strong>信号是否存在。</p><p><a id="表 a3.7">表 A3.7</a> RLAST_Present 属性</p><table><thead><tr><th>RLAST_Present</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>RLAST</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>RLAST</strong>不存在</td></tr></tbody></table><h4 id=a-ida34-通道关系a34-通道关系a><a id="a3.4 通道关系">A3.4 通道关系</a></h4><p>AXI协议要求保持以下关系：</p><ul><li>写响应必须始终跟随写事务中的最后一次写传输。</li><li>读数据和读响应必须始终跟随读请求。</li><li>通道握手必须符合 <em><a href="#a3.5 通道握手依赖关系">A3.5 通道握手依赖关系</a></em> 定义。</li><li>当主机发出写请求时，必须能够提供该事务的所有写数据，而不依赖于该主机的其他事务。</li><li>当主机已发出写请求并提供所有写数据时，必须能够接受该事务的所有响应，而不依赖于该主机的其他事务。</li><li>当主机已发出读请求时，必须能够接受该事务的所有读数据，而不依赖于该主机的其他事务。</li></ul><blockquote><p>Note：主机可以依赖于使用相同ID的事务按顺序返回读数据，因此主机只需要足够的存储空间来存储具有不同ID的事务的读数据。</p></blockquote><ul><li>主机被允许在发出另一个事务请求之前等待一个事务完成。</li><li>从机被允许在接受或发出另一个事务的传输之前等待一个事务完成。</li><li>从机不能因带有前导写数据的事务而阻止接受无数据的写请求。</li></ul><p>该协议未定义通道之间的其他关系。</p><p>缺乏关系意味着写数据可以在写请求之前出现在接口处。
如果写请求通道包含比写数据通道更多的寄存器级别，就会发生这种情况。
同样，写数据可能在与写请求相同的周期内出现。</p><p>当互连需要确定目标地址空间或从机空间时，必须重新对齐请求和写数据。
此重新对齐是为了确保写数据仅向被标记为有效的从机发送。</p><h4 id=a-ida35-通道握手依赖关系a35-通道握手依赖关系a><a id="a3.5 通道握手依赖关系">A3.5 通道握手依赖关系</a></h4><p>通道之间存在写、读和snoop事务的依赖关系。这些在下面的章节中进行了描述，并包含依赖图，其中：</p><ul><li>单箭头指向可以在箭头起始信号之前或之后被断言的信号。</li><li>双箭头指向必须在箭头起始信号断言之后才能被断言的信号。</li></ul><h5 id=a-ida351-写事务依赖a351-写事务依赖a><a id="a3.5.1 写事务依赖">A3.5.1 写事务依赖</a></h5><p>对于写通道上的事务， <em><a href="#图 a3.5">图 A3.5</a></em> 显示了握手信号的依赖关系。规则如下：</p><ul><li><a id=a3.5.1.1>A3.5.1.1</a> 主机在断言<strong>AWVALID</strong>或<strong>WVALID</strong>
之前不得等待从机断言<strong>AWREADY</strong>或<strong>WREADY</strong>。这适用于事务中的每个写数据传输。</li><li><a id=a3.5.1.2>A3.5.1.2</a> 从机可以在断言<strong>AWREADY</strong>之前等待<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者。</li><li><a id=a3.5.1.3>A3.5.1.3</a> 从机可以在<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者被断言之前断言<strong>AWREADY</strong>。</li><li><a id=a3.5.1.4>A3.5.1.4</a> 从机可以在断言<strong>WREADY</strong>之前等待<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者。</li><li><a id=a3.5.1.5>A3.5.1.5</a> 从机可以在<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者被断言之前断言<strong>WREADY</strong>。</li><li><a id=a3.5.1.6>A3.5.1.6</a> 从机必须在断言<strong>BVALID</strong>之前等待
<strong>AWVALID</strong>、<strong>AWREADY</strong>、<strong>WVALID</strong>和<strong>WREADY</strong>被断言。</li><li><a id=a3.5.1.7>A3.5.1.7</a> 从机还必须在断言<strong>BVALID</strong>之前等待<strong>WLAST</strong>被断言。
这是因为写响应<strong>BRESP</strong>必须在写事务的最后一次数据传输之后发送信号。</li><li><a id=a3.5.1.8>A3.5.1.8</a> 从机不得在断言<strong>BVALID</strong>之前等待主机断言<strong>BREADY</strong>。</li><li><a id=a3.5.1.9>A3.5.1.9</a> 主机可以在断言<strong>BREADY</strong>之前等待<strong>BVALID</strong>。</li><li><a id=a3.5.1.10>A3.5.1.10</a> 主机可以在<strong>BVALID</strong>被断言之前断言<strong>BREADY</strong>。</li></ul><p><a id="图 a3.5">图 A3.5
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.5_Write_transaction_handshake_dependencies.png alt></a></p><h5 id=a-ida352-读事务依赖a352-读事务依赖a><a id="a3.5.2 读事务依赖">A3.5.2 读事务依赖</a></h5><p>对于读取通道上的事务，<em><a href="#图 a3.6">图 A3.6</a></em> 显示了握手信号的依赖关系。规则如下：</p><ul><li><a id=a3.5.2.1>A3.5.2.1</a> 主机在断言<strong>ARVALID</strong>之前不得等待从机断言<strong>ARREADY</strong>。</li><li><a id=a3.5.2.2>A3.5.2.2</a> 从机可以在断言<strong>ARREADY</strong>之前等待<strong>ARVALID</strong>被断言。</li><li><a id=a3.5.2.3>A3.5.2.3</a> 从机可以在<strong>ARVALID</strong>被断言之前断言<strong>ARREADY</strong>。</li><li><a id=a3.5.2.4>A3.5.2.4</a> 从机必须等到<strong>ARVALID</strong>和<strong>ARREADY</strong>都被断言后，
才能断言<strong>RVALID</strong>以指示有效数据可用。</li><li><a id=a3.5.2.5>A3.5.2.5</a> 从机不得等待主机断言<strong>RREADY</strong>后再断言<strong>RVALID</strong>。</li><li><a id=a3.5.2.6>A3.5.2.6</a> 主机可以在断言<strong>RREADY</strong>之前等待<strong>RVALID</strong>被断言。</li><li><a id=a3.5.2.7>A3.5.2.7</a> 主机可以在<strong>RVALID</strong>被断言之前断言<strong>RREADY</strong>。</li></ul><p><a id="图 a3.6">图 A3.6
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.6_Read_transaction_handshake_dependencies.png alt></a></p><p>总结：</p><ul><li>断言<strong>VALID</strong>不等断言<strong>READY</strong>：</br><em><a href=#a3.5.1.1>A3.5.1.1</a></em> 写请求和写</br><em><a href=#a3.5.1.8>A3.5.1.8</a></em> 写响应</br><em><a href=#a3.5.2.1>A3.5.2.1</a></em> 读请求</br><em><a href=#a3.2.2.5>A3.2.2.5</a></em> 读</br><em><a href=#a3.6.3.1>A3.6.3.1</a></em> snoop请求</br><em><a href=#a3.6.3.5>A3.6.3.5</a></em> snoop响应</li><li>断言<strong>READY</strong>可等断言<strong>VALID</strong>：</br><em><a href=#a3.5.1.2>A3.5.1.2</a></em> 写请求和写</br><em><a href=#a3.5.1.9>A3.5.1.9</a></em> 写响应</br><em><a href=#a3.5.1.4>A3.5.1.4</a></em> 写请求和写</br><em><a href=#a3.5.2.2>A3.5.2.2</a></em> 读请求</br><em><a href=#a3.5.2.6>A3.5.2.6</a></em> 读</br><em><a href=#a3.6.3.2>A3.6.3.2</a></em> snoop请求</br><em><a href=#a3.6.3.6>A3.6.3.6</a></em> snoop响应</li><li>断言<strong>VALID</strong>和断言<strong>READY</strong>没有先后关系：</br><em><a href=#a3.5.1.3>A3.5.1.3</a></em> 写请求和写</br><em><a href=#a3.5.1.5>A3.5.1.5</a></em> 写请求和写</br><em><a href=#a3.5.1.10>A3.5.1.10</a></em> 写响应</br><em><a href=#a3.5.2.3>A3.5.2.3</a></em> 读请求</br><em><a href=#a3.5.2.7>A3.5.2.7</a></em> 读</br><em><a href=#a3.6.3.3>A3.6.3.3</a></em> snoop请求</br><em><a href=#a3.6.3.6>A3.6.3.7</a></em> snoop响应</li><li>断言<strong>BVALID</strong>必须在写传输完成之后：</br><em><a href=#a3.5.1.6>A3.5.1.6</a></em> 写响应在写请求和写之前</br><em><a href=#a3.5.1.7>A3.5.1.7</a></em> 写响应在最后一笔写传输之前</br></li><li>断言<strong>RVALID</strong>必须在<strong>ARVALID</strong>和<strong>ARREADY</strong>断言之后：</br><em><a href=#a3.5.2.4>A3.5.2.4</a></em> 读有效在读请求有效和就绪之前</li><li>断言<strong>CRVALID</strong>必须在<strong>ACVALID</strong>和<strong>ACREADY</strong>断言之后：</br><em><a href=#a3.6.3.4>A3.6.3.4</a></em> snoop响应有效在snoop请求有效和就绪之前</li></ul><h4 id=a-ida36-snoop通道a36-snoop通道a><a id="a3.6 snoop通道">A3.6 snoop通道</a></h4><p>DVM消息在互连和管理组件之间通过snoop通道传输。
当支持DVM消息时，会有一个snoop请求通道（AC）和一个snoop响应通道（CR）。</p><h5 id=a-ida361-snoop请求通道aca361-snoop请求通道aca><a id="a3.6.1 snoop请求通道（ac）">A3.6.1 snoop请求通道（ac）</a></h5><p>snoop请求通道的控制信号如 <em><a href="#表 a3.8">表 A3.8</a></em> 所示。</p><p><a id="表 a3.8">表 A3.8</a> snoop请求通道控制</p><table><thead><tr><th>信号名</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ACVALID</strong></td><td>1</td><td>从机</td><td>snoop请求有效</td></tr><tr><td><strong>ACREADY</strong></td><td>1</td><td>主机</td><td>snoop请求就绪</td></tr></tbody></table><p>从机只能在驱动有效地址和控制信息时断言<strong>ACVALID</strong>信号。
当<strong>ACVALID</strong>被断言时，它必须保持断言状态，直到主机断言<strong>ACREADY</strong>信号的上升时钟边缘。</p><p><strong>ACREADY</strong>的默认状态可以是高或低。
建议将<strong>ACREADY</strong>的默认状态设置为高。
如果<strong>ACREADY</strong>为高，则主机必须能够接受任何呈现给它的有效请求。</p><p>不推荐将<strong>ACREADY</strong>的默认状态设置为低，因为这会迫使传输至少需要两个时钟周期，
一个用于断言<strong>ACVALID</strong>，另一个用于断言<strong>ACREADY</strong>。</p><h5 id=a-ida362-snoop响应信号cra362-snoop响应信号cra><a id="a3.6.2 snoop响应信号（cr）">A3.6.2 snoop响应信号（cr）</a></h5><p>snoop响应通道的控制信号如 <em><a href="#表 a3.9">表 A3.9</a></em> 所示。</p><p><a id="表 a3.9">表 A3.9</a> snoop响应信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>CRVALID</strong></td><td>1</td><td>主机</td><td>snoop响应有效</td></tr><tr><td><strong>CRREADY</strong></td><td>1</td><td>从机</td><td>snoop响应就绪</td></tr></tbody></table><p>主机只有在它在snoop响应通道上驱动有效信号时才能断言<strong>CRVALID</strong>CRVALID信号。
当<strong>CRVALID</strong>被断言时，必须保持断言状态，直到从机断言<strong>CRREADY</strong>后的时钟上升沿。</p><p>从机使用<strong>CRREADY</strong>信号表示它接受响应。
<strong>CRREADY</strong>的默认状态可以为高，但前提是从机能够在开始snoop事务时立即接受snoop响应。</p><h5 id=a-ida363-snoop事务依赖a363-snoop事务依赖a><a id="a3.6.3 snoop事务依赖">A3.6.3 snoop事务依赖</a></h5><p>对于snoop通道上的事务，<em><a href="#图 a3.7">图 A3.7</a></em> 显示了握手信号依赖关系。规则如下：</p><ul><li><a id=a3.6.3.1>A3.6.3.1</a> 从机在断言<strong>ACVALID</strong>之前不得等待主机断言<strong>ACREADY</strong>。</li><li><a id=a3.6.3.2>A3.6.3.2</a> 主机可以在断言<strong>ACREADY</strong>之前等待<strong>ACVALID</strong>被断言。</li><li><a id=a3.6.3.3>A3.6.3.3</a> 主机可以在<strong>ACVALID</strong>被断言之前断言<strong>ACREADY</strong>。</li><li><a id=a3.6.3.4>A3.6.3.4</a> 主机必须等待<strong>ACVALID</strong>和<strong>ACREADY</strong>都被断言后才能断言<strong>CRVALID</strong>，以表示有效响应可用。</li><li><a id=a3.6.3.5>A3.6.3.5</a> 主机不得等待从机断言<strong>CRREADY</strong>后再断言<strong>CRVALID</strong>。</li><li><a id=a3.6.3.6>A3.6.3.6</a> 从机可以在断言<strong>CRREADY</strong>之前等待<strong>CRVALID</strong>被断言。</li><li><a id=a3.6.3.7>A3.6.3.7</a> 从机可以在<strong>CRVALID</strong>被断言之前断言<strong>CRREADY</strong>。</li></ul><p><a id="图 a3.7">图 A3.7
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.7_Snoop_transaction_handshake_dependencies.png alt></a></p><h3 id=a-ida第4章-事务a第4章-事务a><a id="a第4章 事务">A第4章 事务</a></h3><p>AXI协议使用事务在主机和从机之间进行通信。
所有事务包括请求和响应。</p><p>写和读事务也包括一个或多个数据传输。</p><p>本章描述了事务请求、响应和数据传输。它包含以下几个部分</p><ul><li><em><a href="#a4.1 事务请求">A4.1 事务请求</a></em></li><li><em><a href="#a4.2 读写数据">A4.2 读写数据</a></em></li><li><em><a href="#a4.3 事务响应">A4.3 事务响应</a></em></li></ul><h4 id=a-ida41-事务请求a41-事务请求a><a id="a4.1 事务请求">A4.1 事务请求</a></h4><p>AXI主机通过向从机发出请求来启动事务。
请求包括事务属性和第一次数据传输的地址。
如果事务包含多个数据传输，从机必须计算后续传输的地址。</p><p>事务不得跨越4KB地址边界，这防止了事务跨越两个从机之间的边界。
这也限制了从机必须支持的地址增量数量。</p><h5 id=a-ida411-大小属性a411-大小属性a><a id="a4.1.1 大小属性">A4.1.1 大小属性</a></h5><p>size表示每次数据传输中的最大字节数.</p><p>对于读取事务，size表示每次读取数据传输中必须有效的数据字节数.</p><p>对于写入事务，size表示允许活动的数据字节通道数，<strong>WSTRB</strong> 指示在每次传输中哪些字节是有效的。</p><p>size不得超过接口的数据宽度，这由DATA_WIDTH属性确定。</p><p>如果size小于DATA_WIDTH，则在每次传输中使用字节通道的一个子集。</p><p>size通过写请求和读请求通道上的<strong>AWSIZE</strong>和<strong>ARSIZE</strong>信号进行传达，
在本规范中，<strong>AxSIZE</strong>表示<strong>AWSIZE</strong>和<strong>ARSIZE</strong>。</p><p><a id="表 a4.1">表 A4.1</a> <strong>AxSIZE</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWSIZE</strong></br><strong>ARSIZE</strong></td><td>3</td><td>DATA_WIDTH/8</td><td>一个事务中每次传输的最大字节数</td></tr></tbody></table><p>size通过<strong>AxSIZE</strong>信号进行编码，如 <em><a href="#表 a4.2">表 A4.2</a></em> 所示。</p><table><thead><tr><th><strong>AxSIZE</strong></th><th>标签</th><th>意义</th></tr></thead><tbody><tr><td>0b000</td><td>1</td><td>每次传输最多1Byte</td></tr><tr><td>0b001</td><td>2</td><td>每次传输最多2Byte</td></tr><tr><td>0b010</td><td>4</td><td>每次传输最多4Byte</td></tr><tr><td>0b011</td><td>8</td><td>每次传输最多8Byte</td></tr><tr><td>0b100</td><td>16</td><td>每次传输最多16Byte</td></tr><tr><td>0b101</td><td>32</td><td>每次传输最多32Byte</td></tr><tr><td>0b110</td><td>64</td><td>每次传输最多64Byte</td></tr><tr><td>0b111</td><td>128</td><td>每次传输最多128Byte</td></tr></tbody></table><p>如 <em><a href="#表 a4.3">表 A4.3</a></em> 所示，属性 SIZE_Present 用于确定 <strong>AxSIZE</strong> 信号是否存在。</p><p><a id="表 a4.3">表 A4.3</a> SIZE_Present 属性</p><table><thead><tr><th>SIZE_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWSIZE</strong>和<strong>ARSIZE</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWSIZE</strong>和<strong>ARSIZE</strong>不存在</td></tr></tbody></table><p>一个只发出全数据宽度请求的主机可以从其接口中省略<strong>AxSIZE</strong>输出。
相应的从机必须根据数据宽度将其<strong>AxSIZE</strong>输入连接起来。</p><h5 id=a-ida412-长度属性a412-长度属性a><a id="a4.1.2 长度属性">A4.1.2 长度属性</a></h5><p>Length属性定义了事务中的数据传输次数。</p><p>Size x Length是一个事务中可以传输的最大字节数。如果地址未对齐或存在未使能的<strong>WSTRB</strong>，实际传输的字节数可能低于Size x Length。</p><p>主机必须根据Length发出写数据传输的数量。</p><p>从机必须根据Length发出读数据传输的数量。</p><p>Length通过写请求和读请求通道上的<strong>AWLEN</strong>和<strong>ARLEN</strong>信号进行通信。</p><p>在本规范中<strong>AxLEN</strong>表示<strong>AWLEN</strong>和<strong>ARLEN</strong>，如 <em><a href="#表 a4.4">表 A4.4</a></em> 所示。</p><p><a id="表 a4.4">表 A4.4</a> <strong>AxLEN</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWLEN</strong><br><strong>ARLEN</strong></td><td>8</td><td>0x00</td><td>事务的传输数量，Length=AxLEN+1</td></tr></tbody></table><p>属性 LEN_Present 用于确定信号是否存在，<em><a href="#表 a4.5">表 A4.5</a></em> 显示了 LEN_Present 的合法值。</p><p><a id="表 a4.5">表 A4.5</a> LEN_Present属性</p><table><thead><tr><th>LEN_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWLEN</strong>和 <strong>ARLEN</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWLEN</strong>和 <strong>ARLEN</strong>不存在</td></tr></tbody></table><p>一个只发出长度为1请求的主机可以从其接口中省略<strong>AxLEN</strong>输出。
相应的下属必须将其<strong>AxLEN</strong>输入连接到0x00。以下规则适用于事务长度：</p><ul><li>对于wrap突发，长度可以是2、4、8或16。</li><li>对于固定突发，长度可以达到16。</li><li>事务不得跨越4KB地址边界。</li><li>不支持事务的提前终止。</li></ul><p>没有组件可以提前终止事务。
然而，为了减少写事务中的数据传输次数，主机可以通过取消所有<strong>WSTRB</strong>的有效状态来禁用进一步的写入。
在这种情况下，主机必须完成事务中的其余传输。
在读取事务中，主机可以丢弃读取数据，但必须完成事务中的所有传输。</p><h5 id=a-ida413-事务的最大传输byea413-事务的最大传输byea><a id="a4.1.3 事务的最大传输bye">A4.1.3 事务的最大传输bye</a></h5><p>一个事务的最大字节数为4KB，事务不允许跨越4KB边界。
然而，许多主机生成的事务可能始终小于此值。</p><p>一个从机或互连可能会从这些信息中受益。例如，一个从机可借此优化一些解码逻辑。
一个在小于4KB粒度下进行条带化的互连如果知道事务不会跨越条带边界，可能能够避免突发拆分。</p><p>属性Max_Transaction_Bytes定义了一个事务的最大字节数，如 <em><a href="#表 a4.6">表 A4.6</a></em> 所示。</p><p><a id="表 a4.6">表 A4.6</a> Max_Transaction_Bytes 属性</p><table><thead><tr><th>名字</th><th>值</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>Max_Transaction_Bytes</td><td>64,128,256,512,1024048,4096</td><td>4096</td><td>一个主机发起的事务大小与长度之积不得超过最大传输字节数，且传输不得跨越最大传输字节数的边界。<br>一个从机只能接受大小与长度之积不超过最大传输字节数的传输。</td></tr></tbody></table><p>在连接主机和从机时，<em><a href="#表 a4.7">表 A4.7</a></em> 指示了兼容的 Max_Transaction_Bytes 组合。</p><p><a id="表 a4.7">表 A4.7</a> Max_Transaction_Bytes 互联</p><table><thead><tr><th>主机 &lt; 从机</th><th>主机 == 从机</th><th>主机 > 从机</th></tr></thead><tbody><tr><td>兼容</td><td>兼容</td><td>不兼容</td></tr></tbody></table><h5 id=a-ida414-突发属性a414-突发属性a><a id="a4.1.4 突发属性">A4.1.4 突发属性</a></h5><p>Burst属性描述了在事务中传输之间地址的递增方式。有三种不同的Burst类型：</p><ul><li><p>固定（FIXED）</br>此Burst类型用于对同一位置的重复访问，例如在加载或清空FIFO时。</p><ul><li>在Burst中的每次传输的地址都相同。</li><li>有效的字节通道对于所有传输都是恒定的。然而，在这些字节通道内，实际的<strong>WSTRB</strong>有效的字节在每次传输中可能不同。</li><li>Burst的长度可以达到16次传输。</li><li>固定Burst类型仅可与WriteNoSnoop或ReadNoSnoop操作码一起使用。
有关更多信息，请参见 <em><a href=#a第8章请求操作码>A第8章请求操作码</a></em> 。</li></ul></li><li><p>增量（INCR）</br>对于此Burst类型，每次传输的地址是前一次传输地址的递增。
递增值取决于事务的大小。例如，对于对齐的起始地址，事务中每次传输的地址是前一个地址加4。此Burst类型用于对正常顺序内存的访问。</p></li><li><p>回环（WRAP）</br></p><ul><li>此Burst类型类似于增量，除了在达到上限地址时地址会回环到较低的地址。适用以下限制：<ul><li>起始地址必须与每次传输的大小对齐。</li><li>Burst的长度必须为2、4、8或16次传输。</br></li></ul></li><li>回环事务的行为是：<ul><li>事务访问的最低地址是与要传输的数据总大小对齐的起始地址，即Size * Length。此地址被定义为回环边界。</li><li>每次传输后，地址的递增方式与增量Burst相同。然而，如果这个递增的地址是((回环边界) + (Size * Length))，则地址会回环到回环边界。</li><li>事务中的第一次传输可以使用高于回环边界的地址，前提是遵守适用于回环事务的限制。
当第一次地址高于回环边界时，地址会回环。此Burst类型用于缓存行访问。</li></ul></li></ul></li></ul><p>通过<strong>AWBURST</strong>和<strong>ARBURST</strong>信号分别在写请求和读请求通道上传达Burst。
在本规范中，<strong>AxBURST</strong>指示<strong>AWBURST</strong>和<strong>ARBURST</strong>。</p><p><a id="表 a4.8">表 A4.8</a> <strong>AxBURST</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWBURST</strong><br><strong>ARBURST</strong></td><td>2</td><td>0b01（INCR）</td><td>描述了事务中传输之间地址递增方式</td></tr></tbody></table><p>Burst在<strong>AxBURST</strong>信号上进行编码如 <em><a href="#表 a4.9">表 A4.9</a></em> 所示。</p><p><a id="表 a4.9">表 A4.9</a> <strong>AxBURST</strong>编码</p><table><thead><tr><th><strong>AxBURST</strong></th><th>标签</th><th>意义</th></tr></thead><tbody><tr><td>0b00</td><td>FIXED</td><td>固定突发</td></tr><tr><td>0101</td><td>INCR</td><td>增量突发</td></tr><tr><td>0b10</td><td>WRAP</td><td>回环突发</td></tr><tr><td>0b11</td><td>保留</td><td>-</td></tr></tbody></table><p>属性BURST_Present用于确定<strong>AxBURST</strong>信号是否存在。
只发出类型为INCR的Burst请求的主机可以从其接口中省略<strong>AxBURST</strong>输出。
相应的从机必须将其<strong>AxBURST</strong>输入连接到0b01。</p><p><a id="表 a4.10">表 A4.10</a> BURST_Present属性</p><table><thead><tr><th>BURST_Present</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWBURST</strong>和<strong>ARBURST</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWBURST</strong>和<strong>ARBURST</strong>不存在</td></tr></tbody></table><p>一种突发类型的固定不常用属性，并在 <em><a href="#表 a4.11">表 A4.11</a></em> 中定义了属性Fixed_Burst_Disable以指示组件是否支持它。</p><p><a id="表 a4.11">表 A4.11</a> Fixed_Burst_Disable属性</p><table><thead><tr><th>Fixed_Burst_Disable</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>突发类型为FIXED的请求不支持由从机生成，也不由主机生成</td></tr><tr><td>False</td><td>Y</td><td>突发类型为FIXED的请求支持由从机生成，或主机生成</td></tr></tbody></table><p>根据 Fixed_Burst_Disable 属性的值，<em><a href="#表 a4.12">表 A4.12</a></em> 显示了主机和从机之间的兼容性。</p><p><a id="表 a4.12">表 A4.12</a>Fixed_Burst_Disable 兼容性</p><table><thead><tr><th>Fixed_Burst_Disable</th><th>从机：False</th><th>从机True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>不兼容</td></tr><tr><td>主机：True</td><td>兼容</td><td>兼容</td></tr></tbody></table><h5 id=a-ida415-传输地址a415-传输地址a><a id="a4.1.5 传输地址">A4.1.5 传输地址</a></h5><hr><ul class=pager><li class=previous><a href=/icer/post/git%E5%B0%8F%E7%9F%A5%E8%AF%86/ data-toggle=tooltip data-placement=top title="Git 小知识">&larr;
Previous Post</a></li><li class=next><a href=/icer/post/amba5-apb-%E7%9F%A5%E8%AF%86%E6%8F%90%E7%BA%B2/ data-toggle=tooltip data-placement=top title="AMBA5 APB 知识提纲">Next
Post &rarr;</a></li></ul><script src=https://giscus.app/client.js data-repo=ICJJ/icer data-repo-id=R_kgDOMWEQRg data-category=General data-category-id=DIC_kwDOMWEQRs4CgyrH data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light data-lang=en crossorigin=anonymous async></script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/icer/tags/ahb title=ahb>ahb
</a><a href=/icer/tags/amba title=amba>amba
</a><a href=/icer/tags/amba5 title=amba5>amba5
</a><a href=/icer/tags/apb title=apb>apb
</a><a href=/icer/tags/axi title=axi>axi
</a><a href=/icer/tags/bus title=bus>bus
</a><a href=/icer/tags/git title=git>git
</a><a href=/icer/tags/html title=html>html
</a><a href=/icer/tags/i2c title=i2c>i2c
</a><a href=/icer/tags/multi-layer-ahb title=multi-layer-ahb>multi-layer-ahb
</a><a href=/icer/tags/nxp title=nxp>nxp
</a><a href=/icer/tags/spi title=spi>spi
</a><a href=/icer/tags/uart title=uart>uart
</a><a href=/icer/tags/%E4%B8%B2%E5%8F%A3 title=串口>串口
</a><a href=/icer/tags/%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91 title=协议翻译>协议翻译
</a><a href=/icer/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF title=大小端>大小端
</a><a href=/icer/tags/%E5%AD%97%E8%8A%82%E5%BA%8F title=字节序>字节序
</a><a href=/icer/tags/%E7%9F%A5%E8%AF%86%E6%8F%90%E7%BA%B2 title=知识提纲>知识提纲</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://zhaozhihan.com>Linda的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:chengjj9527@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/icjj><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/ICJJ><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-gitlab fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://stackoverflow.com/users/26381389><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="ICJJ Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; ICJJ Blog 2024<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/icer/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script><script src=https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js integrity="sha256-Qsk2KRBCN5qVZX7B+8+2IvQl1Aqc723qV1tBCQaVoqo=" crossorigin=anonymous></script><script>(function(){let e="language-plantuml";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.parentNode.insertBefore(t,e.parentNode),e.parentNode.style.display="none"})})()</script></body></html>