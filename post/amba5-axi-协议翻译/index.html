<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="ICJJ Blog"><meta property="og:type" content="article"><meta property="og:image" content="img/site/小米汽车/原型车壁纸/2880x1280/2880x1280-06.png"><meta property="twitter:image" content="img/site/小米汽车/原型车壁纸/2880x1280/2880x1280-06.png"><meta name=title content="AMBA5 AXI 协议翻译"><meta property="og:title" content="AMBA5 AXI 协议翻译"><meta property="twitter:title" content="AMBA5 AXI 协议翻译"><meta name=description content="AMBA5 AXI的协议翻译"><meta property="og:description" content="AMBA5 AXI的协议翻译"><meta property="twitter:description" content="AMBA5 AXI的协议翻译"><meta property="twitter:card" content="summary"><meta name=keyword content="程建军, chengjianjun, ChengJianjun, , 程建军的网络日志, 程建军的博客, ChengJianjun Blog, 博客, 个人网站, AMBA, FPGA, SPINALHDL, PCIE"><link rel="shortcut icon" href=/icer/img/site/favicon.ico><title>AMBA5 AXI 协议翻译 | 程建军的博客 | ChengJianjun Blog</title>
<link rel=canonical href=/icer/post/amba5-axi-%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91/><link rel=stylesheet href=/icer/css/bootstrap.min.css><link rel=stylesheet href=/icer/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/icer/css/zanshang.css><link rel=stylesheet href=/icer/css/font-awesome.all.min.css><script src=/icer/js/jquery.min.js></script><script src=/icer/js/bootstrap.min.js></script><script src=/icer/js/hux-blog.min.js></script><script src=/icer/js/lazysizes.min.js></script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-FWR2FVFK68"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FWR2FVFK68")}</script><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/icer>ICJJ Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/icer>Posts</a></li><li><a href=/icer/categories/bus/>bus</a></li><li><a href=/icer/categories/tech/>tech</a></li><li><a href=/icer/categories/tips/>tips</a></li><li><a href=/icer/archive/>ARCHIVE</a></li><li><a href=/icer/about/>ABOUT</a></li><li><a href=/icer/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/icer/img/site/%e5%b0%8f%e7%b1%b3%e6%b1%bd%e8%bd%a6/%e5%8e%9f%e5%9e%8b%e8%bd%a6%e5%a3%81%e7%ba%b8/2880x1280/2880x1280-06.png)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/amba5 title=AMBA5>AMBA5
</a><a class=tag href=/tags/axi title=AXI>AXI
</a><a class=tag href=/tags/%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91 title=协议翻译>协议翻译</a></div><h1>AMBA5 AXI 协议翻译</h1><h2 class=subheading></h2><span class=meta>Posted by
程建军
on
Tuesday, April 23, 2024</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=amba-axi-协议规范>AMBA AXI 协议规范</h1><blockquote><p><a href=https://icjj.github.io/icer/document/IHI0022K_amba_axi_protocol_spec.pdf>IHI0022K_amba_axi_protocol_spec.pdf</a></p></blockquote><h2 id=ahb-协议规范>AHB 协议规范</h2><h3 id=a-id引言引言a><a id=引言>引言</a></h3><p>本前言描述了本规范中使用的内容组织和文档约定。</p><h4 id=a-id目标受众目标受众a><a id=目标受众>目标受众</a></h4><p>该规范是为希望熟悉AMBA协议的硬件和软件工程师编写的，旨在设计与AXI协议兼容的系统和模块</p><h4 id=a-id使用本规范使用本规范a><a id=使用本规范>使用本规范</a></h4><p>本规范中的信息分为几个部分，如本节所述：</p><p><strong>A部分 规范</strong></p><ul><li><em><a href="#a第1章 介绍">A第1章 介绍</a></em> ：介绍了本规格中使用的AXI协议架构和术语。</li><li><em><a href="#a第2章 信号列表">A第2章 信号列表</a></em> ：介绍了本规格中使用的AXI协议架构和术语。</li><li><em><a href="#a第3章 传输">A第3章 传输</a></em> ：提供有关AXI协议的基本操作的信息，例如读写事务、通道信令要求以及通道之间的关系。</li><li><em><a href="#a第4章 事务">A第4章 事务</a></em> ：包含有关AXI协议事务的信息，例如事务请求、事务响应、以及读写数据。</li><li><em><a href="#a第5章 请求属性">A第5章 请求属性</a></em> ：描述内存属性、内存类型、内存保护和多个区域接口。</li><li><em><a href="#a第6章 事务标识和顺序">A第6章 事务标识和顺序</a></em> ：描述事务ID信号、请求顺序、写数据和响应顺序 以及读数据顺序。</li><li><em><a href="#a第7章 原子操作">A第7章 原子操作</a></em> ：包含关于原子访问、单一和多副本原子性及独占访问的信息。</li><li><em><a href="#a第8章 请求操作码">A第8章 请求操作码</a></em> ：提供有关操作码字段的信息，该字段描述请求的功能并指示如何由从机处理。</li><li><em><a href="#a第9章 缓存">A第9章 缓存</a></em> ：描述了AXI协议中的缓存，包括I/O一致性、缓存可共享行以及使用特定事务管理缓存分配。</li><li><em><a href="#a第10章 缓存维护">A第10章 缓存维护</a></em> 提供有关使用缓存维护操作来控制缓存内容的信息，以确保数据的可见性。</li><li><em><a href="#a第11章 额外请求限定">A第11章 额外请求限定</a></em> ：描述AXI协议中的额外请求限定符，例如非安全访问标识符(NSAID)基于页面的硬件属性(PBHA)和子系统标识符。</li><li><em><a href="#a第12章 其他写事务">A第12章 其他写事务</a></em> ：包含有关AXI协议中其他写事务的信息，例如WriteDeferrable和WriteZero。</li><li><em><a href="#a第13章 同步监测、debug和user扩展">A第13章 同步监测、debug和user扩展</a></em> ：描述了AXI协议的系统调试、跟踪和监控功能，例如内存系统资源分区和监控（MPAM）、内存标记扩展（MTE）以及用户回环和用户定义信令。</li><li><em><a href="#a第14章 未翻译事务">A第14章 未翻译事务</a></em> ：描述了AXI如何支持在系统内存管理单元（SMMU）上游组件中使用虚拟地址和翻译缓存提示</li><li><em><a href="#a第15章 虚拟内存消息分布">A第15章 虚拟内存消息分布</a></em> ：描述AXI如何支持分布式系统MMU使用分布式虚拟内存DVM消息来维护虚拟内存系统中的所有MMU。</li><li><em><a href="#a第16章 唤醒信号">A第16章 唤醒信号</a></em> ：描述可用于接口时钟或电源控制的唤醒信号。</li><li><em><a href="#a第17章 接口和数据保护">A第17章 接口和数据保护</a></em> ：解释如何使用poison信号和奇偶校验信号来保护数据或接口。</li></ul><p><strong>B部分 附录</strong></p><ul><li><em><a href="#b1 接口类">B1 接口汇总</a></em> ：对所有AMBA 5 AXI接口类的描述，包括信号和属性表。</li><li><em><a href="#b2 约束总结">B2 约束总结</a></em> ：AXI协议中ID约束的总结。</li><li><em><a href="#b3 版本">B3 版本</a></em> ：本次规格与上一版本之间变化的详细信息。</li></ul><p><strong>C部分 术语</strong></p><ul><li><em><a href="#c1 术语表">C1 术语表</a></em></li></ul><h4 id=a-id约定约定a><a id=约定>约定</a></h4><p>本节描述了本规格使用的约定：</p><ul><li><a href=#排版>排版</a></li><li><a href=#时序图>时序图</a></li><li><a href=#信号>信号</a></li><li><a href=#数字>数字</a></li></ul><h5 id=a-id排版排版a><a id=排版>排版</a></h5><p>排版惯例是：</p><ul><li>italic(斜体)：突出重要笔记，介绍特殊术语，并指示内部交叉引用和引用。</li><li>bold(粗体)：表示信号名称，并用于描述性列表中的术语(如果适用)。</li><li>monospace(等宽)：该字体用于汇编程序语法描述、伪代码和源代码示例。</br>同时用于主要文本中的指令助记符，以及对出现在汇编程序语法描述、伪代码和源代码示例中的其他项目的引用。</li><li>SMALL CAPITALS(小写大写字母)：用于几个具有特定技术含义的术语。</li></ul><h5 id=a-id时序图时序图a><a id=时序图>时序图</a></h5><p>在时序图中使用的组件在 <em><a href="#图 1">图 1</a></em> 中进行了说明。当变化发生时，会有明确的标签。请不要假设图中没有明确的时序信息</p><p><a id="图 1">图 1</a>
<img src=https://icjj.github.io/icer/img/post/axi/Figure1_Key_to_timing_diagram_conventions.png alt></p><p>时序图有时将单比特信号同时显示为高和低，它们看起来与 <em><a href="#图 1">图 1</a></em> 显示的总线变化类似。
如果时序图以这种方式显示单比特信号，则其值不会影响附带的描述。</p><h5 id=a-id信号信号a><a id=信号>信号</a></h5><p>下面是关于信号方面的约定：</p><ul><li>信号电平：</br>断言信号的水平取决于信号是高有效还是低有效，断言意味着<ul><li>HIGH：表示高电平有效。</li><li>LOW：表示低电平有效。</li></ul></li><li>小写n：出现在信号名的开始或结束都表示低电平有效。</li><li>小写x：信号名称的第二个字母表示读取和写入的统称。例如<strong>AxCACHE</strong>既指<strong>ARCACHE</strong>信号也指<strong>AWCACHE</strong>信号。</li></ul><h5 id=a-id数字数字a><a id=数字>数字</a></h5><p>数字通常以十进制书写。二进制数字以0b开头，十六进制数字以0x开头。
在这两种情况下，前缀和相关的值都以monospace字体书写。例如0xFFFF0000。
为了提高可读性，较长的数字可以在每四个字符之间加下划线分隔。
例如0xFFFF_0000_0000_0000，在解释数字的值时忽略任何下划线。</p><h5 id=a-id伪代码描述伪代码描述a><a id=伪代码描述>伪代码描述</a></h5><p>本规范使用一种伪代码形式来提供对指定功能的精确描述。
该伪代码以等宽字体书写。伪代码语言在Arm®架构参考手册中描述，适用于A型架构。</p><h4 id=a-id额外阅读额外阅读a><a id=额外阅读>额外阅读</a></h4><p>本节列出了Arm和第三方的出版物。</p><p>查看Arm开发者网站<a href=http://developer.arm.com>http://developer.arm.com</a> 以获取Arm文档的访问权限。</p><p><a id=[1]>[1]</a> AMBA® AXI and ACE Protocol Specification. (ARM IHI 0022 H.c).<br><a id=[2]>[2]</a> AMBA® AXI Protocol Specification. (ARM IHI 0022 J).<br><a id=[3]>[3]</a> Arm® Architecture Reference Manual for A-profile architecture. (ARM DDI 0487).<br><a id=[4]>[4]</a> Arm® Realm Management Extension (RME) System Architecture. (ARM DEN 0129).<br><a id=[5]>[5]</a> AMBA® 5 CHI Architecture Specification. (ARM IHI 0050).<br><a id=[6]>[6]</a> Arm® Architecture Reference Manual Supplement, Memory System Resource Partitioning and Monitoring<br>(MPAM), for A-profile architecture. (ARM DDI 0598).<br><a id=[7]>[7]</a> Arm® System Memory Management Unit Architecture Specification, SMMU architecture version 3. (ARM IHI0070)</p><h4 id=a-id反馈反馈a><a id=反馈>反馈</a></h4><ul><li>请通过填写 <em><a href=https://developer.arm.com/feedback/survey>https://developer.arm.com/feedback/survey</a></em>
上的表单，提交关于Arm产品文档的反馈意见。</li><li>有关Arm产品、架构和规格的技术反馈、问题或咨询，请在 <em><a href=https://support.developer.arm.com/my-cases/open-case/>https://support.developer.arm.com/my-cases/open-case/</a></em>
上提交支持请求。</li></ul><h3 id=a-ida第1章-介绍a第1章-介绍a><a id="a第1章 介绍">A第1章 介绍</a></h3><p>本章介绍了AXI协议的架构和本规范中使用的术语。</p><p>它包含以下部分：</p><ul><li><em><a href="#1.1 关于axi协议">1.1 关于AXI协议</a></em></li><li><em><a href="#1.2 axi架构">1.2 AXI架构</a></em></li><li><em><a href="#1.3 术语">1.3 术语</a></em></li></ul><h4 id=a-ida11-关于axi协议a11-关于axi协议a><a id="a1.1 关于axi协议">A1.1 关于AXI协议</a></h4><p>AXI协议支持高性能、高频率的系统设计，用于主机与从机之间的通信。</p><p>AXI协议的特点包括：</p><ul><li>适用于高带宽和低延迟的设计。</li><li>无需使用复杂的桥接器，提供高频率操作。</li><li>该协议满足广泛组件的接口要求。</li><li>适用于具有高首次访问延迟的内存控制器。</li><li>提供互联架构实施的灵活性。</li><li>向后兼容AHB和APB接口。</li></ul><p>AXI协议的关键特性包括：</p><ul><li>独立的地址/控制和数据阶段。</li><li>支持使用字节时钟的非对齐数据传输。</li><li>仅发出起始地址的基于突发的事务。</li><li>分开的写和读数据通道，可以提供低成本的直接内存访问（DMA）。</li><li>支持发出多个未完成的地址。</li><li>支持无序事务完成。</li><li>允许轻松添加寄存器阶段以提供时序闭合。</li></ul><p>有关本规范的前期版本，请参见 <sup><em><a href=#[1]>[1]</a></em> </sup>和 <sup><em><a href=#[2]>[2]</a></em> </sup>。</p><h4 id=a-ida12-axi架构a12-axi架构a><a id="a1.2 axi架构">A1.2 AXI架构</a></h4><p>AXI协议是基于事务的，定义了五个独立的通道：</p><ul><li>写请求，其信号名称以AW开头</li><li>写数据，其信号名称以W开头</li><li>写响应，其信号名称以B开头</li><li>读请求，其信号名称以AR开头</li><li>读数据，其信号名称以R开头</li></ul><p>请求通道携带控制信息，描述要传输数据的性质。这个称为请求。</p><p>数据在主机和从机之间使用以下方式传输：</p><ul><li>写数据通道将数据从主机传输到从机。在写事务中，从机使用写响应通道向主机发出表示完成传输的信号。</li><li>读数据通道将数据从从机传输到主机。</li></ul><p>AXI协议：</p><ul><li>允许在实际数据传输之前发出地址信息。</li><li>支持多个未决事务。</li><li>支持事务的乱序完成。</li></ul><p><em><a href="#图 a1.1">图 A1.1</a></em> 展示了写事务如何使用写请求、写数据和写响应通道。</p><p><a id="图 a1.1">图 A1.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A1.1_Channel_architecture_of_writes.png alt></a></p><p><em><a href="#图 a1.1">图 a1.1</a></em></p><p><a id="图 a1.2">图 A1.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A1.2_Channel_architecture_of_reads.png alt></a></p><h5 id=a-ida121-通道定义a121-通道定义a><a id="a1.2.1 通道定义">A1.2.1 通道定义</a></h5><p>每个独立的五个通道由一组信息信号以及<strong>VALID</strong>和<strong>READY</strong>信号组成，
提供双向握手机制。信息源使用<strong>VALID</strong>信号来表示通道上何时有有效的地址、数据或控制信息可用。
目的地使用<strong>READY</strong>信号来表示何时可以接受这些信息。
读数据通道和写数据通道还包括<strong>LAST</strong>信号，以指示在事务中最后一个数据项的传输。</p><h6 id=a-ida1211-读写请求通道a1211-读写请求通道a><a id="a1.2.1.1 读写请求通道">A1.2.1.1 读写请求通道</a></h6><p>存在单独的写请求和读请求通道。适当的请求通道携带一个事务所需的所有地址和控制信息。</p><h6 id=a-ida1212-写数据通道a1212-写数据通道a><a id="a1.2.1.2 写数据通道">A1.2.1.2 写数据通道</a></h6><p>写数据通道将写数据从主机传输到从机，包括：</p><ul><li>数据信号<strong>WDATA</strong>，可以为8、16、32、64、128、256、512或1024位宽。宽度使用DATA_WIDTH属性表示。</li><li>每8个数据位都有一个字节通道时钟信号，指示有效的数据字节。</li></ul><p>写数据通道信息始终被视为缓存，这样主机可以在没有从机确认先前写操作的情况下执行写事务。</p><h6 id=a-ida1213-写响应通道a1213-写响应通道a><a id="a1.2.1.3 写响应通道">A1.2.1.3 写响应通道</a></h6><p>从机使用写响应通道来响应写事务。
所有写事务都需要在写响应通道上进行完成信号传输。
如 <a href="#图 a1.1">图 A1.1</a>所示，只有在完整事务中才会发出完成信号，而不是在事务中的每个数据传输中发出。</p><h6 id=a-ida1214-读数据通道a1214-读数据通道a><a id="a1.2.1.4 读数据通道">A1.2.1.4 读数据通道</a></h6><p>读取数据通道携带从从机到主机的读取数据和读取响应信息，包括：</p><ul><li>数据信号<strong>RDATA</strong>，其宽度可以是8、16、32、64、128、256、512或1024位。宽度通过DATA_WIDTH属性表示。</li><li>表示读取事务完成状态的读取响应信号。</li></ul><h5 id=a-ida122-接口与互联a122-接口与互联a><a id="a1.2.2 接口与互联">A1.2.2 接口与互联</a></h5><p>一个典型的系统由多个主机和从机组成，这些设备通过某种形式的连接相互连接，如 <em><a href="#图 a1.3">图 A1.3</a></em> 所示</p><p><a id="图 a1.3">图 A1.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A1.3_Interface_and_interconnect.png alt></a></p><p>AXI协议为以下接口之间提供了单一的接口定义：</p><ul><li>主机与互连之间</li><li>从机与互连之间</li><li>主机与从机之间</li></ul><p>此接口定义支持许多不同的互连实现。</p><p>设备之间的互连相当于另一个具有对称的主机和从机端口的设备，实际的主机和从机通过这一互联可以连接在一起。</p><h6 id=a-ida1221-典型系统拓扑a1221-典型系统拓扑a><a id="a1.2.2.1 典型系统拓扑">A1.2.2.1 典型系统拓扑</a></h6><p>大多数系统使用三种互连拓扑之一：</p><ul><li>共享请求和数据通道。</li><li>共享请求通道和多个数据通道。</li><li>多层次，具有多个请求和数据通道。</li></ul><p>在大多数系统中，请求通道的带宽需求显著低于数据通道的带宽需求。
这种系统可以通过使用一个共享请求通道和多个数据通道来实现系统性能和互连复杂性之间的良好平衡，从而启用并行数据传输。</p><h6 id=a-ida123-寄存器切片a123-寄存器切片a><a id="a1.2.3 寄存器切片">A1.2.3 寄存器切片</a></h6><p>每个AXI通道仅以单一方向传输信息，并且架构不要求通道之间有任何固定关系。
这些特性意味着可以在任意通道的几乎任何位置插入寄存器切片，代价是增加一个周期的延迟。
这些特性使以下情况成为可能：</p><ul><li>在延迟周期和最大操作频率之间进行权衡。</li><li>处理器与高性能内存之间的直接快速连接，同时使用简单的寄存器切片来隔离到性能要求较低外设的较长路径。</li></ul><h4 id=a-ida13-术语a13-术语a><a id="a1.3 术语">A1.3 术语</a></h4><p>本节总结了本规范中使用的术语，这些术语在 <em><a href="#c1 术语表">C1 术语表</a></em> 中或其他地方有定义。
在适当的情况下，本节中列出的术语链接到相应的术语表定义。</p><h5 id=a-ida131-axi组件和拓扑a131-axi组件和拓扑a><a id="a1.3.1 axi组件和拓扑">A1.3.1 AXI组件和拓扑</a></h5><p>以下术语描述了AXI组件：</p><ul><li><em><a href=#组件>组件</a></em></li><li><em><a href=#主机组件>主机组件</a></em></li><li><em><a href=#从机组件>从机组件</a></em> ，包括内存从机组件和外设从机组件</li><li><em><a href=#互联组件>互联组件</a></em></li></ul><p>对于特定的AXI事务，<em><a href=#上游>上游</a></em> 和 <em><a href=#下游>下游</a></em> 指的是AXI拓扑中AXI组件的相对位置。</p><h5 id=a-ida132-axi事务与传输a132-axi事务与传输a><a id="a1.3.2 axi事务与传输">A1.3.2 AXI事务与传输</a></h5><p>AXI传输是在AXI通道上一个周期内的通信。</p><p>AXI事务是AXI主机与AXI从机进行通信所需的传输集合。</p><p>例如，读事务由请求传输和一个或多个读数据传输组成。</p><h5 id=a-ida133-缓存与缓存操作a133-缓存与缓存操作a><a id="a1.3.3 缓存与缓存操作">A1.3.3 缓存与缓存操作</a></h5><p>本规范没有定义任何缓存参考书中定义的标准缓存术语。</p><p>然而，<em><a href=#缓存>缓存</a></em> 和 <em><a href=#缓存行>缓存行</a></em> 的词汇条目澄清了这些术语在本文档中的使用方式。</p><h5 id=a-ida134-时间描述a134-时间描述a><a id="a1.3.4 时间描述">A1.3.4 时间描述</a></h5><p>AXI规范使用了 <em><a href=#时间描述>时间描述</a></em> 的解释。</p><h3 id=a-ida第2章-信号列表a第2章-信号列表a><a id="a第2章 信号列表">A第2章 信号列表</a></h3><p>本章列出了本规范中描述的所有信号。
有些通道和信号是可选的，因此并不包含在每个接口中。
每个信号名称包含一个超链接，指向定义该信号的章节。
奇偶校验信号不包含在本章中，但在 <em><a href="#a17.2.3 校验检查信号">A17.2.3 校验检查信号</a></em> 中列出。</p><p>信号根据通道和类别分组，如以下各节所述。</p><ul><li><em><a href="#a2.1 写通道">A2.1 写通道</a></em></li><li><em><a href="#a2.2 读通道">A2.2 读通道</a></em></li><li><em><a href="#a2.3 snoop通道">A2.3 snoop通道</a></em></li><li><em><a href="#a2.4 接口信号">A2.4 接口信号</a></em></li></ul><h4 id=a-ida21-写通道a21-写通道a><a id="a2.1 写通道">A2.1 写通道</a></h4><p>写通道用于传输请求、数据和响应以进行写事务以及一些其他无数据事务。</p><h5 id=a-ida211-写请求通道a211-写请求通道a><a id="a2.1.1 写请求通道">A2.1.1 写请求通道</a></h5><p>写请求通道传输使用写通道的事务所需的所有地址和控制信息。该通道上的信号前缀为AW。</p><p><a id="表 a2.1">表 A2.1</a> 写请求通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>AWREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>AWID</strong></td><td>ID_W_WIDTH</td><td>主机</td><td>事务ID</td></tr><tr><td><strong>AWADDR</strong></td><td>ADDR_WIDTH</td><td>主机</td><td>地址</td></tr><tr><td><strong>AWREGION</strong></td><td>4</td><td>主机</td><td>区域ID</td></tr><tr><td><strong>AWLEN</strong></td><td>8</td><td>主机</td><td>长度</td></tr><tr><td><strong>AWSIZE</strong></td><td>3</td><td>主机</td><td>大小</td></tr><tr><td><strong>AWBURST</strong></td><td>2</td><td>主机</td><td>突发属性</td></tr><tr><td><strong>AWLOCK</strong></td><td>1</td><td>主机</td><td>锁定</td></tr><tr><td><strong>AWCACHE</strong></td><td>4</td><td>主机</td><td>缓存属性</td></tr><tr><td><strong>AWPROT</strong></td><td>3</td><td>主机</td><td>访问属性</td></tr><tr><td><strong>AWNSE</strong></td><td>1</td><td>主机</td><td>RME的非安全扩展bit</td></tr><tr><td><strong>AWQOS</strong></td><td>4</td><td>主机</td><td>Qos ID</td></tr><tr><td><strong>AWUSER</strong></td><td>USER_REQ_WIDTH</td><td>主机</td><td>user写请求</td></tr><tr><td><strong>AWDOMAIN</strong></td><td>2</td><td>主机</td><td>可共享域</td></tr><tr><td><strong>AWSNOOP</strong></td><td>AWSNOOP_WIDTH</td><td>主机</td><td>操作码</td></tr><tr><td><strong>AWSTASHNID</strong></td><td>11</td><td>主机</td><td>Stash 节点 ID</td></tr><tr><td><strong>AWSTASHNIDEN</strong></td><td>1</td><td>主机</td><td>Stash 节点 ID 使能</td></tr><tr><td><strong>AWSTASHLPID</strong></td><td>5</td><td>主机</td><td>Stash 逻辑处理器 ID</td></tr><tr><td><strong>AWSTASHLPIDEN</strong></td><td>1</td><td>主机</td><td>Stash 逻辑处理器 ID 使能</td></tr><tr><td><strong>AWTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr><tr><td><strong>AWLOOP</strong></td><td>LOOP_W_WIDTH</td><td>主机</td><td>环回信号</td></tr><tr><td><strong>AWMMUVALID</strong></td><td>1</td><td>主机</td><td>MMU有效</td></tr><tr><td><strong>AWMMUSECSID</strong></td><td>SECSID_WIDTH</td><td>主机</td><td>MMU安全流 ID</td></tr><tr><td><strong>AWMMUSID</strong></td><td>SID_WIDTH</td><td>主机</td><td>MMU流ID</td></tr><tr><td><strong>AWMMUSSIDV</strong></td><td>1</td><td>主机</td><td>MMU子流ID有效</td></tr><tr><td><strong>AWMMUSSID</strong></td><td>SSID_WIDTH</td><td>主机</td><td>MMU子流ID</td></tr><tr><td><strong>AWMMUATST</strong></td><td>1</td><td>主机</td><td>地址转换指示</td></tr><tr><td><strong>AWMMUFLOW</strong></td><td>2</td><td>主机</td><td>MMU flow type</td></tr><tr><td><strong>AWPBHA</strong></td><td>4</td><td>主机</td><td>Page-based 硬件属性</td></tr><tr><td><strong>AWNSAID</strong></td><td>4</td><td>主机</td><td>非安全访问 ID</td></tr><tr><td><strong>AWSUBSYSID</strong></td><td>SUBSYSID_WIDTH</td><td>主机</td><td>子系统 ID</td></tr><tr><td><strong>AWATOP</strong></td><td>6</td><td>主机</td><td>原子事务操作码</td></tr><tr><td><strong>AWMPAM</strong></td><td>MPAM_WIDTH</td><td>主机</td><td>MPAM 写请求</td></tr><tr><td><strong>AWIDUNQ</strong></td><td>1</td><td>主机</td><td>唯一ID</td></tr><tr><td><strong>AWCMO</strong></td><td>AWCMO_WIDTH</td><td>主机</td><td>CMO type</td></tr><tr><td><strong>AWTAGOP</strong></td><td>2</td><td>主机</td><td>内存标签</td></tr><tr><td><strong>AWMECID</strong></td><td>MECID_WIDTH</td><td>主机</td><td>内存加密ID</td></tr></tbody></table><h5 id=a-ida212-写数据通道a212-写数据通道a><a id="a2.1.2 写数据通道">A2.1.2 写数据通道</a></h5><p>写数据通道携带来自主机到从机的写数据和控制信息。该通道上的信号以W为前缀。</p><p><a id="表 a2.2">表 A2.2</a> 写数据通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>WVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>WREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>WDATA</strong></td><td>DATA_WIDTH</td><td>主机</td><td>写数据</td></tr><tr><td><strong>WSTRB</strong></td><td>DATA_WIDTH / 8</td><td>主机</td><td>strobes写</td></tr><tr><td><strong>WTAG</strong></td><td>ceil(DATA_WIDTH/128)*4</td><td>主机</td><td>内存Tag</td></tr><tr><td><strong>WTAGUPDATE</strong></td><td>ceil(DATA_WIDTH/128)</td><td>主机</td><td>内存Tag更新</td></tr><tr><td><strong>WLAST</strong></td><td>1</td><td>主机</td><td>最后写数据标识</td></tr><tr><td><strong>WUSER</strong></td><td>USER_DATA_WIDTH</td><td>主机</td><td>user写数据</td></tr><tr><td><strong>WPOISON</strong></td><td>ceil(DATA_WIDTH / 64)</td><td>主机</td><td>破坏标识</td></tr><tr><td><strong>WTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr></tbody></table><h4 id=a-ida213写响应通道a写响应通道a><a id=a2.1.3写响应通道>A写响应通道</a></h4><p>写响应通道用于传递从从机到主机的响应，适用于使用写数据通道的事务。该通道上的信号以字母B为前缀。</p><p><a id="表 a2.3">表 A2.3</a> 写响应通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>BVALID</strong></td><td>1</td><td>从机</td><td>有效</td></tr><tr><td><strong>BREADY</strong></td><td>1</td><td>主机</td><td>就绪</td></tr><tr><td><strong>BID</strong></td><td>ID_W_WIDTH</td><td>从机</td><td>事务ID</td></tr><tr><td><strong>BIDUNQ</strong></td><td>1</td><td>从机</td><td>唯一ID</td></tr><tr><td><strong>BRESP</strong></td><td>BRESP_WIDTH</td><td>从机</td><td>写响应</td></tr><tr><td><strong>BCOMP</strong></td><td>1</td><td>从机</td><td>完成标识</td></tr><tr><td><strong>BPERSIST</strong></td><td>1</td><td>从机</td><td>持久响应</td></tr><tr><td><strong>BTAGMATCH</strong></td><td>2</td><td>从机</td><td>内存标签匹配</td></tr><tr><td><strong>BUSER</strong></td><td>USER_RESP_WIDTH</td><td>从机</td><td>user写响应</td></tr><tr><td><strong>BTRACE</strong></td><td>1</td><td>从机</td><td>跟踪</td></tr><tr><td><strong>BLOOP</strong></td><td>LOOP_W_WIDTH</td><td>从机</td><td>回环</td></tr><tr><td><strong>BBUSY</strong></td><td>2</td><td>从机</td><td>繁忙</td></tr></tbody></table><h4 id=a-ida22-读通道a22-读通道a><a id="a2.2 读通道">A2.2 读通道</a></h4><p>读通道用于传输读取事务、缓存维护操作和DVM完成消息的请求、数据和响应。</p><h5 id=a-ida221-读请求通道a221-读请求通道a><a id="a2.2.1 读请求通道">A2.2.1 读请求通道</a></h5><p>读请求通道携带所有使用读取通道的事务所需的地址和控制信息。该通道上的信号以前缀AR开头。</p><p><a id="表 a2.4">表 A2.4</a> 读请求信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ARVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>ARREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>ARID</strong></td><td>ID_R_WIDTH</td><td>主机</td><td>ID</td></tr><tr><td><strong>ARADDR</strong></td><td>ADDR_WIDTH</td><td>主机</td><td>地址</td></tr><tr><td><strong>ARREGION</strong></td><td>4</td><td>主机</td><td>区域</td></tr><tr><td><strong>ARLEN</strong></td><td>8</td><td>主机</td><td>长度</td></tr><tr><td><strong>ARSIZE</strong></td><td>3</td><td>主机</td><td>大小</td></tr><tr><td><strong>ARBURST</strong></td><td>2</td><td>主机</td><td>突发</td></tr><tr><td><strong>ARLOCK</strong></td><td>1</td><td>主机</td><td>锁定</td></tr><tr><td><strong>ARCACHE</strong></td><td>4</td><td>主机</td><td>缓存属性</td></tr><tr><td><strong>ARPROT</strong></td><td>3</td><td>主机</td><td>访问属性</td></tr><tr><td><strong>ARNSE</strong></td><td>1</td><td>主机</td><td>RME的非安全扩展位</td></tr><tr><td><strong>ARQOS</strong></td><td>4</td><td>主机</td><td>QoS标识</td></tr><tr><td><strong>ARUSER</strong></td><td>USER_REQ_WIDTH</td><td>主机</td><td>user读请求</td></tr><tr><td><strong>ARDOMAIN</strong></td><td>2</td><td>主机</td><td>共享域</td></tr><tr><td><strong>ARSNOOP</strong></td><td>ARSNOOP_WIDTH</td><td>主机</td><td>操作码</td></tr><tr><td><strong>ARTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr><tr><td><strong>ARLOOP</strong></td><td>LOOP_R_WIDTH</td><td>主机</td><td>环回</td></tr><tr><td><strong>ARMMUVALID</strong></td><td>1</td><td>主机</td><td>MMU有效</td></tr><tr><td><strong>ARMMUSECSID</strong></td><td>SECSID_WIDTH</td><td>主机</td><td>MMU安全流ID</td></tr><tr><td><strong>ARMMUSID</strong></td><td>SID_WIDTH</td><td>主机</td><td>MMU流ID</td></tr><tr><td><strong>ARMMUSSIDV</strong></td><td>1</td><td>主机</td><td>MMU子流ID有效</td></tr><tr><td><strong>ARMMUSSID</strong></td><td>SSID_WIDTH</td><td>主机</td><td>MMU子流ID</td></tr><tr><td><strong>ARMMUATST</strong></td><td>1</td><td>主机</td><td>地址已转换</td></tr><tr><td><strong>ARMMUFLOW</strong></td><td>2</td><td>主机</td><td>MMU flow类型</td></tr><tr><td><strong>ARPBHA</strong></td><td>4</td><td>主机</td><td>Page-based硬件属性</td></tr><tr><td><strong>ARNSAID</strong></td><td>4</td><td>主机</td><td>非安全访问ID</td></tr><tr><td><strong>ARSUBSYSID</strong></td><td>SUBSYSID_WIDTH</td><td>主机</td><td>子系统ID</td></tr><tr><td><strong>ARMPAM</strong></td><td>MPAM_WIDTH</td><td>主机</td><td>带请求的MPAM信息</td></tr><tr><td><strong>ARCHUNKEN</strong></td><td>1</td><td>主机</td><td>分块使能</td></tr><tr><td><strong>ARIDUNQ</strong></td><td>1</td><td>主机</td><td>唯一ID标识</td></tr><tr><td><strong>ARTAGOP</strong></td><td>2</td><td>主机</td><td>内存标签操作码</td></tr><tr><td><strong>ARMECID</strong></td><td>MECID_WIDTH</td><td>主机</td><td>内存加密标识</td></tr></tbody></table><h5 id=a-ida222-读数据通道a222-读数据通道a><a id="a2.2.2 读数据通道">A2.2.2 读数据通道</a></h5><p>读数据通道传输来自从机设备到管理器的读数据和响应。该通道上的信号以R为前缀。</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>RVALID</strong></td><td>1</td><td>从机</td><td>有效</td></tr><tr><td><strong>RREADY</strong></td><td>1</td><td>主机</td><td>就绪</td></tr><tr><td><strong>RID</strong></td><td>ID_R_WIDTH</td><td>从机</td><td>事务ID</td></tr><tr><td><strong>RIDUNQ</strong></td><td>1</td><td>从机</td><td>唯一ID指示</td></tr><tr><td><strong>RDATA</strong></td><td>DATA_WIDTH</td><td>从机</td><td>读取数据</td></tr><tr><td><strong>RTAG</strong></td><td>ceil(DATA_WIDTH/128)*4</td><td>从机</td><td>内存标签</td></tr><tr><td><strong>RRESP</strong></td><td>RRESP_WIDTH</td><td>从机</td><td>读取响应</td></tr><tr><td><strong>RLAST</strong></td><td>1</td><td>从机</td><td>最后读取标识</td></tr><tr><td><strong>RUSER</strong></td><td>USER_DATA_WIDTH + USER_RESP_WIDTH</td><td>从机</td><td>user的读取数据和响应</td></tr><tr><td><strong>RPOISON</strong></td><td>ceil(DATA_WIDTH / 64)</td><td>从机</td><td>破坏标识</td></tr><tr><td><strong>RTRACE</strong></td><td>1</td><td>从机</td><td>跟踪</td></tr><tr><td><strong>RLOOP</strong></td><td>LOOP_R_WIDTH</td><td>从机</td><td>回环</td></tr><tr><td><strong>RCHUNKV</strong></td><td>1</td><td>从机</td><td>分块有效</td></tr><tr><td><strong>RCHUNKNUM</strong></td><td>RCHUNKNUM_WIDTH</td><td>从机</td><td>分块编号</td></tr><tr><td><strong>RCHUNKSTRB</strong></td><td>RCHUNKSTRB_WIDTH</td><td>从机</td><td>分块 strobe</td></tr><tr><td><strong>RBUSY</strong></td><td>2</td><td>从机</td><td>繁忙</td></tr></tbody></table><h5 id=a-ida23-snoop通道a23-snoop通道a><a id="a2.3 snoop通道">A2.3 snoop通道</a></h5><p>在本规范中，旁路通道仅用于传输DVM消息。</p><h5 id=a-ida231-snoop请求通道a231-snoop请求通道a><a id="a2.3.1 snoop请求通道">A2.3.1 snoop请求通道</a></h5><p>snoop请求通道携带DVM消息请求的地址和控制信息。该通道上的信号具有前缀AC。</p><p><a id="表 a2.6">表 A2.6</a> snoop请求通道</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ACVALID</strong></td><td>1</td><td>从机</td><td>有效</td></tr><tr><td><strong>ACREADY</strong></td><td>1</td><td>主机</td><td>就绪</td></tr><tr><td><strong>ACADDR</strong></td><td>ADDR_WIDTH</td><td>从机</td><td>地址</td></tr><tr><td><strong>ACVMIDEXT</strong></td><td>4</td><td>从机</td><td>VMID</td></tr><tr><td><strong>ACTRACE</strong></td><td>1</td><td>从机</td><td>跟踪</td></tr></tbody></table><h5 id=a-ida232-snoop响应通道a232-snoop响应通道a><a id="a2.3.2 snoop响应通道">A2.3.2 snoop响应通道</a></h5><p>snoop响应通道承载对DVM消息的响应。该通道上的信号具有前缀CR.</p><p><a id="表 a2.7">表 A2.7</a> snoop响应通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>CRVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>CRREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>CRTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr></tbody></table><h4 id=a-ida24-接口信号a24-接口信号a><a id="a2.4 接口信号">A2.4 接口信号</a></h4><p>接口级信号是非信道信号。每个接口最多可以有一组信号。</p><h5 id=a-ida241-时钟和复位信号a241-时钟和复位信号a><a id="a2.4.1 时钟和复位信号">A2.4.1 时钟和复位信号</a></h5><p>接口上的所有信号与全局时钟同步，并通过全局复位信号进行复位。</p><p><a id="表 a2.8">表 A2.8</a> 时钟和复位信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ACLK</strong></td><td>1</td><td>时钟源</td><td>全局时钟</td></tr><tr><td><strong>ARESETn</strong></td><td>1</td><td>复位源</td><td>全局复位</td></tr></tbody></table><h5 id=a-ida242-唤醒信号a242-唤醒信号a><a id="a2.4.2 唤醒信号">A2.4.2 唤醒信号</a></h5><p><a id="表 a2.9">表 A2.9</a> 唤醒信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWAKEUP</strong></td><td>1</td><td>主机</td><td>读写通道唤醒</td></tr><tr><td><strong>WCWAKEUP</strong></td><td>1</td><td>从机</td><td>snoop通道唤醒</td></tr></tbody></table><h5 id=a-ida243-qos接收信号a243-qos接收信号a><a id="a2.4.3 Qos接收信号">A2.4.3 Qos接收信号</a></h5><p>QoS接受信号可以被从机接口用于指示它接受的请求的最小QoS值。</p><p><a id="表 a2.10">表 A2.10</a> Qos接收信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>VAWQOSACCEPT</strong></td><td>4</td><td>从机</td><td>写请求的Qos值</td></tr><tr><td><strong>VARQOSACCEPT</strong></td><td>4</td><td>从机</td><td>读请求的Qos值</td></tr></tbody></table><h5 id=a-ida244-连贯性连接信号a244-连贯性连接信号a><a id="a2.4.4 连贯性连接信号">A2.4.4 连贯性连接信号</a></h5><p>连贯性连接信号由主机使用，以控制其是否接收AC通道上的DVM消息。</p><p><a id="表 a2.11">表 A2.11</a> 连贯性连接信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>SYSCOREQ</strong></td><td>1</td><td>主机</td><td>连贯性连接请求</td></tr><tr><td><strong>SYSCOACK</strong></td><td>1</td><td>从机</td><td>连贯性连接回应</td></tr></tbody></table><h5 id=a-ida245-接口控制信号a245-接口控制信号a><a id="a2.4.5 接口控制信号">A2.4.5 接口控制信号</a></h5><p>接口控制信号是主机接口的静态输入，可用于配置接口行为。</p><p><a id="表 a2.12">表 A2.12</a> 接口控制信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>BROADCASTATOMIC</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于原子事务</td></tr><tr><td><strong>BROADCASTSHAREABLE</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于可共享事务</td></tr><tr><td><strong>BROADCASTCACHEMAINT</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于维护操作</td></tr><tr><td><strong>BROADCASTCMOPOPA</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于 CleanInvalidPoPA CMO</td></tr><tr><td><strong>BROADCASTPERSIST</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于 CleanSharedPersist and CleanSharedDeepPersist</td></tr></tbody></table><h3 id=a-ida第3章-传输a第3章-传输a><a id="a第3章 传输">A第3章 传输</a></h3><p>本章描述了AXI中使用的通道传输
它包含以下部分：</p><ul><li><em><a href="#a3.1 时钟和复位">A3.1 时钟和复位</a></em></li><li><em><a href="#a3.2 通道握手">A3.2 通道握手</a></em></li><li><em><a href="#a3.3 读写通道">A3.3 读写通道</a></em></li><li><em><a href="#a3.4 通道关系">A3.4 通道关系</a></em></li><li><em><a href="#a3.5 通道握手依赖">A3.5 通道握手依赖</a></em></li><li><em><a href="#a3.6 snoop通道">A3.6 snoop通道</a></em></li></ul><h4 id=a-ida31-时钟和复位a31-时钟和复位a><a id="a3.1 时钟和复位">A3.1 时钟和复位</a></h4><p>本节描述了实现AXI全局时钟和复位信号<strong>ACLK</strong>和<strong>ARESETn</strong>的要求。</p><h5 id=a-ida311-时钟a311-时钟a><a id="a3.1.1 时钟">A3.1.1 时钟</a></h5><p>每个AXI接口都有一个单一的时钟信号<strong>ACLK</strong>。
所有输入信号在<strong>ACLK</strong>的上升沿被采样。
所有输出信号的变化只能在<strong>ACLK</strong>的上升沿之后发生。</p><p>在主机和从机之间，输入和输出信号之间必须没有组合路径。</p><h5 id=a-ida312-复位a312-复位a><a id="a3.1.2 复位">A3.1.2 复位</a></h5><p>AXI协议使用一个单一的低电平有效复位信号<strong>ARESETn</strong>。
复位信号可以异步地被断言，但解除断言只能在<strong>ACLK</strong>上升沿同步进行。
在复位期间，以下接口要求适用：</p><ul><li>主机必须将<strong>AWVALID</strong>、<strong>WVALID</strong>和<strong>ARVALID</strong>驱动为低。</li><li>从机必须将<strong>BVALID</strong>和<strong>RVALID</strong>驱动为低。</li><li>所有其他信号可以被驱动为任何值。</li></ul><p>复位后，主机被允许开始将<strong>AWVALID</strong>、<strong>WVALID</strong>和<strong>ARVALID</strong>
驱动为高的最早时刻是在<strong>ARESETn</strong>高后的<strong>ACLK</strong>上升沿。</p><p><em><a href="#图 a3.1">图 A3.1</a></em> 显示了复位后<strong>AWVALID</strong>、<strong>WVALID</strong>和<strong>ARVALID</strong>
可以被驱动为高的最早时间点 <em>b</em>。</p><p><a id="图 a3.1">图 A3.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.1_Exit_from_reset.png alt></a></p><h4 id=a-ida32-通道握手a32-通道握手a><a id="a3.2 通道握手">A3.2 通道握手</a></h4><p>所有AXI通道使用相同的<strong>VALID</strong>/<strong>READY</strong>握手过程来传输地址、数据和控制信息。
这种双向流控制机制意味着主机和从机都可以控制信息在主机和从机之间移动的速率。
源生成<strong>VALID</strong>信号以指示地址、数据或控制信息可用。
目标生成<strong>READY</strong>信号以指示它可以接受信息。
仅当<strong>VALID</strong>和<strong>READY</strong>信号均为高电平时，传输才会发生。</p><p>在主机和从机之间，输入信号和输出信号之间必须没有组合路径。
<em><a href="#图 a3.2">图 A3.2</a></em> 到 <em><a href="#图 a3.4">图 A3.4</a></em> 展示了握手过程的示例。</p><p>源可以在<strong>READY</strong>被断言之前就断言<strong>VALID</strong>。</p><p>源在边缘1之后呈现信息，并如 <em><a href="#图 a3.2">图 A3.2</a></em> 所示声明<strong>VALID</strong>信号。
目标在边缘2之后声明<strong>READY</strong>信号。
源必须保持其信息稳定，直到在边缘3时发生传输，此时该声明被识别。</p><p><a id="图 a3.2">图 A3.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.2_VALID_before_READY_handshake.png alt></a></p><p>源不能在断言<strong>VALID</strong>之前去等待<strong>READY</strong>被断言。</p><blockquote><p>Note：
也就是说源不能依靠等待<strong>READY</strong>被断言之后才去断言<strong>VALID</strong>。</p></blockquote><p>当<strong>VALID</strong>被断言时，它必须保持断言状态直到握手发生，
握手发生在<strong>VALID</strong>和<strong>READY</strong>同时被断言的上升时钟边缘。</p><p>在 <em><a href="#图 a3.3">图 A3.3</a></em> 中，目标在边缘1之后断言<strong>READY</strong>，在地址、数据或控制信息有效之前。
这一确认表明它可以接受信息。源在边缘2之后提供信息并断言<strong>VALID</strong>，然后在边缘3时被识别时进行传输。
在这种情况下，传输发生在一个周期内。</p><p><a id="图 a3.3">图 A3.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.3_READY_before_VALID_handshake.png alt></a></p><p>允许目的在相应的<strong>READY</strong>断言之前等待<strong>VALID</strong>被断言。</p><p>如果<strong>READY</strong>被断言，它被允许<strong>VALID</strong>断言之前解除断言<strong>READY</strong>。
在 <em><a href="#图 a3.4">图 A3.4</a></em> 中，源和目的地恰好都表示它们在边缘1之后可以传送地址、数据或控制信息。
在这种情况下，传输发生在<strong>VALID</strong>和<strong>READY</strong>同时被断言的上升时钟边缘。这意味着传输发生在边缘2。</p><p><a id="图 a3.4">图 A3.4
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.4_VALID_with_READY_handshake.png alt></a></p><p>个别AXI通道握手机制在 <em><a href="#a3.4 通道关系">A3.4 通道关系</a></em> 中描述。</p><blockquote><p>Note：</p><ul><li><strong>VALID</strong>不能等待<strong>READY</strong>，</li><li><strong>READY</strong>可以等待<strong>VALID</strong>。</li></ul></blockquote><h4 id=a-ida33-读写通道a33-读写通道a><a id="a3.3 读写通道">A3.3 读写通道</a></h4><p>这一部分描述了AXI写通道和读通道。通道如下：</p><ul><li><em><a href="#a3.3.1 写请求通道">A3.3.1 写请求通道</a></em></li><li><em><a href="#a3.3.2 写数据通道">A3..3.2 写数据通道</a></em></li><li><em><a href="#a3.3.3 写响应通道">A3.3.3 写响应通道</a></em></li><li><em><a href="#a3.3.4 读请求通道">A3.3.4 读请求通道</a></em></li><li><em><a href="#a3.3.5 读数据通道">A3.3.5 读数据通道</a></em></li></ul><p>对于使用 <em><a href="#a15.3 dvm 消息">A15.3 dvm 消息</a></em> 的接口，额外有两个通道：</p><ul><li><em><a href="#a3.6.1 snoop请求通道（ac）">A3.6.1 snoop 请求通道（ac）</a></em></li><li><em><a href="#a3.6.2 snoop响应通道（cr）">A3.6.2 snoop响应通道（cr）</a></em></li></ul><h5 id=a-ida331-写请求通道awa331-写请求通道awa><a id="a3.3.1 写请求通道（aw）">A3.3.1 写请求通道（aw）</a></h5><p>写请求通道的控制信号如 <em><a href="#表 a3.1">表 A3.1</a></em> 所示。</p><p><a id="表 a3.1">表 A3.1</a> 写请求通道控制信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWVALID</strong></td><td>1</td><td>主机</td><td>写请求有效</td></tr><tr><td><strong>AWREADY</strong></td><td>1</td><td>从机</td><td>写请求就绪</td></tr></tbody></table><p>当主机驱动有效请求时，可以断言<strong>AWVALID</strong>信号。
当被断言时，<strong>AWVALID</strong>必须保持断言状态，直到从机在上升时钟边缘断言<strong>AWREADY</strong>。</p><p><strong>AWREADY</strong>的默认状态可以是高或低。
建议将<strong>AWREADY</strong>的默认状态设置为高。
当<strong>AWREADY</strong>为高时，从机必须能够接受呈现给它的任何有效请求。</p><p>不建议将<strong>AWREADY</strong>默认设置为低，因为这会强制传输至少需要两个周期，
一个周期用于断言<strong>AWVALID</strong>，另一个周期用于断言<strong>AWREADY</strong>。</p><h5 id=a-ida332-写数据通道wa332-写数据通道wa><a id="a3.3.2 写数据通道（w）">A3.3.2 写数据通道（w）</a></h5><p>写数据通道的控制信号如 <em><a href="#表 a3.2">表 A3.2</a></em> 所示。</p><p><a id="表 a3.2">表 A3.2</a> 写数据通道控制信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>WVALID</strong></td><td>1</td><td>主机</td><td>写数据有效</td></tr><tr><td><strong>WREADY</strong></td><td>1</td><td>从机</td><td>写数据就绪</td></tr><tr><td><strong>WLAST</strong></td><td>1</td><td>主机</td><td>写事务最后一个传输</td></tr></tbody></table><p>在写事务期间，主机只能在其驱动有效写数据时断言<strong>WVALID</strong>信号。
当断言时，<strong>WVALID</strong>必须保持断言状态，
直到从机断言<strong>WREADY</strong>之后的上升时钟边缘。</p><p><strong>WREADY</strong>的默认状态可以是高，但前提是从机始终能够在单个周期内接受写数据。</p><p>主机在驱动事务中的最后写传输时必须断言<strong>WLAST</strong>信号。</p><p>建议对于非活跃的字节通道，将<strong>WDATA</strong>驱动为零。</p><p>未使用<strong>WLAST</strong>的从机可以省略其接口中的输入。
属性WLAST_Present用于确定<strong>WLAST</strong>信号是否存在。</p><p><a id="表 a3.3">表 A3.3</a> WLAST_Present 属性</p><table><thead><tr><th>WLAST_Present</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>WLAST</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>WLAST</strong>不存在</td></tr></tbody></table><h5 id=a-ida333-写响应通道ba333-写响应通道ba><a id="a3.3.3 写响应通道（b）">A3.3.3 写响应通道（b）</a></h5><p>写响应通道的控制信号如 <em><a href="#表 a3.4">表 A3.4</a></em> 所示。</p><p><a id="表 a3.4">表 A3.4</a> 写响应通道控制信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>BVALID</strong></td><td>1</td><td>从机</td><td>写响应信号有效</td></tr><tr><td><strong>BREADY</strong></td><td>1</td><td>主机</td><td>写响应信号就绪</td></tr></tbody></table><p>从机只能在驱动有效写响应时断言<strong>BVALID</strong>信号。
当断言时，<strong>BVALID</strong>必须保持断言状态，
直到主机断言<strong>BREADY</strong>后的上升时钟边缘。</p><p><strong>BREADY</strong>BREADY的默认状态可以是高电平，但是前提是主机必须始终能在一个周期内接受写响应。</p><h5 id=a-ida334-读请求通道a334-读请求通道a><a id="a3.3.4 读请求通道">A3.3.4 读请求通道</a></h5><p>读取请求通道的控制信号如 <em><a href="#表 a3.5">表 A3.5</a></em> 所示。</p><p><a id="表 a3.5">表 A3.5</a> 读请求控制信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ARVALID</strong></td><td>1</td><td>主机</td><td>读请求有效</td></tr><tr><td><strong>ARREADY</strong></td><td>1</td><td>从机</td><td>读请求就绪</td></tr></tbody></table><p>主机只能在发出有效读请求时断言<strong>ARVALID</strong>信号。
一旦断言，<strong>ARVALID</strong>必须保持断言状态，直到从机在上升时钟边缘断言<strong>ARREADY</strong>信号。</p><p><strong>ARREADY</strong>的默认状态可以是高或低。
建议将<strong>ARREADY</strong>的默认状态设置为高。
如果<strong>ARREADY</strong>为高，则从机必须能够接受任何呈现给它的有效读请求。</p><p>不建议将<strong>ARREADY</strong>设为低，因为这会使传输至少需要两个周期，一个用于将<strong>ARVALID</strong>置为有效，
另一个用于将<strong>ARREADY</strong>置为有效</p><h5 id=a-ida235-读数据通道ra235-读数据通道ra><a id="a2.3.5 读数据通道（r）">A2.3.5 读数据通道（r）</a></h5><p>读取数据通道的控制信号如 <em><a href="#表 a3.6">表 A3.6</a></em> 所示</p><p><a id="表 a3.6 读数据通道控制信号">表 A3.6 读数据通道控制信号</a></p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>RVALID</strong></td><td>1</td><td>从机</td><td>读数据有效</td></tr><tr><td><strong>RREADY</strong></td><td>1</td><td>主机</td><td>读数据就绪</td></tr><tr><td><strong>RLAST</strong></td><td>1</td><td>从机</td><td>读事务中的最后一个传输</td></tr></tbody></table><p>从机仅在驱动读取数据通道上的有效信号时才能断言<strong>RVALID</strong>信号。
当<strong>RVALID</strong>被断言时，它必须保持断言状态，直到主机断言<strong>ARREADY</strong>RREADY后的上升时钟边缘。
即使从机只有一个读取数据源，它也必须仅在响应请求时断言<strong>RVALID</strong>信号。</p><p>主机使用信号<strong>RREADY</strong>指示它接受数据。
<strong>RREADY</strong>的默认状态可以是高，但只有在主机能够在开始读取事务且立即接受读取数据时。</p><p>每当从机驱动事务中的最终读取传输时，必须断言<strong>RLAST</strong>信号。
建议对不活动的字节通道将<strong>RDATA</strong>驱动为零。</p><p>不使用<strong>RLAST</strong>的主机可以从其接口中省略该输入。属性RLAST_Present用于确定<strong>RLAST</strong>信号是否存在。</p><p><a id="表 a3.7">表 A3.7</a> RLAST_Present 属性</p><table><thead><tr><th>RLAST_Present</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>RLAST</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>RLAST</strong>不存在</td></tr></tbody></table><h4 id=a-ida34-通道关系a34-通道关系a><a id="a3.4 通道关系">A3.4 通道关系</a></h4><p>AXI协议要求保持以下关系：</p><ul><li>写响应必须始终跟随写事务中的最后一次写传输。</li><li>读数据和读响应必须始终跟随读请求。</li><li>通道握手必须符合 <em><a href="#a3.5 通道握手依赖关系">A3.5 通道握手依赖关系</a></em> 定义。</li><li>当主机发出写请求时，必须能够提供该事务的所有写数据，而不依赖于该主机的其他事务。</li><li>当主机已发出写请求并提供所有写数据时，必须能够接受该事务的所有响应，而不依赖于该主机的其他事务。</li><li>当主机已发出读请求时，必须能够接受该事务的所有读数据，而不依赖于该主机的其他事务。</li></ul><blockquote><p>Note：主机可以依赖于使用相同ID的事务按顺序返回读数据，因此主机只需要足够的存储空间来存储具有不同ID的事务的读数据。</p></blockquote><ul><li>主机被允许在发出另一个事务请求之前等待一个事务完成。</li><li>从机被允许在接受或发出另一个事务的传输之前等待一个事务完成。</li><li>从机不能因带有前导写数据的事务而阻止接受无数据的写请求。</li></ul><p>该协议未定义通道之间的其他关系。</p><p>缺乏关系意味着写数据可以在写请求之前出现在接口处。
如果写请求通道包含比写数据通道更多的寄存器级别，就会发生这种情况。
同样，写数据可能在与写请求相同的周期内出现。</p><p>当互连需要确定目标地址空间或从机空间时，必须重新对齐请求和写数据。
此重新对齐是为了确保写数据仅向被标记为有效的从机发送。</p><h4 id=a-ida35-通道握手依赖关系a35-通道握手依赖关系a><a id="a3.5 通道握手依赖关系">A3.5 通道握手依赖关系</a></h4><p>通道之间存在写、读和snoop事务的依赖关系。这些在下面的章节中进行了描述，并包含依赖图，其中：</p><ul><li>单箭头指向可以在箭头起始信号之前或之后被断言的信号。</li><li>双箭头指向必须在箭头起始信号断言之后才能被断言的信号。</li></ul><h5 id=a-ida351-写事务依赖a351-写事务依赖a><a id="a3.5.1 写事务依赖">A3.5.1 写事务依赖</a></h5><p>对于写通道上的事务， <em><a href="#图 a3.5">图 A3.5</a></em> 显示了握手信号的依赖关系。规则如下：</p><ul><li><a id=a3.5.1.1>A3.5.1.1</a> 主机在断言<strong>AWVALID</strong>或<strong>WVALID</strong>
之前不得等待从机断言<strong>AWREADY</strong>或<strong>WREADY</strong>。这适用于事务中的每个写数据传输。</li><li><a id=a3.5.1.2>A3.5.1.2</a> 从机可以在断言<strong>AWREADY</strong>之前等待<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者。</li><li><a id=a3.5.1.3>A3.5.1.3</a> 从机可以在<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者被断言之前断言<strong>AWREADY</strong>。</li><li><a id=a3.5.1.4>A3.5.1.4</a> 从机可以在断言<strong>WREADY</strong>之前等待<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者。</li><li><a id=a3.5.1.5>A3.5.1.5</a> 从机可以在<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者被断言之前断言<strong>WREADY</strong>。</li><li><a id=a3.5.1.6>A3.5.1.6</a> 从机必须在断言<strong>BVALID</strong>之前等待
<strong>AWVALID</strong>、<strong>AWREADY</strong>、<strong>WVALID</strong>和<strong>WREADY</strong>被断言。</li><li><a id=a3.5.1.7>A3.5.1.7</a> 从机还必须在断言<strong>BVALID</strong>之前等待<strong>WLAST</strong>被断言。
这是因为写响应<strong>BRESP</strong>必须在写事务的最后一次数据传输之后发送信号。</li><li><a id=a3.5.1.8>A3.5.1.8</a> 从机不得在断言<strong>BVALID</strong>之前等待主机断言<strong>BREADY</strong>。</li><li><a id=a3.5.1.9>A3.5.1.9</a> 主机可以在断言<strong>BREADY</strong>之前等待<strong>BVALID</strong>。</li><li><a id=a3.5.1.10>A3.5.1.10</a> 主机可以在<strong>BVALID</strong>被断言之前断言<strong>BREADY</strong>。</li></ul><p><a id="图 a3.5">图 A3.5
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.5_Write_transaction_handshake_dependencies.png alt></a></p><h5 id=a-ida352-读事务依赖a352-读事务依赖a><a id="a3.5.2 读事务依赖">A3.5.2 读事务依赖</a></h5><p>对于读取通道上的事务，<em><a href="#图 a3.6">图 A3.6</a></em> 显示了握手信号的依赖关系。规则如下：</p><ul><li><a id=a3.5.2.1>A3.5.2.1</a> 主机在断言<strong>ARVALID</strong>之前不得等待从机断言<strong>ARREADY</strong>。</li><li><a id=a3.5.2.2>A3.5.2.2</a> 从机可以在断言<strong>ARREADY</strong>之前等待<strong>ARVALID</strong>被断言。</li><li><a id=a3.5.2.3>A3.5.2.3</a> 从机可以在<strong>ARVALID</strong>被断言之前断言<strong>ARREADY</strong>。</li><li><a id=a3.5.2.4>A3.5.2.4</a> 从机必须等到<strong>ARVALID</strong>和<strong>ARREADY</strong>都被断言后，
才能断言<strong>RVALID</strong>以指示有效数据可用。</li><li><a id=a3.5.2.5>A3.5.2.5</a> 从机不得等待主机断言<strong>RREADY</strong>后再断言<strong>RVALID</strong>。</li><li><a id=a3.5.2.6>A3.5.2.6</a> 主机可以在断言<strong>RREADY</strong>之前等待<strong>RVALID</strong>被断言。</li><li><a id=a3.5.2.7>A3.5.2.7</a> 主机可以在<strong>RVALID</strong>被断言之前断言<strong>RREADY</strong>。</li></ul><p><a id="图 a3.6">图 A3.6
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.6_Read_transaction_handshake_dependencies.png alt></a></p><p>总结：</p><ul><li>断言<strong>VALID</strong>不等断言<strong>READY</strong>：</br><em><a href=#a3.5.1.1>A3.5.1.1</a></em> 写请求和写</br><em><a href=#a3.5.1.8>A3.5.1.8</a></em> 写响应</br><em><a href=#a3.5.2.1>A3.5.2.1</a></em> 读请求</br><em><a href=#a3.2.2.5>A3.2.2.5</a></em> 读</br><em><a href=#a3.6.3.1>A3.6.3.1</a></em> snoop请求</br><em><a href=#a3.6.3.5>A3.6.3.5</a></em> snoop响应</li><li>断言<strong>READY</strong>可等断言<strong>VALID</strong>：</br><em><a href=#a3.5.1.2>A3.5.1.2</a></em> 写请求和写</br><em><a href=#a3.5.1.9>A3.5.1.9</a></em> 写响应</br><em><a href=#a3.5.1.4>A3.5.1.4</a></em> 写请求和写</br><em><a href=#a3.5.2.2>A3.5.2.2</a></em> 读请求</br><em><a href=#a3.5.2.6>A3.5.2.6</a></em> 读</br><em><a href=#a3.6.3.2>A3.6.3.2</a></em> snoop请求</br><em><a href=#a3.6.3.6>A3.6.3.6</a></em> snoop响应</li><li>断言<strong>VALID</strong>和断言<strong>READY</strong>没有先后关系：</br><em><a href=#a3.5.1.3>A3.5.1.3</a></em> 写请求和写</br><em><a href=#a3.5.1.5>A3.5.1.5</a></em> 写请求和写</br><em><a href=#a3.5.1.10>A3.5.1.10</a></em> 写响应</br><em><a href=#a3.5.2.3>A3.5.2.3</a></em> 读请求</br><em><a href=#a3.5.2.7>A3.5.2.7</a></em> 读</br><em><a href=#a3.6.3.3>A3.6.3.3</a></em> snoop请求</br><em><a href=#a3.6.3.6>A3.6.3.7</a></em> snoop响应</li><li>断言<strong>BVALID</strong>必须在写传输完成之后：</br><em><a href=#a3.5.1.6>A3.5.1.6</a></em> 写响应在写请求和写之前</br><em><a href=#a3.5.1.7>A3.5.1.7</a></em> 写响应在最后一笔写传输之前</br></li><li>断言<strong>RVALID</strong>必须在<strong>ARVALID</strong>和<strong>ARREADY</strong>断言之后：</br><em><a href=#a3.5.2.4>A3.5.2.4</a></em> 读有效在读请求有效和就绪之前</li><li>断言<strong>CRVALID</strong>必须在<strong>ACVALID</strong>和<strong>ACREADY</strong>断言之后：</br><em><a href=#a3.6.3.4>A3.6.3.4</a></em> snoop响应有效在snoop请求有效和就绪之前</li></ul><h4 id=a-ida36-snoop通道a36-snoop通道a><a id="a3.6 snoop通道">A3.6 snoop通道</a></h4><p>DVM消息在互连和管理组件之间通过snoop通道传输。
当支持DVM消息时，会有一个snoop请求通道（AC）和一个snoop响应通道（CR）。</p><h5 id=a-ida361-snoop请求通道aca361-snoop请求通道aca><a id="a3.6.1 snoop请求通道（ac）">A3.6.1 snoop请求通道（ac）</a></h5><p>snoop请求通道的控制信号如 <em><a href="#表 a3.8">表 A3.8</a></em> 所示。</p><p><a id="表 a3.8">表 A3.8</a> snoop请求通道控制</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ACVALID</strong></td><td>1</td><td>从机</td><td>snoop请求有效</td></tr><tr><td><strong>ACREADY</strong></td><td>1</td><td>主机</td><td>snoop请求就绪</td></tr></tbody></table><p>从机只能在驱动有效地址和控制信息时断言<strong>ACVALID</strong>信号。
当<strong>ACVALID</strong>被断言时，它必须保持断言状态，直到主机断言<strong>ACREADY</strong>信号的上升时钟边缘。</p><p><strong>ACREADY</strong>的默认状态可以是高或低。
建议将<strong>ACREADY</strong>的默认状态设置为高。
如果<strong>ACREADY</strong>为高，则主机必须能够接受任何呈现给它的有效请求。</p><p>不推荐将<strong>ACREADY</strong>的默认状态设置为低，因为这会迫使传输至少需要两个时钟周期，
一个用于断言<strong>ACVALID</strong>，另一个用于断言<strong>ACREADY</strong>。</p><h5 id=a-ida362-snoop响应信号cra362-snoop响应信号cra><a id="a3.6.2 snoop响应信号（cr）">A3.6.2 snoop响应信号（cr）</a></h5><p>snoop响应通道的控制信号如 <em><a href="#表 a3.9">表 A3.9</a></em> 所示。</p><p><a id="表 a3.9">表 A3.9</a> snoop响应信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>CRVALID</strong></td><td>1</td><td>主机</td><td>snoop响应有效</td></tr><tr><td><strong>CRREADY</strong></td><td>1</td><td>从机</td><td>snoop响应就绪</td></tr></tbody></table><p>主机只有在它在snoop响应通道上驱动有效信号时才能断言<strong>CRVALID</strong>CRVALID信号。
当<strong>CRVALID</strong>被断言时，必须保持断言状态，直到从机断言<strong>CRREADY</strong>后的时钟上升沿。</p><p>从机使用<strong>CRREADY</strong>信号表示它接受响应。
<strong>CRREADY</strong>的默认状态可以为高，但前提是从机能够在开始snoop事务时立即接受snoop响应。</p><h5 id=a-ida363-snoop事务依赖a363-snoop事务依赖a><a id="a3.6.3 snoop事务依赖">A3.6.3 snoop事务依赖</a></h5><p>对于snoop通道上的事务，<em><a href="#图 a3.7">图 A3.7</a></em> 显示了握手信号依赖关系。规则如下：</p><ul><li><a id=a3.6.3.1>A3.6.3.1</a> 从机在断言<strong>ACVALID</strong>之前不得等待主机断言<strong>ACREADY</strong>。</li><li><a id=a3.6.3.2>A3.6.3.2</a> 主机可以在断言<strong>ACREADY</strong>之前等待<strong>ACVALID</strong>被断言。</li><li><a id=a3.6.3.3>A3.6.3.3</a> 主机可以在<strong>ACVALID</strong>被断言之前断言<strong>ACREADY</strong>。</li><li><a id=a3.6.3.4>A3.6.3.4</a> 主机必须等待<strong>ACVALID</strong>和<strong>ACREADY</strong>都被断言后才能断言<strong>CRVALID</strong>，以表示有效响应可用。</li><li><a id=a3.6.3.5>A3.6.3.5</a> 主机不得等待从机断言<strong>CRREADY</strong>后再断言<strong>CRVALID</strong>。</li><li><a id=a3.6.3.6>A3.6.3.6</a> 从机可以在断言<strong>CRREADY</strong>之前等待<strong>CRVALID</strong>被断言。</li><li><a id=a3.6.3.7>A3.6.3.7</a> 从机可以在<strong>CRVALID</strong>被断言之前断言<strong>CRREADY</strong>。</li></ul><p><a id="图 a3.7">图 A3.7
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.7_Snoop_transaction_handshake_dependencies.png alt></a></p><h3 id=a-ida第4章-事务a第4章-事务a><a id="a第4章 事务">A第4章 事务</a></h3><p>AXI协议使用事务在主机和从机之间进行通信。
所有事务包括请求和响应。</p><p>写和读事务也包括一个或多个数据传输。</p><p>本章描述了事务请求、响应和数据传输。它包含以下几个部分</p><ul><li><em><a href="#a4.1 事务请求">A4.1 事务请求</a></em></li><li><em><a href="#a4.2 读写数据">A4.2 读写数据</a></em></li><li><em><a href="#a4.3 事务响应">A4.3 事务响应</a></em></li></ul><h4 id=a-ida41-事务请求a41-事务请求a><a id="a4.1 事务请求">A4.1 事务请求</a></h4><p>AXI主机通过向从机发出请求来启动事务。
请求包括事务属性和第一次数据传输的地址。
如果事务包含多个数据传输，从机必须计算后续传输的地址。</p><p>事务不得跨越4KB地址边界，这防止了事务跨越两个从机之间的边界。
这也限制了从机必须支持的地址增量数量。</p><h5 id=a-ida411-大小属性a411-大小属性a><a id="a4.1.1 大小属性">A4.1.1 大小属性</a></h5><p>size表示每次数据传输中的最大字节数.</p><p>对于读取事务，size表示每次读取数据传输中必须有效的数据字节数.</p><p>对于写入事务，size表示允许活动的数据字节通道数，<strong>WSTRB</strong> 指示在每次传输中哪些字节是有效的。</p><p>size不得超过接口的数据宽度，这由DATA_WIDTH属性确定。</p><p>如果size小于DATA_WIDTH，则在每次传输中使用字节通道的一个子集。</p><p>size通过写请求和读请求通道上的<strong>AWSIZE</strong>和<strong>ARSIZE</strong>信号进行传达，
在本规范中，<strong>AxSIZE</strong>表示<strong>AWSIZE</strong>和<strong>ARSIZE</strong>。</p><p><a id="表 a4.1">表 A4.1</a> <strong>AxSIZE</strong>信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWSIZE</strong></br><strong>ARSIZE</strong></td><td>3</td><td>DATA_WIDTH/8</td><td>一个事务中每次传输的最大字节数</td></tr></tbody></table><p>size通过<strong>AxSIZE</strong>信号进行编码，如 <em><a href="#表 a4.2">表 A4.2</a></em> 所示。</p><table><thead><tr><th><strong>AxSIZE</strong></th><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>0b000</td><td>1</td><td>每次传输最多1Byte</td></tr><tr><td>0b001</td><td>2</td><td>每次传输最多2Byte</td></tr><tr><td>0b010</td><td>4</td><td>每次传输最多4Byte</td></tr><tr><td>0b011</td><td>8</td><td>每次传输最多8Byte</td></tr><tr><td>0b100</td><td>16</td><td>每次传输最多16Byte</td></tr><tr><td>0b101</td><td>32</td><td>每次传输最多32Byte</td></tr><tr><td>0b110</td><td>64</td><td>每次传输最多64Byte</td></tr><tr><td>0b111</td><td>128</td><td>每次传输最多128Byte</td></tr></tbody></table><p>如 <em><a href="#表 a4.3">表 A4.3</a></em> 所示，属性 SIZE_Present 用于确定 <strong>AxSIZE</strong> 信号是否存在。</p><p><a id="表 a4.3">表 A4.3</a> SIZE_Present 属性</p><table><thead><tr><th>SIZE_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWSIZE</strong>和<strong>ARSIZE</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWSIZE</strong>和<strong>ARSIZE</strong>不存在</td></tr></tbody></table><p>一个只发出全数据宽度请求的主机可以从其接口中省略<strong>AxSIZE</strong>输出。
相应的从机必须根据数据宽度将其<strong>AxSIZE</strong>输入连接起来。</p><h5 id=a-ida412-长度属性a412-长度属性a><a id="a4.1.2 长度属性">A4.1.2 长度属性</a></h5><p>Length属性定义了事务中的数据传输次数。</p><p>Size x Length是一个事务中可以传输的最大字节数。如果地址未对齐或存在未使能的<strong>WSTRB</strong>，实际传输的字节数可能低于Size x Length。</p><p>主机必须根据Length发出写数据传输的数量。</p><p>从机必须根据Length发出读数据传输的数量。</p><p>Length通过写请求和读请求通道上的<strong>AWLEN</strong>和<strong>ARLEN</strong>信号进行通信。</p><p>在本规范中<strong>AxLEN</strong>表示<strong>AWLEN</strong>和<strong>ARLEN</strong>，如 <em><a href="#表 a4.4">表 A4.4</a></em> 所示。</p><p><a id="表 a4.4">表 A4.4</a> <strong>AxLEN</strong>信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWLEN</strong><br><strong>ARLEN</strong></td><td>8</td><td>0x00</td><td>事务的传输数量，Length=AxLEN+1</td></tr></tbody></table><p>属性 LEN_Present 用于确定信号是否存在，<em><a href="#表 a4.5">表 A4.5</a></em> 显示了 LEN_Present 的合法值。</p><p><a id="表 a4.5">表 A4.5</a> LEN_Present属性</p><table><thead><tr><th>LEN_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWLEN</strong>和 <strong>ARLEN</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWLEN</strong>和 <strong>ARLEN</strong>不存在</td></tr></tbody></table><p>一个只发出长度为1请求的主机可以从其接口中省略<strong>AxLEN</strong>输出。
相应的下属必须将其<strong>AxLEN</strong>输入连接到0x00。以下规则适用于事务长度：</p><ul><li>对于wrap突发，长度可以是2、4、8或16。</li><li>对于固定突发，长度可以达到16。</li><li>事务不得跨越4KB地址边界。</li><li>不支持事务的提前终止。</li></ul><p>没有组件可以提前终止事务。
然而，为了减少写事务中的数据传输次数，主机可以通过取消所有<strong>WSTRB</strong>的有效状态来禁用进一步的写入。
在这种情况下，主机必须完成事务中的其余传输。
在读取事务中，主机可以丢弃读取数据，但必须完成事务中的所有传输。</p><h5 id=a-ida413-事务的最大传输byea413-事务的最大传输byea><a id="a4.1.3 事务的最大传输bye">A4.1.3 事务的最大传输bye</a></h5><p>一个事务的最大字节数为4KB，事务不允许跨越4KB边界。
然而，许多主机生成的事务可能始终小于此值。</p><p>一个从机或互连可能会从这些信息中受益。例如，一个从机可借此优化一些解码逻辑。
一个在小于4KB粒度下进行条带化的互连如果知道事务不会跨越条带边界，可能能够避免突发拆分。</p><p>属性Max_Transaction_Bytes定义了一个事务的最大字节数，如 <em><a href="#表 a4.6">表 A4.6</a></em> 所示。</p><p><a id="表 a4.6">表 A4.6</a> Max_Transaction_Bytes 属性</p><table><thead><tr><th>名字</th><th>值</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>Max_Transaction_Bytes</td><td>64,128,256,512,1024048,4096</td><td>4096</td><td>一个主机发起的事务大小与长度之积不得超过最大传输字节数，且传输不得跨越最大传输字节数的边界。<br>一个从机只能接受大小与长度之积不超过最大传输字节数的传输。</td></tr></tbody></table><p>在连接主机和从机时，<em><a href="#表 a4.7">表 A4.7</a></em> 指示了兼容的 Max_Transaction_Bytes 组合。</p><p><a id="表 a4.7">表 A4.7</a> Max_Transaction_Bytes 互联</p><table><thead><tr><th>主机 &lt; 从机</th><th>主机 == 从机</th><th>主机 > 从机</th></tr></thead><tbody><tr><td>兼容</td><td>兼容</td><td>不兼容</td></tr></tbody></table><h5 id=a-ida414-突发属性a414-突发属性a><a id="a4.1.4 突发属性">A4.1.4 突发属性</a></h5><p>Burst属性描述了在事务中传输之间地址的递增方式。有三种不同的Burst类型：</p><ul><li><p>固定（FIXED）</br>此Burst类型用于对同一位置的重复访问，例如在加载或清空FIFO时。</p><ul><li>在Burst中的每次传输的地址都相同。</li><li>有效的字节通道对于所有传输都是恒定的。然而，在这些字节通道内，实际的<strong>WSTRB</strong>有效的字节在每次传输中可能不同。</li><li>Burst的长度可以达到16次传输。</li><li>固定Burst类型仅可与WriteNoSnoop或ReadNoSnoop操作码一起使用。
有关更多信息，请参见 <em><a href=#a第8章请求操作码>A第8章请求操作码</a></em> 。</li></ul></li><li><p>增量（INCR）</br>对于此Burst类型，每次传输的地址是前一次传输地址的递增。
递增值取决于事务的大小。例如，对于对齐的起始地址，事务中每次传输的地址是前一个地址加4。此Burst类型用于对正常顺序内存的访问。</p></li><li><p>回环（WRAP）</br></p><ul><li>此Burst类型类似于增量，除了在达到上限地址时地址会回环到较低的地址。适用以下限制：<ul><li>起始地址必须与每次传输的大小对齐。</li><li>Burst的长度必须为2、4、8或16次传输。</br></li></ul></li><li>回环事务的行为是：<ul><li>事务访问的最低地址是与要传输的数据总大小对齐的起始地址，即Size * Length。此地址被定义为回环边界。</li><li>每次传输后，地址的递增方式与增量Burst相同。然而，如果这个递增的地址是((回环边界) + (Size * Length))，则地址会回环到回环边界。</li><li>事务中的第一次传输可以使用高于回环边界的地址，前提是遵守适用于回环事务的限制。
当第一次地址高于回环边界时，地址会回环。此Burst类型用于缓存行访问。</li></ul></li></ul></li></ul><p>通过<strong>AWBURST</strong>和<strong>ARBURST</strong>信号分别在写请求和读请求通道上传达Burst。
在本规范中，<strong>AxBURST</strong>指示<strong>AWBURST</strong>和<strong>ARBURST</strong>。</p><p><a id="表 a4.8">表 A4.8</a> <strong>AxBURST</strong>信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWBURST</strong><br><strong>ARBURST</strong></td><td>2</td><td>0b01（INCR）</td><td>描述了事务中传输之间地址递增方式</td></tr></tbody></table><p>Burst在<strong>AxBURST</strong>信号上进行编码如 <em><a href="#表 a4.9">表 A4.9</a></em> 所示。</p><p><a id="表 a4.9">表 A4.9</a> <strong>AxBURST</strong>编码</p><table><thead><tr><th><strong>AxBURST</strong></th><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>FIXED</td><td>固定突发</td></tr><tr><td>0101</td><td>INCR</td><td>增量突发</td></tr><tr><td>0b10</td><td>WRAP</td><td>回环突发</td></tr><tr><td>0b11</td><td>保留</td><td>-</td></tr></tbody></table><p>属性BURST_Present用于确定<strong>AxBURST</strong>信号是否存在。
只发出类型为INCR的Burst请求的主机可以从其接口中省略<strong>AxBURST</strong>输出。
相应的从机必须将其<strong>AxBURST</strong>输入连接到0b01。</p><p><a id="表 a4.10">表 A4.10</a> BURST_Present属性</p><table><thead><tr><th>BURST_Present</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWBURST</strong>和<strong>ARBURST</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWBURST</strong>和<strong>ARBURST</strong>不存在</td></tr></tbody></table><p>一种突发类型的固定不常用属性，并在 <em><a href="#表 a4.11">表 A4.11</a></em> 中定义了属性Fixed_Burst_Disable以指示组件是否支持它。</p><p><a id="表 a4.11">表 A4.11</a> Fixed_Burst_Disable属性</p><table><thead><tr><th>Fixed_Burst_Disable</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>突发类型为FIXED的请求不支持由从机生成，也不由主机生成</td></tr><tr><td>False</td><td>Y</td><td>突发类型为FIXED的请求支持由从机生成，或主机生成</td></tr></tbody></table><p>根据 Fixed_Burst_Disable 属性的值，<em><a href="#表 a4.12">表 A4.12</a></em> 显示了主机和从机之间的兼容性。</p><p><a id="表 a4.12">表 A4.12</a>Fixed_Burst_Disable 兼容性</p><table><thead><tr><th>Fixed_Burst_Disable</th><th>从机：False</th><th>从机True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>不兼容</td></tr><tr><td>主机：True</td><td>兼容</td><td>兼容</td></tr></tbody></table><h5 id=a-ida415-传输地址a415-传输地址a><a id="a4.1.5 传输地址">A4.1.5 传输地址</a></h5><p>本节提供了在事务中确定传输的地址和字节通道的方法。事务的起始地址通过<strong>AxADDR</strong>信号指示。</p><p><a id="表 a4.13">表 A4.13</a> <strong>AxADDR</strong>信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWADDR</strong><br><strong>ARADDR</strong></td><td>ADDR_WIDTH</td><td>−</td><td>事务第一次传输的地址</td></tr></tbody></table><p>属性ADDR_WIDTH用于定义地址宽度。</p><p><a id="表 a4.14">表 A4.14</a> ADDR_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>ADDR_WIDTH</td><td>1&mldr;64</td><td>32</td><td><strong>AWADDR</strong>、<strong>ARADDR</strong>、<strong>ACADDR<strong>的地址</td></tr></tbody></table><p>该协议支持具有不同物理地址空间大小的组件之间的通信。</p><p>具有不同物理地址空间大小的组件必须按如下方式进行通信</p><ul><li>物理地址空间较小的组件必须位于较大物理地址空间中的对齐窗口内。
通常，窗口位于较大物理地址空间的底部。
但是，物理地址空间较小的组件可以位于较大物理地址空间中的偏移窗口内。</li><li>外部事务必须将所需的额外高位添加到事务地址中。</li><li>内部事务必须做以下检查：<ul><li>在地址窗口内的事务去掉高位地址位并被传递。</li><li>不具有所需高位地址位的事务被抑制。</li></ul></li></ul><blockquote><p>Note：
高位地址位通常携带了用于选择存储器或I/O设备特定区域的信息。
在计算机系统中，地址被分为高位和低位，高位地址线用于选择更大的地址范围或特定的存储区域，而低位地址线用于具体单元或设备的寻址</p></blockquote><p>提供所需功能是互联的责任</p><h5 id=a-ida416-事务方程a416-事务方程a><a id="a4.1.6 事务方程">A4.1.6 事务方程</a></h5><p>该文中列出的方程用于确定事务中每次传输的地址和活动数据字节通道。方程使用以下变量：</p><ul><li>Start_Addr：由主机发出的起始地址。</li><li>Data_Bytes：数据通道的宽度（以字节为单位）（DATA_WIDTH/8）。</li><li>Aligned_Addr：起始地址的对齐地址。</li><li>Address_N：事务中传输N的地址。事务中第一次传输N的值为1。</li><li>Wrap_Boundary：wrap突发事务中的回环边界地址。</li><li>Lower_Byte_Lane：传输中最低寻址字节的字节通道。</li><li>Upper_Byte_Lane：传输中最高寻址字节的字节通道。</li><li>INT(x)：对x向下取整的整数值。</li></ul><p>这些方程确定突发内传输的地址：<br><code>Start_Addr = AxADDR</code><br><code>Aligned_Addr = INT(Start_Addr / Size)* Size</code></p><p>该方程确定突发中第一次传输的地址：<br><code>Address_1 = Start_Addr</code></p><p>对于INCR突发和地址未回环的WRAP突发，该方程确定突发中首次传输后的任何传输地址：<br><code>Address_N = Aligned_Addr + (N - 1)* Size</code></p><p>对于WRAP突发，Wrap_Boundary变量定义回环边界：<br><code>Wrap_Boundary = INT(Start_Addr / (Size * Length))* Size * Length</code></p><p>对于WRAP突发，如果Address_N = Wrap_Boundary + Size * Length，则：</p><ul><li>对于当前传输使用该方程：<br><code>Address_N = Wrap_Boundary</code></li><li>对于任何后续传输使用该方程：<br><code>Address_N = Start_Addr + ((N - 1)* Size)- (Size * Length)</code></li></ul><p>这些方程确定突发中第一次传输使用的字节通道：<br><code>Lower_Byte_Lane = Start_Addr - (INT(Start_Addr/Data_Bytes)* Data_Bytes)</code><br><code>Upper_Byte_Lane = Aligned_Addr + (Size-1)- (INT(Start_Addr/Data_Bytes)* Data_Bytes)</code></p><p>这些方程确定突发中第一次传输之后所有传输使用的字节通道：<br><code>Lower_Byte_Lane = Address_N - (INT(Address_N / Data_Bytes)* Data_Bytes)</code><br><code>Upper_Byte_Lane = Lower_Byte_Lane + Size - 1</code></p><p>数据传输在：<br><code>DATA((8 * Upper_Byte_Lane)+ 7: (8 * Lower_Byte_Lane))</code></p><p>事务容器描述在该事务中可以访问的所有字节，如果地址对齐且触发信号得到确认：<br><code>Container_Size = Size * Length</code></p><p>对于INCR突发：<br><code>Container_Lower = Aligned_Addr</code><br><code>Container_Upper = Aligned_Addr + Container_Size</code></p><p>对于WRAP突发：<br><code>Container_Lower = Wrap_Boundary</code><br><code>Container_Upper = Wrap_Boundary + Container_Size</code></p><h5 id=a-ida417-传输描述的伪代码a417-传输描述的伪代码a><a id="a4.1.7 传输描述的伪代码">A4.1.7 传输描述的伪代码</a></h5><pre tabindex=0><code>// DataTransfer()
// IsWrite is TRUE for a write, and FALSE for a read
DataTransfer(Start_Addr, Size, Length, Data_Bytes, Burst, IsWrite)

	addr = Start_Addr; // Variable for current address
	Aligned_Addr = (INT(addr/Size) * Size);
	aligned = (Aligned_Addr == addr); // Check whether addr aligned to Size
	Container_Size = Size * Length;
	
	if Burst == WRAP then
		Lower_Wrap_Boundary = (INT(addr/Container_Size) * Container_Size);
		// addr must be aligned for a wrapping burst
		Upper_Wrap_Boundary = Lower_Wrap_Boundary + Container_Size;

	for n = 1 to Length
		Lower_Byte_Lane = addr - (INT(addr/Data_Bytes) * Data_Bytes);
		if aligned then
			Upper_Byte_Lane = Lower_Byte_Lane + Size - 1
		else
			Upper_Byte_Lane = Aligned_Addr + Size - 1 - (INT(addr/Data_Bytes) * Data_Bytes);

		// Perform data transfer
		if IsWrite then
			dwrite(addr, Lower_Byte_Lane, Upper_Byte_Lane)
		else
			dread(addr, Lower_Byte_Lane, Upper_Byte_Lane);

		// Increment address if necessary
		if Burst != FIXED then
			if aligned then
				addr = addr + Size;
				if Burst == WRAP then
					if addr &gt;= Upper_Wrap_Boundary then 
						addr = Lower_Wrap_Boundary;
					else
						addr = Aligned_Addr + Size;
						aligned = TRUE; // All transfers after the first are aligned
		return;
</code></pre><h5 id=a-ida418-常规事务a418-常规事务a><a id="a4.1.8 常规事务">A4.1.8 常规事务</a></h5><p>事务有许多突发、大小和长度的选项。
然而，一些接口和事务类型可能只使用这些选项的一个子集。
如果一个从机连接到一个仅使用事务选项子集的主机，它可以设计为简化型解码逻辑。</p><p>Regular属性被定义为识别符合以下标准的事务：</p><ul><li>长度为1、2、4、8或16次传输。</li><li>如果长度大于1，则大小与数据通道宽度相同。</li><li>突发为INCR或WRAP，而不是FIXED。<ul><li>对于INCR事务，地址与事务容器对齐。</li><li>对于WRAP事务，地址与大小对齐。</li></ul></li></ul><p>Regular_Transactions_Only属性用于定义一个主机是否仅发出常规类型的事务，
以及一个从机是否仅支持常规事务。</p><p><a id="表 a4.15">表 A4.15</a> Regular_Transaction_Only属性</p><table><thead><tr><th>Regular_Transactions_Only</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>只有常规事务被支持</td></tr><tr><td>False</td><td>Y</td><td>所有合法<strong>AxBURST</strong>、<strong>AxSIZE</strong>、<strong>AxLEN</strong>的组合都支持</td></tr></tbody></table><p>常规交易的互操作性规则见 <em><a href=#a4.16>A4.16</a></em></p><p><a id="表 a4.16">表 A4.16</a> Regular_Transactions_Only互操作性</p><table><thead><tr><th>Regular_Transactions_Only</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>不兼容<br>如果主机发布的事务不是常规的，那么可能会发生数据损坏或死锁</td></tr><tr><td>主机：True</td><td>兼容</td><td>兼容</td></tr></tbody></table><h4 id=a-ida42-读写数据a42-读写数据a><a id="a4.2 读写数据">A4.2 读写数据</a></h4><p>本节描述了AXI写入和读取数据通道上不同大小的传输，以及接口如何执行混合字节序和非对齐传输。</p><h5 id=a-ida421-write-strobesa421-write-strobesa><a id="a4.2.1 write strobes">A4.2.1 write strobes</a></h5><p><strong>WSTRB</strong>信号携带写使能信号，指定写数据通道的哪些字节通道包含有效的信息。</p><p><a id="表 a4.17">表 A4.17</a> <strong>WSTRB</strong>信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>WSTRB</strong></td><td>WDATA_WIDTH/8</td><td>全1</td><td>表明写事务中每次传输<strong>WDATA</strong>的哪些字节有效</td></tr></tbody></table><p>每8位写数据通道都对应一位的<strong>WSTRB</strong>，因此WSTRB[n]对应于WDATA[(8n)+7:(8n)]。<br>当<strong>WVALID</strong>为高电平时：</p><ul><li>要写入的数据字节与<strong>WSTRB</strong>信号相应的bit被设为高电平。</li><li>在事务容器内部，可以有任意数量的<strong>WSTRB</strong>信号bit为高电平。
如果所有<strong>WSTRB</strong>信号bit都为低电平，则该传输不写入任何数据。</li><li>在事务容器外部，所有<strong>WSTRB</strong>信号bit必须为低电平。</li></ul><p>当<strong>WVALID</strong>为低电平时，<strong>WSTRB</strong>信号可以取任何值，
但建议将其保持在低电平或保持在之前的值上。</p><p>建议在<strong>WSTRB</strong>信号为低电平时，<strong>WDATA</strong>的字节通道设为零。</p><p>属性WSTRB_Present用于指示接口上是否存在<strong>WSTRB</strong>信号。</p><p><a id="表 a4.18">表 A4.18</a> WSTRB_Present属性</p><table><thead><tr><th>WSTRB_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>WSTRB</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>WSTRB</strong>不存在</td></tr></tbody></table><p>一个只在所有<strong>WSTRB</strong>信号bit都被激活时发出事务的主机可以省略其接口中的<strong>WSTRB</strong>输出。
相应的从机必须将其<strong>WSTRB</strong>输入固定为高电平。</p><h5 id=a-ida422-窄传输a422-窄传输a><a id="a4.2.2 窄传输">A4.2.2 窄传输</a></h5><p>当主机生成的传输比其数据通道窄时，地址和控制信息决定了传输使用的字节通道：</p><ul><li>当突发模式为INCR或WRAP时，事务中的每个数据传输使用不同的字节通道。</li><li>当突发模式为FIXED时，事务中的每个数据传输使用相同的字节通道。</li></ul><p>字节通道使用的两个示例显示在 <em><a href="#图 a4.1">图 A4.1</a></em> 和 <em><a href="#图 a4.2">图 A4.2</a></em> 中。
阴影单元表示未传输的字节。
在 <em><a href="#图 a4.1">图 A4.1</a></em> 中：</p><ul><li>事务有五个数据传输。</li><li>起始地址为0。</li><li>每个传输为8位。</li><li>传输在32位数据通道上进行。</li><li>突发类型为INC。</li></ul><p><a id="图 a4.1">图 A4.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.1_Narrow_transfer_example_with_8-bit_transfers.png alt></a></p><p>在 <em><a href="#图 a4.2">图 A4.2</a></em> 中</p><ul><li>该事务有三个数据传输。</li><li>起始地址是4。</li><li>每个传输为32位。</li><li>传输在64位数据通道上。</li><li>突发类型是INCR。</li></ul><p><a id="图 a4.2">图 A4.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.2_Narrow_transfer_example_with_32-bit_transfers.png alt></a></p><h5 id=a-ida423-字节不变性a423-字节不变性a><a id="a4.2.3 字节不变性">A4.2.3 字节不变性</a></h5><p>为了在单一内存空间中访问混合字节序的数据结构，AXI协议使用了字节不变的字节序方案。</p><p>字节不变的字节序意味着在数据结构中的任何多字节元素：</p><ul><li>元素使用相同的连续内存字节，与数据的字节序无关。</li><li>字节序决定了内存中这些字节的顺序，这意味着它决定了内存中的第一个字节是元素的最高有效字节（MSB）还是最低有效字节（LSB）。</li><li>任何字节传输到一个地址时，会将8位数据通过相同的数据通道线传输到相同的地址位置，无论它所属的较大数据元素的字节序如何。</li></ul><p>只有一种传输宽度的组件必须将其字节通道连接到数据通道的适当字节通道。
支持多种传输宽度的组件可能需要更复杂的接口来转换不是自然字节不变的接口。</p><p>大多数小端组件可以直接连接到字节不变接口。
仅支持大端传输的组件需要一个转换函数以实现字节不变操作。</p><p><em><a href="#图 a4.3">图 A4.3</a></em> 和 <em><a href="#图 a4.4">图 A4.4</a></em> 中的示例显示了一个32位数字0x0A0B0C0D，
存储在寄存器和内存中。</p><p>在 <em><a href="#图 a4.3">图 A4.3</a></em> 中，有一个大端字节不变数据结构的示例，在该结构中：</p><ul><li>数据的最高有效字节（MSB），即0x0A，存储在寄存器的最高有效字节位置。</li><li>数据的最高有效字节（MSB），存储在最低地址的内存位置。</li><li>其他数据字节按重要性递减顺序排列。</li></ul><p><a id="图 a4.3">图 A4.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.3_Example_big-endian_byte-invariant_data_structure.png alt></a></p><p>在 <em><a href="#图 a4.4">图 A4.4</a></em> 中，有一个小端字节不变数据结构的示例在这个结构中：</p><ul><li>数据的最低有效位（LSB），即0x0D，存储在寄存器的最低有效位位置。</li><li>数据的最低有效位（LSM），存储在地址最低的内存位置。</li><li>其他数据字节按重要性递增的顺序排列。</li></ul><p><a id="图 a4.4">图 A4.4
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.4_Example_little-endian_byte-invariant_data_structure.png alt></a></p><p><em><a href="#图 a4.3">图 A4.3</a></em> 和 <em><a href="#图 a4.4">图 A4.4</a></em> 中的示例显示了
字节不变性确保大端和小端结构可以在单一内存空间中共存且不会出现损坏。</p><p><em><a href="#图 a4.5">图 A4.5</a></em> 中有一个需要字节不变访问的数据结构示例，在这个示例中标头字段使用小端排序而有效负载使用大端排序。</p><p><a id="图 a4.5">图 A4.5
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.5_Example_mixed-endian_data_structure.png alt></a></p><p>在这个示例结构中，Data items是一个两字节的小端元素，这意味着其最低地址是最低有效位。
字节不变量的使用确保了大端对负载的访问不会破坏小端元素。</p><h5 id=a-ida424-不对齐传输a424-不对齐传输a><a id="a4.2.4 不对齐传输">A4.2.4 不对齐传输</a></h5><p>AXI支持非对齐传输。
对于由超过1kB的数据传输组成的任何事务，初始访问的字节可能与自然地址边界不对齐。
例如开始于字节地址0x1002的32位数据包未对齐到自然32位地址边界，</p><p>主机可以：</p><ul><li>使用低位地址线来表示非对齐的起始地址.</li><li>提供对齐地址并使用字节行strobes来表示非对齐的起始地址。</li></ul><p>低位地址线上的信息必须与字节行strobes上的信息一致。</p><p>从机不需要基于主机提供的任何对齐信息采取特殊行动。</p><p><em><a href="#图 a4.6">图 A4.6</a></em> 显示了32位数据通道上对齐和非对齐32位事务的示例。
图中的每一行表示一次传输并且阴影单元表示未传输的字节。</p><p><a id="图 a4.6">图 A4.6
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.6_Aligned_and_unaligned_transfers_on_a_32-bit_data_channel.png alt></a></p><p>在 <em><a href="#图 a4.7">图 A4.7</a></em> 中，有一些在64位数据通道上对齐和未对齐的32位事务示例。
图中每一行代表一次传输，阴影单元格表示未传输的字节。</p><p><a id="图 a4.7">图 A4.7
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.7_Aligned_and_unaligned_transfers_on_a_64-bit_data_channel.png alt></a></p><p>在 <em><a href="#图 a4.8">图 A4.8</a></em> 中有一个在64位数据通道上对齐的32位回环事务的示例。
图中的每一行表示一个传输，阴影的单元格表示未传输的字节。</p><p><a id="图 a4.8">图 A4.8
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.8_Aligned_wrapping_transfers_on_a_64-bit_channel.png alt></a></p><h4 id=a-ida43-事务响应a43-事务响应a><a id="a4.3 事务响应">A4.3 事务响应</a></h4><p>每个AXI事务都包括一个或多个由从机发送的响应传输，以指示事务的结果。</p><p>写通道上的事务有一个或多个写响应。</p><p>读通道上的事务有一个或多个读响应。</p><p>原子事务有写和读响应，请参见 <em><a href="#a7.4 原子事务">A7.4 原子事务</a></em> 。</p><h5 id=a-ida431-写响应a431-写响应a><a id="a4.3.1 写响应">A4.3.1 写响应</a></h5><p>写响应通过写响应通道上的<strong>BRESP</strong>信号进行传输。
写通道上的所有事务都有一个完成响应，它指示事务的结果。
一些事务还有第二个写响应，例如指示持久性。
参见 <em><a href="#a10.8.4 b通道上的pcmo响应">A10.8.4 B通道上的PCMO响应</a></em> 。</p><p><strong>BRESP</strong>和<strong>BCOMP</strong>信号用于发送写响应。</p><p><a id="表 a4.19">表 A4.19</a> <strong>BRESP</strong> 和 <strong>BCOMP</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>BRESP</strong></td><td>BRESP_WIDTH</td><td>0b00（OKAY）</td><td>写通道的事务响应</td></tr><tr><td><strong>BCOMP</strong></td><td>1</td><td>0b1</td><td>断言为高，表明完成响应</td></tr></tbody></table><p>BRESP_WIDTH属性在 <em><a href="#表 a4.20">表 A4.20</a></em> 中有显示。</p><p><a id="表 a4.20">表 A4.20</a> BRESP_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>BRESP_WIDTH</td><td>0,2,3</td><td>2</td><td><strong>BRESP</strong>的位宽。<br>如果是下列情况，则必须是3：<br>Untranslated_Transactions = v2<br>Untranslated_Transactions =v3<br>WriteDeferrable_Transaction = True</td></tr></tbody></table><p><strong>BRESP</strong>是一个可选信号。如果BRESP_WIDTH属性为0，则该信号不存在，并被假定为0b000（OKAY）。</p><p>只有在接口使用可以具有两个写响应的特性时，BCOMP才会出现，这些特性包括：</p><ul><li>持久性的缓存维护，参见 <em><a href="#a10.8 持久性cmos">A10.8 持久性CMOs</a></em> 。</li><li>内存标签，参见 <em><a href="#a13.2 内存标签扩展（mte）">A13.2 内存标签扩展（MTE）</a></em> 。</li></ul><p>如果<strong>BCOMP</strong>存在，则必须在写通道每个事务的响应传输中被断言。</p><p><strong>BRESP</strong>编码见 <em><a href="#表 a4.21">表 A4.21</a></em> 。</p><p><a id="表 a4.21">表 A4.21</a> <strong>BRESP</strong>编码</p><table><thead><tr><th><strong>BRESP</strong></th><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>OKAY</td><td>非独占写入：事务成功。如果事务包含写入数据，则更新的值是可观察的。<br>独占写入：更新位置失败</td></tr><tr><td>0n001</td><td>EXOKAY</td><td>独占写入：事务成功。只允许在独占写中使用。</td></tr><tr><td>0b010</td><td>SLVERR</td><td>存在于请求已到达终点但未成功完成。<br>位置可能未完全更新，通常在从机中存在问题时使用，例如尝试访问只读或已断电的功能。</td></tr><tr><td>0b011</td><td>DECERR</td><td>存在于请求尚未达到可以写入数据的阶段。<br>位置可能尚未完全更新。通常在地址解码为无效地址时使用</td></tr><tr><td>0b100</td><td>DEFER</td><td>写入未成功，因为此时无法提供服务。<br>位置未更新。此响应仅适用于可延迟写入事务（WriteDeferrable）。</td></tr><tr><td>0b101</td><td>TRANSFAULT</td><td>事务因翻译错误而终止，该错误可能通过PRI请求来解决。</td></tr><tr><td>0b110</td><td>RESERVED</td><td>-</td></tr><tr><td>0b111</td><td>UNSUPPORTED</td><td>写入不成功，因为目标不支持该事务类型。位置未更新。此响应仅允许用于可延迟写入的事务（WriteDeferrable）。</td></tr></tbody></table><h5 id=a-ida432-读响应a432-读响应a><a id="a4.3.2 读响应">A4.3.2 读响应</a></h5><p>读取响应指示读取是否成功以及该传输中的数据是否有效。</p><p>读取响应通过读取数据通道上的<strong>RRESP</strong>信号传输，在事务中的每次读取数据传输都有一个读取响应。
响应值不要求在事务中的每次读取数据传输中都相同。</p><p>需要注意的是所有数据传输都应按长度指示始终完成而不考虑响应。
对于某些响应，该传输中的数据不要求有效。</p><p><strong>RRESP</strong>信号的定义如表 <em><a href="#表 a4.22">表 A4.22</a></em> 所示。</p><p><a id="表 a4.22">表 A4.22</a> <strong>RRESP</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>RRESP</strong></td><td>RRESP_WIDTH</td><td>0b00（OKAY）</td><td>读通道的事务响应。<br><strong>RVALID</strong>断言时<strong>RRESP</strong>必须有效。</td></tr></tbody></table><p>RRESP_WIDTH属性在 <em><a href="#表 a4.23">表 A4.23</a></em> 中显示。</p><p><a id="表 a4.23">表 A4.23</a> RRESP_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>RRESP_WIDTH</td><td>0,2,3</td><td>2</td><td><strong>RRESP</strong>的位宽。<br>如果是下列情况，则必须是3：<br>Prefetch_Transaction = True<br>Untranslated_Transactions = v2<br>Untranslated_Transactions =v3<br>Shareable_Cache_Support = True</td></tr></tbody></table><p><strong>RRESP</strong>是一个可选信号。
如果RRESP_WIDTH属性为0，则该信号不存在，并假定为0b000（OKAY）。
RRESP的编码如 <em><a href="#表 a4.24">表 A4.24</a></em> 所示。</p><p>对于数据不要求有效的响应，主机可能仍会采样RDATA值，因此从机不应依赖响应来隐藏敏感数据。</p><p><a id="表 a4.24">表 A4.24</a> <strong>RRESP</strong>编码</p><table><thead><tr><th><strong>RRESP</strong></th><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>OKAY</td><td>非独占读取：事务成功。读取数据有效。<br>独占读取：从机不支持独占访问</td></tr><tr><td>0n001</td><td>EXOKAY</td><td>独占读取：事务成功。只允许在独占读中使用。</td></tr><tr><td>0b010</td><td>SLVERR</td><td>事务遇到了一个包含的错误，仅此位置受影响。<br>通常在从机中出现问题时使用，例如FIFO溢出、不支持的传输大小或尝试访问已断电的功能。<br>读取数据无效</td></tr><tr><td>0b011</td><td>DECERR</td><td>事务已遇到未包含的错误，其他位置可能会受到影响。<br>通常用于地址解码到无效地址。<br>读取数据无效</td></tr><tr><td>0b100</td><td>PREFETCHED</td><td>来自预取的读取值有效。</td></tr><tr><td>0b101</td><td>TRANSFAULT</td><td>事务因翻译错误而终止，该错误可能通过PRI请求来解决。</td></tr><tr><td>0b110</td><td>OKAYDIRTY</td><td>读取数据有效且相对于内存中的值是脏的。<br>仅允许响应ReadShared请求</td></tr><tr><td>0b111</td><td>RESERVED</td><td>-</td></tr></tbody></table><p><strong>RRESP</strong>的值并不限制在每次传输中都相同。
当访问从机出现问题时，通常会使用 DECERR 响应。
且在这种情况下，DECERR 在每次读取数据的传输中都会一致地发出信号。</p><p>如果主机可以检查一次读取数据传输以确定是否发生了， DECERR 可能会有效。</p><p>Consistent_DECERR 属性用于定义从机在一个事务中是否一致地发出 DECERR 信号，如表 A4.25 所示。</p><p><a id="表 a4.25">表 A4.25</a> Consistent_DECERR 属性</p><table><thead><tr><th>Consistent_DECERR</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>DECERR信号在每个读取数据传输或每个缓存行数据中没有读取数据传输时发出。<br>比如，跨越缓存行边界的事务可以在一个缓存行的每个读取数据传输中收到DECERR响应，而在下一个缓存行中没有数据传输。</td></tr><tr><td>False</td><td>Y</td><td>DECERR 可能在任意数量的读数据传输中被触发。</td></tr></tbody></table><p>从机不使用DECERR响应的可以将Consistent_DECERR属性设置为真。</p><p>将Consistent_DECERR设置为真的主机可以检查一次数据传输以确定是否发生了DECERR。</p><p>当在AXI和CHI之间桥接时将此属性设置为真可以有用的，因为DECERR会转换为非数据错误。</p><p>在连接主机和从机时 <em><a href="#表 a4.26">表 A4.26</a></em> 显示了兼容的Consistent_DECERR组合。</p><p><a id="表 a4.26">表 A4.26</a> Consistent_DECERR 互操作性</p><table><thead><tr><th>Consistent_DECERR</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容</td></tr><tr><td>主机：True</td><td>不兼容<br>主机可能会错过DECERR响应。</td><td>兼容</td></tr></tbody></table><h5 id=a-ida433-从机繁忙标识a433-从机繁忙标识a><a id="a4.3.3 从机繁忙标识">A4.3.3 从机繁忙标识</a></h5><p>当提供响应时，从机可以使用繁忙标识来表明其当前的活动水平。
这些信息可以用来控制主机的发出速率或它产生的推测性事务的数量。</p><p>繁忙标识对于有共享资源的组件是有用的，
比如内存控制器或系统缓存。例如，繁忙指示可以表示：</p><ul><li>共享队列的繁忙状态。</li><li>读取或写入请求队列的繁忙状态，取决于事务的方向。</li><li>当组件对资源的使用超过或少于其分配值。</li></ul><p>如 <em><a href="#表 a4.27">表 A4.27</a></em> 所示，Busy_Support属性用于定义接口是否包含繁忙标识信号。</p><p><a id="表 a4.27">表 A4.27</a> Busy_Support属性</p><table><thead><tr><th>BUSY_Support</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>从机繁忙支持</td></tr><tr><td>False</td><td>Y</td><td>从机繁忙不支持</td></tr></tbody></table><p>当 Busy_Support 为 True 时，<em><a href="#表 a28">表 A28</a></em> 以下信号将包含在接口上。</p><p><a id="表 a28">表 A28</a> 繁忙标识信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>BBUSY</strong><br><strong>RBUSY</strong></td><td>2</td><td>0b00</td><td>指示在事务响应中从机操作的当前状态，随着从机变得越来越忙 该值会增加</td></tr></tbody></table><p>对于具有多个读取数据传输的事务，Busy必须有效，但每次传输可以有不同的值。</p><p>对于具有多个写入响应的事务，在<strong>BCOMP</strong>断言的响应中，Busy必须有效。
对于其他写入响应，Busy不适用时可以取任何值。</p><p>对于具有写入和读取响应的原子事务，<strong>BBUSY</strong>和<strong>RBUSY</strong>预计但不要求具有相同的值。</p><p>Busy标识值的具体使用方式是实现定义的，在 <em><a href="#表 a4.29">表 A4.29</a></em> 中有展示了使用它的示例。
在这个示例中，如果从机无法生成动态繁忙标识，则默认值0b01是适当的。</p><p><a id="表 a29">表 A29</a> 繁忙标识的使用例子</p><table><thead><tr><th>繁忙标识</th><th>含义</th><th>主机行为</th></tr></thead><tbody><tr><td>0b00</td><td>不繁忙</td><td>增加请求</td></tr><tr><td>0b01</td><td>稍微忙</td><td>无动作</td></tr><tr><td>0b10</td><td>有点忙</td><td>减少请求</td></tr><tr><td>0b11</td><td>特别忙</td><td>大幅度减少请求</td></tr></tbody></table><p><a id=a4.30>A4.30</a> Busy_Support 互操作性</p><table><thead><tr><th>Busy_Support</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容<br>繁忙输出不连接</td></tr><tr><td>主机：True</td><td>兼容 繁忙输入连接到默认值</td><td>兼容</td></tr></tbody></table><h3 id=a-ida第5章-请求属性a第5章-请求属性a><a id="a第5章 请求属性">A第5章 请求属性</a></h3><p>本章描述了请求属性以及下游组件如何对其进行处理。它包含以下部分：</p><ul><li><em><a href="#a5.1 从机类型">A5.1 从机类型</a></em></li><li><em><a href="#a5.2 内存属性">A5.2 内存属性</a></em></li><li><em><a href="#a5.3 内存类型">A5.3 内存类型</a></em></li><li><em><a href="#a5.4 保护错误">A5.4 保护错误</a></em></li><li><em><a href="#a5.5 内存保护和realm管理扩展">A5.5 内存保护和realm管理扩展</a></em></li><li><em><a href="#a5.6 内存加密上下文">A5.6 内存加密上下文</a></em></li><li><em><a href="#a5.7 多区域接口">A5.7 多区域接口</a></em></li><li><em><a href="#a5.8 qos信令">A5.8 Qos信令</a></em></li></ul><h4 id=a-ida51-从机类型a51-从机类型a><a id="a5.1 从机类型">A5.1 从机类型</a></h4><p>从机被分类为内存从机或外设从机：</p><ul><li><p>内存从机：
内存从机需要正确处理所有事务类型。</p></li><li><p>外设从机：
外设从机有一个 IMPLEMENTATION DEFINED 的访问方法。
通常访问方法在组件数据表中定义，该表描述了从机正确处理的事务类型。</p></li></ul><p>任何不是 IMPLEMENTATION DEFINED 访问方法一部分的外设从机，其访问必须完成，并遵循协议。
然而，当这样的访问已被进行时，不要求外设从机继续正常操作。
只要求从机在协议合规的方式下继续完成进一步的事务。</p><h4 id=a-ida52-内存类型a52-内存类型a><a id="a5.2 内存类型">A5.2 内存类型</a></h4><p>本节描述了决定系统组件如缓存、缓冲区和内存控制器应如何处理请求的属性。
<strong>AWCACHE</strong>和<strong>ARCACHE</strong>信号指定了请求的内存属性。
它们控制：</p><ul><li>事务如何在系统中进行。</li><li>任意系统级缓冲区和缓存如何处理事务。</li></ul><p>在本规范中，术语<strong>AxCACHE</strong>统称为<strong>AWCACHE</strong>和<strong>ARCACHE</strong>信号。
<em><a href="#表 a5.1">表 A5.1</a></em> 描述了<strong>AWCACHE</strong>和<strong>ARCACHE</strong>信号。</p><p><a id="表 a5.1">表 A5.1</a> <strong>AxCACHE</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWCACHE</strong><br><strong>ARCACHE</strong></td><td>4</td><td>0x0</td><td>请求的内存属性控制事务在系统中的进展以及缓存和缓冲区如何处理该请求</td></tr></tbody></table><p>属性CACHE_Present用于确定接口上是否存在<strong>AxCACHE</strong>信号。</p><p><a id="表 a5.2">表 A5.2</a> CACHE_Present属性</p><table><thead><tr><th>CACHE_Present</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWCACHE</strong>和<strong>ARCACHE</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWCACHE</strong>和<strong>ARCACHE</strong>不存在</td></tr></tbody></table><p>AWCACHE位被编码为：</p><ul><li>[0] 可缓冲</li><li>[1] 可修改</li><li>[2] 其他分配</li><li>[3] 分配</li></ul><p>ARCACHE位被编码为：</p><ul><li>[0] 可缓冲</li><li>[1] 可修改</li><li>[2] 分配</li><li>[3] 其他分配</li></ul><p>请注意，分配和其他分配位在读请求和写请求中的位置不同。</p><h5 id=a-ida521-可缓冲-strongaxcache0stronga521-可缓冲strong-axcache0stronga><a id="a5.2.1 可缓冲-<strong>AxCACHE[0]</strong>">A5.2.1 可缓冲<strong>-AxCACHE[0]</strong></a></h5><p>对于写入事务：</p><ul><li>如果可缓冲位被解除断言，则写入响应表示数据已到达最终目的地。</li><li>如果可缓冲位被断言，则写入响应可以在满足可观察性要求时从中间点发送。</li></ul><p>对于 ARCACHE[3:2] 被解除断言（不可缓存）且 ARCACHE[1] 被断言（可修改）的读取事务：</p><ul><li>如果可缓冲位被解除断言，则读取的数据必须从最终目的地获取。</li><li>如果可缓冲位被断言，则读取的数据可以从最终目的地或从正在传输到最终目的地的写入中获取。</li></ul><p>对于 ARCACHE[3:1] 的其他组合，可缓冲位无效。</p><h5 id=a-ida522-可修改-strongaxcache1stronga522-可修改-strongaxcache1stronga><a id="a5.2.2 可修改-<strong>AxCACHE[1]</strong>">A5.2.2 可修改-<strong>AxCACHE[1]</strong></a></h5><p>事务可以被修改。当AxCACHE[1]解除断言时，事务是不可修改的。
以下部分描述了不可修改和可修改事务的属性。</p><p><strong>不可修改事务</strong></p><p>不可将其拆分为多个事务或与其他事务合并。
在不可修改事务中，<em><a href="#表 a5.3">表 A5.3</a></em> 中显示的参数不得更改。</p><p><a id="表 a5.3">表 A5.3</a> 不可修改的参数</p><table><thead><tr><th>参数</th><th>信号</th></tr></thead><tbody><tr><td>地址</td><td><strong>AxADDR</strong><br><strong>AxREGION</strong></td></tr><tr><td>大小</td><td><strong>AxSIZE</strong></td></tr><tr><td>长度</td><td><strong>AxLEN</strong></td></tr><tr><td>突发类型</td><td><strong>AxBURST</strong></td></tr><tr><td>保护属性</td><td><strong>AxPROT</strong><br>AxNSE</strong></td></tr></tbody></table><p><strong>AxCACHE</strong>属性只能修改以将事务从可缓冲转换为不可缓冲。对AxCACHE的其他更改是不允许的。</p><p>事务ID和QoS值可以被修改。</p><p>长度大于16的不可修改事务可以分割成多个事务。
每个生成的事务必须满足本小节中给出的要求，但不可避免的带来一些改变，</p><ul><li>长度减少。</li><li>地址要做相应的调整。</li></ul><p><strong>AxLOCK</strong>断言指定的独占访问不可修改事务，可以修改大小<strong>AxSIZE</strong>和长度<strong>AxLEN</strong>，
前提是总访问的字节数保持不变。</p><p>存在一些情况，无法满足不可修改事务的要求。
例如，当缩小到宽度小于大小要求的数据时，事务必须被修改。</p><p>执行该操作的组件可以选择性地包括 IMPLEMENTATION DEFINED 的机制，以指示已发生修改。
这种机制可以帮助软件调试。</p><p><strong>可修改事务</strong></p><p>可修改事务可以通过以下方式进行修改：</p><ul><li>事务可以被分解为多个事务。</li><li>多个事务可以合并为一个事务。</li><li>读取事务可以获取比所需更多的数据。</li><li>写入事务可以访问比所需更大的地址范围，使用<strong>WSTRB</strong>信号确保只有适当的位置被更新。</li><li>在每个生成的事务中，可以修改以下属性：<ul><li>地址，<strong>AxADDR</strong></li><li>大小，<strong>AxSIZE</strong></li><li>长度，<strong>AxLEN</strong></li><li>突发类型，</strong>AxBURST</strong></li></ul></li></ul><p>以下内容不得更改：</p><ul><li>独占访问指示符，<strong>AxLOCK</strong></li><li>保护和安全属性，<strong>AxPROT</strong>和<strong>AxNSE</strong>。</li></ul><p><strong>AxCACHE</strong>可以修改，但任何修改必须确保不减少其他组件对事务的可见性，
既不能阻止事务传播到所需位置，也不能更改在缓存中查找事务的需求。
对内存属性的所有修改必须对同一地址范围内的所有事务保持一致。</p><p>事务ID和QoS值可以被修改。<br>不允许的事务修改包括：</p><ul><li>导致访问与原始事务不同的4KB地址空间。</li><li>导致对单一拷贝原子性大小区域的单个访问被执行为多个访问。见 <em><a href="#a7.1 单副本原子大小">A7.1 单副本原子大小</a></em></li></ul><h5 id=a-ida523-分配和其他分配-strongaxcache32stronga523-分配和其他分配-strongaxcache32stronga><a id="a5.2.3 分配和其他分配-<strong>AxCACHE[3:2]</strong>">A5.2.3 分配和其他分配-<strong>AxCACHE[3:2]</strong></a></h5><p>如果分配位被断言：</p><ul><li>数据可能先前已被分配，因此必须在缓存中查找该行。</li><li>建议将数据分配到缓存中以供将来使用。</li></ul><p>如果其他分配位被断言：</p><ul><li>数据可能先前已被分配，因此必须在缓存中查找该行。</li><li>不建议对数据进行分配，因为预计不会再次访问。</li></ul><p>如果分配和其他分配都未断言，则请求不需要在任何缓存中查找。</p><h5 id=a-ida53-内存类型a53-内存类型a><a id="a5.3 内存类型">A5.3 内存类型</a></h5><p><strong>AxCACHE</strong>信号的组合指示了一种内存类型。
<em><a href=#a5.4>A5.4</a></em> 显示了内存类型编码。
括号中的值是允许的但不是首选的，表中未显示的值是保留的。</p><p><a id="表 a5.4">表 A5.4</a> 内存类型编码</p><table><thead><tr><th><strong>ARCACHE[3:0]</strong></th><th><strong>AWCACHE[3:0]</strong></th><th>Memory type</th></tr></thead><tbody><tr><td>0b0000</td><td>0b0000</td><td><em><a href=#a设备非缓冲>A设备非缓冲</a></em><br>Device Non-bufferable</td></tr><tr><td>0b0001</td><td>0b0001</td><td><em><a href=#a设备可缓冲>A设备可缓冲</a></em><br>Device Bufferable</td></tr><tr><td>0b0010</td><td>0b0010</td><td><em><a href=#a正常非缓存非缓冲>A正常非缓存非缓冲</a></em><br>Normal Non-cacheable Non-bufferable</td></tr><tr><td>0b0011</td><td>0b0011</td><td><em><a href=#a正常非缓存可缓冲>A正常非缓存可缓冲</a></em><br>Normal Non-cacheable Bufferable</td></tr><tr><td>0b1010</td><td>0b0110</td><td><em><a href=#a写直通不分配>A写直通不分配</a></em><br>Write-Through No-Allocate</td></tr><tr><td>0b1110(0b0110)</td><td>0b0110</td><td><em><a href=#a写直通读分配>A写直通读分配</a></em><br>Write-Through Read-Allocate</td></tr><tr><td>0b1010</td><td>0b1110(0b1010)</td><td><em><a href=#a写直通写分配>A写直通写分配</a></em><br>Write-Through Write-Allocate</td></tr><tr><td>0b1110</td><td>0b1110</td><td><em><a href=#a写直通读写分配>A写直通读写分配</a></em><br>Write-Through Read and Write-Allocate</td></tr><tr><td>0b1011</td><td>0b0111</td><td><em><a href=#a写回不分配>A写回不分配</a></em><br>Write-Back No-Allocate</td></tr><tr><td>0b1111(0b0111)</td><td>0b0111</td><td><em><a href=#a写回读分配>A写回读分配</a></em><br>Write-Back Read-Allocate</td></tr><tr><td>0b1011</td><td>0b1111(0b1011)</td><td><em><a href=#a写回写分配>A写回写分配</a></em><br>Write-Back Write-Allocate</td></tr><tr><td>0b1111</td><td>0b1111</td><td><em><a href=#a写回读写分配>A写回读写分配</a></em><br>Write-Back Read and Write-Allocate</td></tr></tbody></table><h5 id=a-ida531-内存类型需求a531-内存类型需求a><a id="a5.3.1 内存类型需求">A5.3.1 内存类型需求</a></h5><p>本节规定了各类内存的必要行为。</p><p><strong><a id=a设备非缓冲>A设备非缓冲</a></strong></br>设备非缓冲内存的必要行为是：</p><ul><li>写操作的响应必须从最终目的地获得。</li><li>读取的数据必须从最终目的地获得。</li><li>事务是不可修改的，请参见 <em><a href="#a5.2.2 可修改-<strong>AxCACHE[1]</strong>">a5.2.2 可修改-<strong>AxCACHE[1]</strong></a></em> 。</li><li>读取的数据不得预取。</li><li>写事务不得合并。</li></ul><p><strong><a id=a设备可缓冲>A设备可缓冲</a></strong></br>设备缓冲内存类型的必要行为是：</p><ul><li>写操作的响应可以从中间点获得。</li><li>写事务必须在最终目的地及时可见。</li><li>读取的数据必须从最终目的地获得。</li><li>事务是不可修改的，请参见。</li><li>读取的数据不得预取。</li><li>写事务不得合并。</li></ul><p>这两种设备内存类型都是不可修改的。在本规范中，设备内存和不可修改内存这两个术语是可以互换的。</p><p>对于读取事务，设备非缓冲和设备缓冲内存类型的必要行为没有区别。</p><p><strong><a id=a正常非缓存非缓冲>A正常非缓存非缓冲</a></strong></br>正常非缓存非缓冲内存类型的必要行为是：</p><ul><li>写操作的响应必须从最终目的地获得。</li><li>读取的数据必须从最终目的地获得。</li><li>事务是可修改的，请参见 <em><a href="#a5.2.2 可修改-<strong>AxCACHE[1]</strong>">a5.2.2 可修改-<strong>AxCACHE[1]</strong></a></em> 。</li><li>写事务可以合并。</li></ul><p><strong><a id=a正常非缓存可缓冲>A正常非缓存可缓冲</a></strong></br>正常非缓存缓冲内存类型的必要行为是：</p><ul><li>写操作的响应可以从中间点获得。</li><li>写事务必须在最终目的地及时可见，具体定义见 <em><a href="#c1 术语表">c1 术语表</a></em> 。
没有机制可以确定写事务何时在最终目的地可见。</li><li>读取的数据必须从以下任一来源获得：<ul><li>最终目的地。</li><li>正在进行的写事务，目标是最终目的地。</li></ul></li><li>如果从写事务获得读取数据：<ul><li>必须从写的最新版本获得。</li><li>数据不得被缓存，用于服务于后续的读取。</li></ul></li><li>事务是可修改的，请参见 <em><a href="#a5.2.2 可修改-<strong>AxCACHE[1]</strong>">a5.2.2 可修改-<strong>AxCACHE[1]</strong></a></em> 。</li><li>写事务可以合并。</li></ul><p>对于正常非缓存可缓冲读取，数据可以从仍在进行中的写事务中获得，目标是最终目的地。
这些数据与同时传播到最终目的地的读取和写入事务无法区分。
以这种方式返回的读取数据并不表示写事务在最终目的地可见。</p><p><strong><a id=a写直通不分配>A写直通不分配</a></strong></br>写直通不分配内存类型的必要行为是：</p><ul><li>写操作的响应可以从中间点获得。</li><li>写事务必须在最终目的地及时可见，具体定义见 <em><a href="#c1 术语表">C1 术语表</a></em> 。
没有机制可以确定写事务何时在最终目的地可见。</li><li>读取数据可以从中间缓存副本获得。</li><li>事务是可修改的，请参见 <em><a href="#a5.2.2 可修改-<strong>AxCACHE[1]</strong>">a5.2.2 可修改-<strong>AxCACHE[1]</strong></a></em> 。</li><li>读取数据可以预取。</li></ul><p><strong><a id=a写直通读分配>A写直通读分配</a></strong></br>写透读取分配内存类型的必要行为与写透不分配内存相同。出于性能原因：</p><ul><li>建议分配读取事务。</li><li>不建议分配写事务。</li></ul><p><strong><a id=a写直通写分配>A写直通写分配</a></strong></br>透写分配内存类型的必要行为与写透不分配内存相同。出于性能原因：</p><ul><li>不建议分配读取事务。</li><li>建议分配写事务。</li></ul><p><strong><a id=a写回读写分配>A写回读写分配</a></strong></br>写直通读写分配内存类型的必要行为与写直通不分配内存相同。出于性能原因：</p><ul><li>建议分配读取事务。</li><li>建议分配写事务。</li></ul><p><strong><a id=a写回不分配>A写回不分配</a></strong></br>写回不分配内存类型的必要行为是：</p><ul><li>写操作的响应可以从中间点获得。</li><li>写事务不要求在最终目的地可见。</li><li>读取数据可以从中间缓存副本获得。</li><li>事务是可修改的，请参见 <em><a href="#a5.2.2 可修改-<strong>AxCACHE[1]</strong>">a5.2.2 可修改-<strong>AxCACHE[1]</strong></a></em> 。</li><li>读取数据可以预取。</li><li>写事务可以合并。</li><li>读取和写入事务需要进行缓存查找。</li><li>不分配属性是一个分配提示，即它是向内存系统推荐的，出于性能原因，这些事务不会被分配。然而，读取和写入事务的分配并不被禁止。</li></ul><p><strong><a id=a写回读分配>A写回读分配</a></strong></br>写回读取分配内存类型的必要行为与写回不分配内存相同。出于性能原因：</p><ul><li>建议分配读取事务。</li><li>不建议分配写事务。</li></ul><p><strong><a id=a写回写分配>A写回写分配</a></strong></br>写回写分配内存类型的必要行为与写回不分配内存相同。出于性能原因：</p><ul><li>不建议分配读取事务。</li><li>建议分配写事务。</li></ul><p><strong><a id=a写回读写分配>A写回读写分配</a></strong></br>写回读写分配内存类型的必要行为与写回不分配内存相同。出于性能原因：</p><ul><li>建议分配读取事务。</li><li>建议分配写事务。</li></ul><h5 id=a-ida532-内存属性不匹配a532-内存属性不匹配a><a id="a5.3.2 内存属性不匹配">A5.3.2 内存属性不匹配</a></h5><p>多个访问同一内存区域的主机可以使用不匹配的内存属性。
但是，为了功能正确性，必须遵循以下规则：</p><ul><li>访问同一区域内存的所有主机在任何层次结构中必须对该区域内存的缓存性有一致的视图。适用的规则是：<ul><li>如果地址区域是不可缓存的，则所有主机必须使用<strong>AxCACHE[3:2]</strong>都未断言的事务。</li><li>如果地址区域是可缓存的，则所有主机必须使用<strong>AxCACHE[3:2]</strong>的任何一个断言的事务。</li></ul></li><li>不同的主机可以使用不同的分配提示。</li><li>如果一个地址区域是正常的不可缓存，任何主机都可以使用设备内存事务访问它。</li><li>如果一个地址区域具有可缓冲属性，任何主机都可以使用不允许缓冲行为的事务访问它。例如，要求从最终目的地响应的事务不允许缓冲行为。</li></ul><h5 id=a-ida533-改变内存属性a533-改变内存属性a><a id="a5.3.3 改变内存属性">A5.3.3 改变内存属性</a></h5><p>特定内存区域的属性可以从一种类型更改为另一种不兼容的类型。
例如，可以将属性从写直通缓存可用更改为普通不可缓存。
这一变化需要适当的过程来执行更改。</p><p>通常，执行以下过程：</p><ol><li>所有主机停止访问该区域。</li><li>一个主机执行任何必要的缓存维护操作。</li><li>所有主机重新开始访问内存区域，使用新的属性。</li></ol><h5 id=a-ida534-事务缓冲a534-事务缓冲a><a id="a5.3.4 事务缓冲">A5.3.4 事务缓冲</a></h5><p>写入对以下内存类型的访问不需要最终目的地的事务响应，但确实需要确保写入事务及时在最终目的地可见：</p><ul><li>设备可缓冲。</li><li>普通非缓存可缓冲。</li><li>写直通。</li></ul><p>对于写入事务，这三种内存类型要求相同的行为。</p><p>对于读取事务，所需行为如下：</p><ul><li>对于设备可缓冲内存，读取的数据必须从最终目的地获得。</li><li>对于普通非缓存可缓冲内存，读取的数据必须从最终目的地获得，或者从正在前往其最终目的地的写入事务中获得。</li><li>对于写直通内存，读取的数据可以从中间缓存副本中获得。</li></ul><p>除了确保写入事务及时向其最终目的地产生进展之外，中间缓冲区必须表现如下：</p><ul><li>一个可以响应事务的中间缓冲区必须确保随着时间的推移，任何对普通非缓存可缓冲内存的读取事务都向其目的地传播。
这种传播意味着在转发读取事务时，尝试的转发不能无限期继续，且用于转发的数据不能无限期存在。
协议未定义任何确定用于转发读取事务的数据能够存在多久的机制。但是，在这样的机制中，读取数据的行为不能重置数据超时期限。</br>如果没有这一要求，持续对同一位置的轮询可能会阻止保存在缓冲区中的读取的超时，从而阻止读取向其目的地的进展。</li><li>一个可以持有和合并写入事务的中间缓冲区必须确保事务不会无限期保留在其缓冲区中。
例如，合并写入事务不得重置确定写入何时向其最终目的地排出的机制。</br>如果没有这一要求，持续向同一位置写入可能会阻止保存在缓冲区中的写入的超时，从而阻止写入向其目的地的进展。</li></ul><p>有关对这些内存类型的读取访问所需行为的信息，请参见：</p><ul><li><em><a href=#a设备可缓冲>A设备可缓冲</a></em></li><li><em><a href=#a正常非缓存可缓冲>A正常非缓存可缓冲</a></em></li><li><em><a href=#a写直通不分配>A写直通不分配</a></em></li></ul><h5 id=a-ida535-设备内存实例a535-设备内存实例a><a id="a5.3.5 设备内存实例">A5.3.5 设备内存实例</a></h5><p>该规范支持设备非缓冲和设备缓冲内存类型的组合使用，以强制写入事务到达其最终目的地，并确保发起的主机知道事务何时对所有其他主机可见。</p><p>标记为设备缓冲的写入事务必须及时地到达其最终目的地。
然而，该事务的写入响应可以由一个中间缓冲区发出信号。
因此，发起的主机无法知道写入何时对所有其他主机可见。</p><p>如果主机发起了一个设备缓冲写入事务，或一系列写入事务，随后是一个设备非缓冲写入事务，并且所有事务使用相同的AXI ID，
则AXI排序要求强制所有设备缓冲写入事务在设备非缓冲事务给予响应之前到达最终目的地。
因此，设备非缓冲事务的响应表明所有事务对所有主机可见。</p><h4 id=a-ida54-协议错误a54-协议错误a><a id="a5.4 协议错误">A5.4 协议错误</a></h4><p>AXI协议定义了两类协议错误，软件协议错误和硬件协议错误。</p><h5 id=a-ida541-软件协议错误a541-软件协议错误a><a id="a5.4.1 软件协议错误">A5.4.1 软件协议错误</a></h5><p>软件协议错误发生在多个访问同一位置时，访问的共享性或缓存属性不匹配。
软件协议错误可能导致一致性丧失，并导致数据值损坏。
该协议要求系统在出现软件协议错误时不发生死锁，并且事务始终在系统中进行推进。</p><p>对一个4KB内存区域的访问导致的软件协议错误不得在另一个4KB内存区域造成数据损坏。
对于保存在正常内存中的位置，可以使用适当的软件屏障和缓存维护将内存位置恢复到定义状态。</p><p>在访问外设时，如果使用可修改事务（<strong>AxCACHE[1]被断言</strong>），则无法保证外设的正常操作。
唯一的要求是外设继续以遵循协议的方式响应事务。
将一个错误访问的外设恢复到已知工作状态所需的事件序列是实现定义的。</p><h5 id=a-ida542-硬件协议错误a542-硬件协议错误a><a id="a5.4.2 硬件协议错误">A5.4.2 硬件协议错误</a></h5><p>硬件协议错误被定义为任何不是软件协议错误的协议错误。
硬件协议错误不需要支持。</p><p>如果发生硬件协议错误，则无法保证从错误中恢复。系统可能会崩溃、锁死或遭遇其他不可恢复的故障。</p><h4 id=a-ida55-内存保护和realm管理扩展a55-内存保护和realm管理扩展a><a id="a5.5 内存保护和realm管理扩展">A5.5 内存保护和realm管理扩展</a></h4><p>AXI提供可以用来保护内存免受意外事务的信号。</p><p>通过Realm管理扩展（RME），内存保护也可以被扩展。
它提供基于硬件的隔离，允许执行上下文在不同的安全状态下运行并共享系统中的资源。</p><p>当使用RME时，它扩展了物理寻址和未翻译事务的地址空间，影响缓存维护操作的运行并扩展了MPAM信号。
保护信号如 <em><a href="#表 a5.5">表 A5.5</a></em> 所示</p><p><a id="表 a5.5">表 A5.5</a> 保护信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWPROT</strong><br><strong>ARPROT</strong></td><td>3</td><td>−</td><td>请求的访问属性可用于保护内存免受意外事务。</td></tr><tr><td><strong>AWNSE</strong><br><strong>AWNSE</strong></td><td>1</td><td>0b0</td><td>扩展的物理地址空间包含Root和Realm两种。</td></tr></tbody></table><p>属性PROT_Present用于确定接口上是否存在<strong>AxPROT</strong>信号。
一个不使用保护属性的从机可以从其接口中省略<strong>AxPROT</strong>输入。</p><p><a id="表 a5.6">表 A5.6</a> PROT_Present属性</p><table><thead><tr><th>PROT_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWPROT</strong>和<strong>ARPROT</strong> 都存在</td></tr><tr><td>False</td><td></td><td><strong>AWPROT</strong>和<strong>ARPROT</strong> 都不存在</td></tr></tbody></table><p>当使用RME时，RME_Support属性被设置为True，并且<strong>AxNSE</strong>信号出现在一个接口上。</p><p><a id="表 a5.7">表 A5.7</a> RME_Support属性</p><table><thead><tr><th>RME_Support</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>RME支持。<br>所有RME信号都出现在接口上。</td></tr><tr><td>False</td><td>Y</td><td>RME不支持。<br>所有RME讯号都不出现在接口上。</td></tr></tbody></table><p>保护属性分为三个部分：</p><p><strong>非特权与特权</strong></p><p>AXI主机可能支持多于一个级别的操作特权，并且可以选择性地将这一特权概念扩展到内存访问。<br><strong>AxPROT[0]</strong>将访问标识为非特权或特权：</p><ul><li>0b0：非特权</li><li>0b1：特权</li></ul><p>某些主机支持多个特权级别，请参阅所选处理器的文档以确定与AXI特权级别的映射。
AXI提供的唯一区分是特权和非特权访问之间的区分。</p><p><strong>非安全与安全</strong></p><p>如果AXI主机支持不同的安全操作状态，它可以将其扩展到内存访问中，使用安全属性。
具有不同安全属性的请求可以被视为占用不同的地址空间，因此同一地址可以根据安全属性解码到不同的位置。</p><p><strong>AxPROT[1]</strong>和<strong>AxNSE</strong>信号用于定义安全属性，如 <em><a href="#表 a5.8">表 A5.8</a></em> 所示。</p><p><a id="表 a5.8">表 A5.8</a> 安全属性</p><table><thead><tr><th><strong>AxNSE</strong></th><th><strong>AxPROT[1]</strong></th><th>安全属性</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Secure</td></tr><tr><td>0</td><td>1</td><td>Non-secure</td></tr><tr><td>1</td><td>0</td><td>Root</td></tr><tr><td>1</td><td>1</td><td>Realm</td></tr></tbody></table><p><strong>数据与指令</strong></p><p><strong>AxPROT[2]</strong>表示事务是指令访问或数据访问：</p><ul><li>0b0: 数据访问</li><li>0b1: 指令访问</li></ul><p>AXI协议将此指示定义为提示。在所有情况下它并不一定准确。
例如，当一个事务包含指令和数据项的混合时。建议在访问被确定为指令访问之前，主机将AxPROT[2]设置为LOW以指示数据访问。</p><h4 id=a-ida56-内存加密上下文a56-内存加密上下文a><a id="a5.6 内存加密上下文">A5.6 内存加密上下文</a></h4><p>内存加密上下文（MEC）是对Arm域管理扩展（RME）的扩展，允许每个域拥有其独特的加密上下文。</p><p>MEC扩展将内存加密上下文分配给域物理地址空间内的所有内存访问。
所有内存事务都与一个MECID相关，该ID由安全状态、翻译方案、翻译表和MEC系统寄存器决定。
MECID被内存加密引擎用作加密上下文表（无论是密钥还是变更）的索引，这些上下文有助于外部内存加密。</p><p>使用MEC可以通过使每组域数据采用不同的加密方式来帮助保护内存中的域数据。
这意味着，能够访问物理内存设备并能够解密一组域数据的恶意主机，无法使用相同的解密方法来访问其他组域数据。
在加密点（PoE）之前，在组件之间移动的数据是明文形式。</p><p>R-EL2上的域管理软件控制MECID的策略和分配给域的信息。</p><p>有关MEC的更多信息，请参见 <em><a href=#[3]>[3]</a></em> 和 <em><a href=#[4]>[4]</a></em> 。</p><p>请注意，MEC架构规范 <em><a href=#[3]>[3]</a></em> 详细说明了MECID值不匹配时的几种实现选项。
此MEC实现假设主机和缓存不执行任何MECID检查。</p><p>例如，如果与一个MECID相关的读取访问目标位置在缓存中有一个副本并且与不同的MECID相关，那么读取访问就会成功，好像MECID值没有不匹配一样。
这里不需要额外的保护，因为R-EL2上的域管理软件确保一个上下文无法访问属于不同上下文的位置，从而确保不会发生明文泄漏。</p><h5 id=a-ida561-mec信号a561-mec信号a><a id="a5.6.1 mec信号">A5.6.1 mec信号</a></h5><p>MEC_Support属性确定接口是否支持内存加密上下文MEC。</p><p><a id="表 a5.9">表 A5.9</a> MEC_Support属性</p><table><thead><tr><th>MEC_Support</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>MEC支持。<br><strong>AxMECID</strong>信号存在。</td></tr><tr><td>False</td><td>Y</td><td>MEC不支持。<br><strong>AxMECID</strong>信号不存在。</td></tr></tbody></table><p>MEC是RME的扩展，因此如果RME_Support属性为False，则MEC_Support必须为False。<br><em><a href="#表 a5.10">表 A5.10</a></em> 中信号是支持MEC所必需的。</p><p><a id="表 a5.10">表 A5.10</a> MECID信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWMECID</strong><br><strong>ARMECID</strong></td><td>MECID_WIDTH</td><td>全0</td><td>RME内存加密上下文ID</td></tr></tbody></table><p>参数MECID_WIDTH定义了宽度。</p><p><a id="表 a4.11">表 A4.11</a> MECID_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>MECID_WIDTH</td><td>0&mldr;16</td><td>0</td><td><strong>AxMECID</strong>的位宽。</td></tr></tbody></table><p>以下规则适用于MECID_WIDTH属性：</p><ul><li>如果MECID_WIDTH为0，则<strong>AWMECID</strong>和<strong>ARMECID</strong>不在接口上。</li><li>如果MEC_Support为False，则<strong>MECID_WIDTH</strong>必须为0。</li><li>如果MEC_Support为True，则<strong>MECID_WIDTH</strong>必须不为0。</li></ul><blockquote><p>Note：</br>注意MECID的宽度并不表示组件使用了多少不同的值。通过使用更窄的内部宽度，可能可以减少MECID的存储需求。</p></blockquote><p>如果两个组件之间的MECID位宽不同，可以进行零扩展或截去高位，具体取决于情况。
此调整仅在将公共MECID宽度设置为系统中任何MEC兼容组件支持的最小MECID宽度时，才能产生正确的MEC操作。</p><p>根据MEC_Support属性的值，主机和从机之间的兼容性如 <em><a href="#表 a5.12">表 A5.12</a></em> 所示。</p><p><a id="表 a5.12">表 A5.12</a> MEC_Support兼容性</p><table><thead><tr><th>MEC_Support</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容。<br><strong>AxMECID</strong>输入连接为LOW</td></tr><tr><td>从机：True</td><td>兼容。<br>下游内存使用MEC未加密。</td><td>兼容</td></tr></tbody></table><h5 id=a-ida562-mecid使用a562-mecid使用a><a id="a5.6.2 mecid使用">A5.6.2 MECID使用</a></h5><p>MECID值范围是有界的，依赖于被访问的物理地址空间。</p><p><a id="表 a5.13">表 A5.13</a> 在每个物理地址空间可能的MECID</p><table><thead><tr><th><strong>AxNSE</strong></th><th><strong>AxPROT[1]</strong></th><th>物理地址空间</th><th>MECID</th></tr></thead><tbody><tr><td>0b0</td><td>0b0</td><td>Secure</td><td>必须为0</td></tr><tr><td>0b0</td><td>0b1</td><td>Non-secure</td><td>必须为0</td></tr><tr><td>0b1</td><td>0b0</td><td>Root</td><td>必须为0</td></tr><tr><td>0b1</td><td>0b1</td><td>Realm</td><td>任何值</td></tr></tbody></table><p>MECID 不适用，并且对于以下请求操作码可以取任何值：</p><ul><li>CMO</li><li>CleanInvalid</li><li>MakeInvalid</li><li>CleanShared</li><li>CleanSharedPersist</li><li>InvalidateHint</li><li>StashTranslation</li><li>UnstashTranslation</li></ul><p>MECID 不适用，且对于以下请求操作码必须为 0：</p><ul><li>DVM Complete</li></ul><p>传播事务并在其从机和主机上支持 MECID 的组件必须在适用请求中保留 MECID。
执行地址转换的组件可能会更改 MECID。</p><p>存储与 MECID 关联数据的高速缓存必须也存储 MECID，并在写回时与数据一同提供。</p><p>可以使用 CleanInvalidPoPA 操作来确保从加密点上游的所有缓存中清理并使缓存行失效。
有关 CleanInvalidPoPA 的更多信息，请参见 <em>&lt;a href="#a10.9 缓存维护和rme>A10.9 缓存维护和RME</a></em> 。</p><h4 id=a-ida57-多区域接口a57-多区域接口a><a id="a5.7 多区域接口">A5.7 多区域接口</a></h4><p>本节描述了在请求中使用区域ID的方式，以支持单个接口中具有多个地址区域的接口。</p><h5 id=a-ida571-区域id信令a571-区域id信令a><a id="a5.7.1 区域id信令">A5.7.1 区域ID信令</a></h5><p>属性 REGION_Present 决定接口是否支持区域ID信令。</p><p><a id="表 a5.14">表 A5.14</a> REGION_Present属性</p><table><thead><tr><th>REGION_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWREGION</strong>和<strong>ARREGION</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWREGION</strong>和<strong>AWREGION</strong>不存在</td></tr></tbody></table><p>指示区域的信号如 <em><a href="#表 a5.15">表 A5.15</a></em> 所示。</p><p><a id="表 a5.15">表 A5.15</a> Region信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWREGION</strong><br><strong>ARREGION</strong></td><td>4</td><td>0x0</td><td>一个可以用于识别不同地址区域的4位区域ID</td></tr></tbody></table><h5 id=a-ida572-区域id的使用a572-区域id的使用a><a id="a5.7.2 区域ID的使用">A5.7.2 区域ID的使用</a></h5><p>4位区域ID可用于唯一标识最多16个不同的区域。
区域标识符可以提供更高位地址位的解码。
区域标识符在任何4K字节的地址空间内必须保持不变。</p><p>使用区域标识符意味着从机上的单个物理接口可以提供多个逻辑接口，每个接口在系统地址映射中具有不同的位置。
使用区域标识符意味着从机不必支持不同逻辑接口之间的地址解码。</p><p>本规范期望互连在对具有多个逻辑接口的单个从机执行地址解码功能时产生<strong>AxREGION</strong>信号。
如果从机在系统地址映射中只有一个物理接口，则互连必须使用默认的<strong>AxREGION</strong>值。</p><p>区域ID有几种使用模型，包括但不限于以下内容：</p><ul><li>外设可以在地址映射中的不同位置具有其主要数据路径和控制寄存器，并通过单个接口访问，无需从机执行地址解码。</li><li>从机可以在不同的内存区域表现出不同的行为。例如，从机可能在一个区域提供读写访问，但在另一个区域只提供只读访问。</li></ul><p>从机必须确保正确的协议信号和事务的正确顺序得到维护。
从机必须确保对两个请求不同区域的相同事务ID的响应按正确顺序提供。</p><p>从机还必须确保<strong>AxREGION</strong>任何值的正确协议信号。
如果从机实现的区域少于十六个，则从机必须确保对任何对不支持区域的访问提供正确的协议信号。</p><p>如何实现这一点是实现定义的。例如，从机可能通过以下方式确保此点：</p><ul><li>对于任何访问不支持区域的事务提供错误响应。</li><li>在所有不支持区域之间对受支持区域进行别名，以确保对所有访问给出合规的协议响应。</li></ul><p><strong>AxREGION</strong>信号仅提供现有地址空间的地址解码，可以被从机用来消除地址解码功能的需要。信号不创建新的独立地址空间。</p><p><strong>AxREGION</strong>必须仅出现在地址解码功能下游的接口上。</p><h4 id=a-ida58-qos信令a58-qos信令a><a id="a5.8 qos信令">A5.8 Qos信令</a></h4><p>AXI支持服务质量（Quality of Service）QoS方案通过以下特性：</p><ul><li><em><a href="#a5.8.1 qos 标识">A5.8.1 QoS 标识</a></em></li><li><em><a href="#a5.8.2 qos 接受标识">A5.8.2 QoS 接受标识</a></em></li></ul><h5 id=a-ida581-qos-标识a581-qos-标识a><a id="a5.8.1 qos 标识">A5.8.1 QoS 标识</a></h5><p>AXI请求有一个可选的标识符，可以用来区分不同的流量流，如 <em><a href="#表 a5.16">表 A5.16</a></em> 所示。</p><p><a id="表 a5.16">表 A5.16</a> QoS信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWQOS</strong><br><strong>ARQOS</strong></td><td>4</td><td>0x0</td><td>QoS用于区分不同的流量流</td></tr></tbody></table><p>QOS_Present属性用于定义接口是否包含<strong>AxQOS</strong>信号。</p><p><a id="表 a5.17">表 A5.17</a> QOS_Support属性</p><table><thead><tr><th>QOS_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWQOS</strong>和<strong>ARQOS</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWQOS</strong>和<strong>ARQOS</strong>不存在</td></tr></tbody></table><p>该协议未指定QoS标识的具体使用方式。
建议将<strong>AxQOS</strong>用作关联写或读请求的优先级指示符，其中较高的值表示更高优先级的请求。</p><p><strong>使用QoS标识符</strong></p><p>主机可以生成自己的<strong>AxQOS</strong>值，如果它可以生成多个流量流，可以为不同的流选择不同的QoS值。</p><p>支持QoS需要对正在使用的QoS方案有系统级的理解，以及所有参与组件之间的协作。
因此，建议主机组件包括一些可编程性，以可用于控制任何给定场景下使用的确切QoS值。</p><p>如果主机组件不支持可编程QoS方案，则可以使用表示其生成的事务相对优先级的QoS值。
这些值随后可以映射到适当的替代系统级QoS值。</p><p>该规范预期许多互连组件实现将支持可编程寄存器，这些寄存器可用于将QoS值分配给连接的主机。
这些值替代主机提供的编程或默认QoS值。</p><p>QoS的默认系统级实现是任何具有选择多个要处理的事务的组件首先选择具有更高QoS值的请求进行处理。
当没有其他AXI约束要求按特定顺序处理请求时，才会进行此选择。
这意味着AXI排序规则优先于QoS目的的排序。</p><h5 id=a-ida582-qos接受标识a582-qos接受标识a><a id="a5.8.2 qos接受标识">A5.8.2 qos接受标识</a></h5><p><em><a href="#表 a5.18">表 A5.18</a></em> 中显示的QoS接受指标是来自从机的输出信号，指示它接受的最低QoS值而不会产生延迟。
这些信号与<strong>ACLK</strong>同步，但与其他AXI通道无关。</p><p><a id="表 a5.18">表 A5.18</a> QoS接受信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>VAWQOSACCEPT</strong></td><td>4</td><td>0x0</td><td>来自从机的输出，指示其接受来自AW通道请求的QoS值。</td></tr><tr><td><strong>VARQOSACCEPT</strong></td><td>4</td><td>0x0</td><td>来自从机的输出，指示其接受来自AR通道请求的QoS值。</td></tr></tbody></table><p>QoS接受信令旨在用于具有不同资源的从机组件，以满足不同的QoS值，这通常适用于内存控制器。
当较低QoS值所需的资源正在使用时，从机可以表明它仅接受特定QoS值或更高的请求。</p><p>QoS接受信令可以作为主机的输入，该接口可能有多个不同的请求可供选择。
这允许主机仅发出有可能被接受的请求，从而避免接口的不必要阻塞。</p><p>通过防止可能停滞一段时间的请求被发出，接口仍然可用于发出可能在稍后时间抵达的更高优先级请求。</p><p>在本规范中，术语<strong>VAxQOSACCEPT</strong>统称为<strong>VAWQOSACCEPT</strong>和<strong>VARQOSACCEPT</strong>信号。
<strong>VAxQOSACCEPT</strong>信号的规则和建议如下：</p><ul><li>任何QoS级别等于或高于<strong>VAxQOSACCEPT</strong>的请求将被从机接受。</li><li>任何QoS级别低于<strong>VAxQOSACCEPT</strong>的请求可能会被显著延迟。</br>本规范未定义从机必须在何种时间段内接受等于或高于所指QoS级别的请求。
然而，预计对于给定的从机，接受事务所需的时钟周期数是确定性的最大值，这在考虑到实现方面（如时钟域交叉比率）后得出。</li><li>允许从机接受低于<strong>VAxQOSACCEPT</strong>信号所指示的QoS级别的请求，但预计该请求可能会遭受显著延迟。
虽然从机延迟优先级低于QoS接受级别的请求是可以接受的，但建议该事务不应无限期延迟。</li></ul><p>优先级低的事务在接口发出的原因有几个，例如：</p><ul><li>QoS接受值的变化与组件适应该变化之间的延迟。</li><li>需要对此事务进行以避免阻塞较高优先级请求的头部。</li><li>由于饥饿预防的原因，要求对此事务进行。</li></ul><p><em><a href="#表 a5.19">表 A5.19</a></em> 中显示的QoS_Accept属性用于定义接口是否包含QoS接受指示信号。</p><p><a id="表 a5.19">表 A5.19</a> QoS_Accept属性</p><table><thead><tr><th>Qos_Accept</th><th>默认</th><th>描述\</th></tr></thead><tbody><tr><td>True</td><td></td><td>接口包含<strong>VAWQOSACCEPT</strong>和<strong>VARQOSACCEPT</strong>信号。</td></tr><tr><td>False</td><td>Y</td><td>接口不包含<strong>VAWQOSACCEPT</strong>和<strong>VARQOSACCEPT</strong>信号</td></tr></tbody></table><h3 id=a-ida第6章-事务标识和顺序a第6章-事务标识和顺序a><a id="a第6章 事务标识和顺序">A第6章 事务标识和顺序</a></h3><p>本章描述了事务标识符及其如何用于控制事务的顺序。
它包含以下部分：</p><ul><li><em><a href="#a6.1 事务id">A6.1 事务id</a></em></li><li><em><a href="#a6.2 唯一id">A6.2 唯一id</a></em></li><li><em><a href="#a6.3 请求顺序">A6.3 请求顺序</a></em></li><li><em><a href="#a6.4 互联使用事务id">A6.4 互联使用事务id</a></em></li><li><em><a href="#a6.5 写数据和响应顺序">A6.5 写数据和响应顺序</a></em></li><li><em><a href="#a6.6 读数据顺序">A6.6 读数据顺序</a></em></li></ul><h4 id=a-ida61-事务ida61-事务ida><a id="a6.1 事务id">A6.1 事务id</a></h4><p>AXI协议包含一个事务标识符（AXI ID）。
主机可以使用AXI ID来识别必须按顺序返回的实物。</p><p>所有具有给定AXI ID值的事务必须保持有序，但对于不同ID值的事务没有排序限制。</p><p>单个物理端口可以通过作为多个逻辑端口来支持乱序事务，每个端口按顺序处理其事务。</p><p>通过使用AXI ID，主机可以发出事务而无需等待早期事务完成这可以提高系统性能，
因为它使事务的并行处理成为可能。</p><h5 id=a-ida611-事务标识信号a611-事务标识信号a><a id="a6.1.1 事务标识信号">A6.1.1 事务标识信号</a></h5><p>读写请求、读取数据和写入响应通道包括一个事务ID信号。</p><p><a id="表 a6.1">表 A6.1</a> ID信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWID</strong><br><strong>BID</strong></td><td>ID_W_WIDTH</td><td>全0</td><td>用于写请求和响应排序的事务标识符</td></tr><tr><td><strong>ARID</strong><br><strong>RID</strong></td><td>ID_R_WIDTH</td><td>全0</td><td>用于读请求、响应和读数据排序的事务标识符</td></tr></tbody></table><p><em><a href="#表 a6.2">表 A6.2</a></em> 中描述了ID宽度属性。</p><p><a id="表 a6.2">表 A6.2</a> ID位宽属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>ID_W_WIDTH</td><td>0&mldr;32</td><td>−</td><td>写通道<strong>AWID</strong>、<strong>BID</strong>的位宽</td></tr><tr><td>ID_R_WIDTH</td><td>0&mldr;32</td><td>−</td><td>读通道</strong>ARID</strong>、<strong>RID</strong>的位宽</td></tr></tbody></table><p>如果宽度属性为零，则相关信号不存在。</p><p>一个不支持请求和响应重排序的主机，或者只有一个未完成事务的主机，可以从其接口中省略 ID 信号。
相应的从机必须将其 AxID 输入固定为低电平。</p><p>一个不重排序请求或响应的从机不需要使用 ID 值。
如果一个从机不包含 ID 信号，则不能连接到具有 ID 信号的主机。
因为主机要求从<strong>AWID</strong>和<strong>ARID</strong>对应<strong>BID</strong>和<strong>RID</strong>。</p><h4 id=a-ida62-唯一ida62-唯一ida><a id="a6.2 唯一id">A6.2 唯一id</a></h4><p>唯一ID指示器是一个可选标志，指示在读或写地址通道上的请求是否使用了对于在途事务唯一的AXI标识符。
在读和写响应通道上也有一个相应的信号，用于指示某个事务使用了唯一ID。</p><p>唯一ID指示器可以在AXI主机下游使用，以确定何时请求需要相对于该主机的其他请求进行排序。
那些不需要排序的请求可能在下游组件中不需要跟踪。</p><p>Unique_ID_Support属性用于指示接口是否支持唯一ID指示。</p><p><a id="表 a6.3">表 A6.3</a> Unique_ID_Support 属性</p><table><thead><tr><th>Unique_ID_Support</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>唯一ID信号存在</td></tr><tr><td>False</td><td>Y</td><td>唯一ID信号不存在</td></tr></tbody></table><p>当Unique_ID_Support为真时，以下信号包含在读取请求、读取数据、写入请求和写入响应通道中。</p><p><a id="表 a6.4">表 A6.4</a> 唯一ID信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWIDUNQ</strong><br><strong>BIDUNQ</strong><br><strong>ARIDUNQ</strong><br><strong>RIDUNQ</strong></td><td>1</td><td>0b0</td><td>如果断言为高。则本次传输ID是唯一的</td></tr></tbody></table><p>以下规则适用于唯一 ID 指示符：</p><ul><li>当<strong>AWIDUNQ</strong>被断言时，该主机不得有同一<strong>AWID</strong>值的未完成写入事务。</li><li>当<strong>AWIDUNQ</strong>被断言时，该主机不得发出与未完成写入事务具有相同<strong>AWID</strong>的写入请求。</li><li>如果请求的<strong>AWIDUNQ</strong>断言被解除，
则对应的<strong>BIDUNQ</strong>信号必须在单个传输响应中或在多传输响应的完成部分中被解除断言。</li><li>如果请求的<strong>AWIDUNQ</strong>被断言，
则对应的<strong>BIDUNQ</strong>信号必须在单个传输响应中或在多传输响应的完成部分中被断言。</li><li>当<strong>ARIDUNQ</strong>被断言时，该主机不得有同一<strong>ARID</strong>值的未完成读取事务。</li><li>当<strong>ARIDUNQ</strong>被断言时，该主机不得发出与未完成读取事务具有相同<strong>ARID</strong>的读取请求。</li><li>如果请求的<strong>ARIDUNQ</strong>被解除断言，则必须为该事务的所有响应传输解除相应的<strong>RIDUNQ</strong>信号断言。</li><li>如果请求的<strong>ARIDUNQ</strong>被断言，则必须为该事务的所有响应传输断言相应的<strong>RIDUNQ</strong>信号。</li><li>对于包含读取和写入响应的原子事务，还适用附加规则：<ul><li>如果原子请求的<strong>AWIDUNQ</strong>被取消断言，则必须为该事务的所有响应传输解除相应的<strong>RIDUNQ</strong>信号断言。</li><li>如果原子请求的<strong>AWIDUNQ</strong>被断言，则必须为该事务的所有响应传输断言相应的<strong>RIDUNQ</strong>信号。</li></ul></li></ul><p>一个事务从<strong>AxVALID</strong>被断言的周期开始，直到最终响应传输被主机接受的周期结束。
如果接口包含<strong>BCOMP</strong>，则该事务在收到断言<strong>BCOMP</strong>的响应之前被视为未完成。</p><p>一个原子事务在写入和读取响应都被主机接受之前是未完成的，参见 <em><a href=#a7.4原子事务>A7.4原子事务</a></em> 。</p><p>某些事务类型规定如果存在，则需要断言<strong>AxIDUNQ</strong>。
如果没有指定，即使没有使用相同 ID 的未完成事务，断言<strong>AxIDUNQ</strong>是可选的。</p><h4 id=a-ida63-请求顺序a63-请求顺序a><a id="a6.3 请求顺序">A6.3 请求顺序</a></h4><p>AXI请求排序模型是基于事务标识符的使用，该标识符在<strong>ARID</strong>或<strong>AWID</strong>上发出信号。</p><p>具有相同ID和目标的同一通道上的事务请求保证保持顺序。<br>具有相同ID的事务响应将以与请求发出相同的顺序返回。</p><p>排序模型不对以下情况提供任何排序保证：</p><ul><li>来自不同主机的事务。</li><li>读和写事务。</li><li>具有不同ID的事务。</li><li>发送到不同外设区域的事务。</li><li>发送到不同内存位置的事务。</li></ul><p>如果主机要求在没有排序保证的事务之间进行排序，则主机必须等到收到第一个事务的响应后再发出第二个事务。</p><h5 id=a-ida631-内存位置和外设区域a631-内存位置和外设区域a><a id="a6.3.1 内存位置和外设区域">A6.3.1 内存位置和外设区域</a></h5><p>AMBA中的地址映射由内存位置和外设区域组成。<br>内存位置具有以下所有属性:</p><ul><li>从内存位置读取一个字节返回该字节位置最后写入的值。</li><li>向内存位置的一个字节写入更新该位置的值为后续读取该位置获得的新值。</li><li>对内存位置的读取或写入对任何其他内存位置没有副作用。</li><li>每个位置都有内存观察保证。</li><li>内存位置的大小等于该组件的单拷贝原子性大小。</li></ul><p>外设区域具有以下所有属性：</p><ul><li>从外设区域中的一个地址读取并不一定返回最后写入该地址的值.</li><li>向外设区域中的一个字节地址写入并不一定将该地址的值更新为后续读取获得的新值.</li><li>访问外设区域内的一个地址可能对该区域内的其他地址产生副作用。</li><li>每个区域都有外设观察保证</li><li>外设区域的大小由实现定义，但必须包含在一个从机内。</li><li>一个事务可以针对一个或多个地址位置，这些位置由<strong>AxADDR</strong>和任何相关限定符如地址空间确定。</li><li>仅对同一内存位置或外设区域的访问之间提供排序保证。</li><li>针对外设区域的事务必须完全包含在该区域内。</li><li>跨越多个内存位置的事务具有多个排序保证。</li></ul><h5 id=a-ida362-设备和正常请求a362-设备和正常请求a><a id="a3.6.2 设备和正常请求">A3.6.2 设备和正常请求</a></h5><p>事务可以是设备类型或普通类型。</p><p><strong>设备事务</strong></p><p>一个读取或写入请求，其中<strong>AxCACHE[1]</strong>失效。</p><p>设备事务可用于访问外设区域或内存位置。</p><p><strong>普通事务</strong></p><p>一个读取或写入请求，其中<strong>AxCACHE[1]</strong>有效。</p><p>普通事务用于访问内存位置，且不应预期用于访问外围区域。</p><p>对外设区域的普通访问必须以符合协议的方式完成，但结果是IMPLEMENTATION DEFINED。</p><h5 id=a-ida363-观察和完成定义a363-观察和完成定义a><a id="a3.6.3 观察和完成定义">A3.6.3 观察和完成定义</a></h5><p>对于对外设区域的访问，当设备读取或写入访问DRW1在DRW2到达从机之前时，设备读取或写入访问DRW2会观察到DRW1。</p><p>对于对内存位置的访问，以下所有条件均适用：</p><ul><li>如果W2在W1之后生效，则写入W1会被写入W2观察到。</li><li>如果R1从写入W3返回数据，而W2在W3之后，则读取R1会被写入W2观察到。</li><li>如果R2从W1或写入W3返回数据，而W3在W1之后，则写入W1会被读取R2观察到。</li></ul><p>读取R1或写入W1可以是设备类型或普通类型。</p><p>写入和读取完成的定义如下：</p><p><strong>写入完成响应</strong></p><p>在关联的<strong>BRESP</strong>握手被发出时的周期，
当<strong>BVALID</strong>，<strong>BREADY</strong>和<strong>BCOMP</strong>（如果存在）被断言。</p><p><strong>读取完成响应</strong></p><p>在最后一个关联的<strong>RDATA</strong>握手被发出时的周期，当<strong>RVALID</strong>，<strong>RLAST</strong>和<strong>RREADY</strong>被断言。</p><h5 id=a-ida634-主机顺序保证a634-主机顺序保证a><a id="a6.3.4 主机顺序保证">A6.3.4 主机顺序保证</a></h5><p>有三种类型的排序模型保证：</p><ul><li>在收到<strong>完成响应之前</strong>的可观察性保证。</li><li><strong>完成响应中</strong>的可观察性保证。</li><li><strong>响应</strong>排序保证。</li></ul><p><strong>在收到完成响应之前的可观察性保证</strong></p><p>以下所有保证适用于使用相同 ID 的同一主机的事务：</p><ul><li>设备写入 DW1 保证在目的地到达之前先于设备写入 DW2 到达，其中 DW2 在 DW1 之后发布，且针对相同的外设区域。</li><li>设备读取 DR1 保证在目的地到达之前先于设备读取 DR2 到达，其中 DR2 在 DR1 之后发布，且针对相同的外设区域。</li><li>写入 W1 保证被写入 W2 观察到，其中 W2 在 W1 之后发布，且针对相同的内存位置。</li><li>一个被读取 R2 观察到的写入 W1 保证被读取 R3 观察到，其中 R3 在 R2 之后发布，且针对相同的内存位置。</li></ul><p><strong>从完成响应中的可观察性保证</strong></p><p>完成响应的保证如下：</p><ul><li>对于读取请求，完成响应保证它对来自任何主机的后续读取或写入请求是可观察的。</li><li>对于不可缓冲的写入请求，完成响应保证它对来自任何主机的后续读取或写入请求是可观察的。</li><li>对于可缓冲的写入请求，完成响应可以从一个中间点发送。它并不保证写入在端点完成，但保证可观察性，这取决于请求的域：<ul><li>不可共享：仅对发布主机可观察。</li><li>可共享：对共享域中的所有其他主机可观察。</li><li>系统：对所有其他主机可观察。</li></ul></li></ul><p>有关域的更多信息，请参阅 <em><a href="#a9.3 缓存一致性和域">A9.3 缓存一致性和域</a></em> 。</p><p><strong>响应排序保证</strong></p><p>事务响应具备以下所有排序保证：</p><ul><li>读取 R1 保证在读取 R2 的响应之前收到响应，其中 R2 是在 R1 之后从同一主机发布且具有相同 ID 的请求。</li><li>写入 W1 保证在写入 W2 的响应之前收到响应，其中 W2 是在 W1 之后从同一主机发布且具有相同 ID 的请求。</li></ul><h5 id=a-ida635-从机顺序需求a635-从机顺序需求a><a id="a6.3.5 从机顺序需求">A6.3.5 从机顺序需求</a></h5><p>为了满足主机顺序的保障，从机也必须满足以下要求。</p><p><strong>外设位置</strong></p><ul><li>对于外设位置，对外设位置事务的执行顺序是实现定义的。该执行顺序通常预期与到达顺序相匹配，但这并不是要求。</li></ul><p><strong>内存位置</strong></p><ul><li>写入 W1 必须在写入 W2 之前，W1 和 W2 是同一内存位置相同 ID 的访问，W2 的接收时间晚于 W1 的接收时间。</li><li>写入 W1 必须在写入 W2 之前，W1 和 W2 是同一内存位置的访问，W2 的接收时间晚于 W1 的完成响应。</li><li>写入 W1 必须在读取 R2 之前，W1 和 R2 是同一内存位置的访问，R2 的接收时间晚于 W1 的完成响应。</li><li>读取 R1 必须在写入 W2 之前，W1 和 W2 是同一内存位置的访问，W2 的接收时间晚于 R1 的完成响应。</li></ul><p><strong>响应排序要求</strong></p><ul><li>对读取 R1 的响应必须在对读取 R2 的响应之前返回，R2 是在 R1 之后接收的，相同 ID。</li><li>对写入 W1 的响应必须在对写入 W2 的响应之前返回，W2 是在 W1 之后接收的，相同 ID。</li></ul><h5 id=a-ida366-互联顺序需求a366-互联顺序需求a><a id="a3.6.6 互联顺序需求">A3.6.6 互联顺序需求</a></h5><p>互连组件具有以下属性：</p><ul><li>在一个端口接收到请求，并在另一个端口发出或响应。</li><li>在一个端口接收到响应，并在另一个端口发出或处理。</li></ul><p>当互连发出请求或响应时，必须遵循以下要求：</p><ul><li>在发出读取 R2 请求之前，必须发出读取 R1 请求，其中 R2 是在 R1 之后接收的，具有相同的 ID，并且指向相同或重叠的位置。</li><li>在发出写入 W2 请求之前，必须发出写入 W1 请求，其中 W2 是在 W1 之后接收的，具有相同的 ID，并且指向相同或重叠的位置。</li><li>在发出设备读取 DR2 请求之前，必须发出设备读取 DR1 请求，其中 DR2 是在 DR1 之后接收的，具有相同的 ID，并且指向相同的外设区域。</li><li>在发出设备写入 DW2 请求之前，必须发出设备写入 DW1 请求，其中 DW2 是在 DW1 之后接收的，具有相同的 ID，并且指向相同的外设区域。</li><li>在发出读取 R2 响应之前，必须发出读取 R1 响应，其中 R2 是在 R1 之后接收的，具有相同的 ID。</li><li>在发出写入 W2 响应之前，必须发出写入 W1 响应，其中 W2 是在 W1 之后接收的，具有相同的 ID。</li></ul><p>当互连作为从机工作时，也必须遵循从机要求。</p><p>与事务相关 AXI ID 值的任何操作必须确保原始 ID 值的顺序要求得以保持。</p><h5 id=a-ida367-终点之前响应a367-终点之前响应a><a id="a3.6.7 终点之前响应">A3.6.7 终点之前响应</a></h5><p>为了提高系统性能，中间组件可以对某些事务发出响应。这一操作被称为提前响应。
发出提前响应的中间组件必须确保满足可见性和排序保证。</p><p><strong>提前读取响应</strong></p><p>对于普通读取事务，如果中间组件的本地内存与对相同或重叠地址的所有早期写入保持同步，则可以用读取数据进行响应。
在这种情况下，请求不需要传播到中间组件之外。</p><p>中间组件必须遵守 ID 排序规则，这意味着只有在所有早期的相同 ID 读取已经有响应的情况下，才能发送读取响应。</p><p><strong>提前写入响应</strong></p><p>对于可缓冲写入事务（<strong>AWCACHE[0]</strong> 被置为有效），中间组件可以为没有下游观察者的事务发送提前写入响应。
如果中间组件发送提前写入响应，则可以存储数据的本地副本，但必须在丢弃该数据之前将事务向下游传播。</p><p>中间组件必须遵守 ID 排序规则，这意味着只有在所有早期的相同 ID 写入已经有响应的情况下，才能发送写入响应。</p><p>在发送提前写入响应后，该组件必须负责该事务的排序和可观察性，直到写入被传播到下游并收到写入响应。
在发送提前写入响应和收到下游响应的期间，该组件必须确保：</p><ul><li>如果对普通事务给予了提前写入响应，则所有后续事务对相同或重叠内存位置的写入都是在已经给予提前响应的写入之后排序。</li><li>如果对设备事务给予了提前写入响应，则所有后续事务对相同外设区域的写入都是在已经给予提前响应的写入之后排序。</li></ul><p>在对设备可缓冲事务给予提前写入响应时，预计中间组件将独立于其他事务传播写入事务。
中间组件无法等待另一个读取或写入到达，然后再传播之前的设备写入。</p><h5 id=a-ida368-不同内存类型之间的请求顺序a368-不同内存类型之间的请求顺序a><a id="a3.6.8 不同内存类型之间的请求顺序">A3.6.8 不同内存类型之间的请求顺序</a></h5><p>在可缓存请求与设备请求或非缓存普通请求之间没有排序要求。
设备请求与非缓存普通请求之间的排序要求取决于Device_Normal_Independence属性。</p><p><a id="表 a6.5">表 A6.5</a> Device_Normal_Independence属性</p><table><thead><tr><th>Device_Normal_Independence</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>设备请求被允许超越或被具有相同ID并指向相同位置的正常非缓存请求超越</td></tr><tr><td>False</td><td>Y</td><td>设备和正常的非缓存请求具有相同的 ID，必须按发布顺序在同一位置被观察。</td></tr></tbody></table><p>连接具有不同Device_Normal_Independence值的主机和从机接口的指导如 <em><a href="#表 a6.6">表 A6.6</a></em> 所示。</p><p><a id="表 a6.6">表 A6.6</a> Device_Normal_Independence互联指导</p><table><thead><tr><th>Device_Normal_Independence</th><th>从机: False</th><th>从机: True</th></tr></thead><tbody><tr><td>主机: False</td><td>兼容</td><td>不兼容 从机可能无法满足主机的顺序要求。</td></tr><tr><td>主机: True</td><td>兼容<br>从机可能会执行比主机更严格的顺序</td><td>兼容</td></tr></tbody></table><h5 id=a-ida369-写入可观察顺序a369-写入可观察顺序a><a id="a3.6.9 写入可观察顺序">A3.6.9 写入可观察顺序</a></h5><p>为了提高与支持不同排序模型的接口协议兼容性，
从机可以为写事务提供更强的排序保证，这被称为有序写观察。</p><p>Ordered_Write_Observation 属性用于定义一个接口是否具有有序写观察。</p><p><a id="表 a6.7">表 A6.7</a> Ordered_Write_Observation 属性</p><table><thead><tr><th>Ordered_Write_Observation</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>接口表现出有序可观察性。</td></tr><tr><td>False</td><td>Y</td><td>接口不表现出有序可观察性。</td></tr></tbody></table><p>一个展示有序写观察的接口为写事务提供了保证，这些保证与目的地或地址无关：</p><ul><li>写操作W1保证会被写操作W2观察到，其中W2是在W1之后由同一主机发出的，且具有相同的ID。</li></ul><p>使用有序写观察时，主机可以在不等待写响应的情况下发出多个写请求，并且它们会按照发出顺序被观察。
这在使用Producer-Consumer排序模式时可以提高性能。</p><h4 id=a-ida64-互联使用事务ida64-互联使用事务ida><a id="a6.4 互联使用事务id">A6.4 互联使用事务id</a></h4><p>当一个主机连接到互连时，互连会将附加bit附加到<strong>AWID</strong>和<strong>ARID</strong>标识符，
这些位对于该主机端口是唯一的。这有两个效果：</p><ul><li>主机不必知道其他主机使用的ID值，因为互连通过将主机编号附加到原始标识符使每个主机使用的ID值唯一。</li><li>从机接口处的ID标识符比主机接口处的ID标识符更宽。</li></ul><p>对于写响应，互连使用<strong>BID</strong>标识符的附加bit来确定写响应的目标主机器端口。
互连在将<strong>BID</strong>值传递给正确的主机端口之前会去掉这些<strong>BID</strong>标识符的位。</p><p>对于读数据，互连使用<strong>RID</strong>标识符的附加bit来确定读数据的目标主机端口。
互连在将<strong>RID</strong>值传递给正确的主机端口之前会去掉这些<strong>RID</strong>标识符的位。</p><h4 id=a-ida65-写数据和响应顺序a65-写数据和响应顺序a><a id="a6.5 写数据和响应顺序">A6.5 写数据和响应顺序</a></h4><p>从机必须确保写响应的<strong>BID</strong>值与其响应请求的<strong>AWID</strong>值匹配。</p><p>主机必须按照发出事务请求的顺序发出写数据。</p><p>一个将不同主机的写事务结合在一起的互连必须确保以请求顺序转发写数据。</p><p>不同事务的写数据传输不允许交错。</p><p>互连必须确保来自具有相同<strong>AWID</strong>值的事务序列的写响应在请求顺序中被主机接收。</p><h4 id=a-ida66-读数据顺序a66-读数据顺序a><a id="a6.6 读数据顺序">A6.6 读数据顺序</a></h4><p>从机必须确保任何返回数据的<strong>RID</strong>值与其响应请求的<strong>ARID</strong>值匹配。</p><p>互连接口必须确保来自同一<strong>ARID</strong>值的不同从机的一系列事务的读取数据按请求顺序被主机接收。</p><p>读取数据重排序深度是从机可能发送读取数据的最大接受请求数量。
按接收请求的顺序发送读取数据的从机具有一级读取数据重排深度。</p><p>读取数据重排序深度是一个静态值，可以由从机的设计者指定。</p><p>主机没有机制动态地确定从机的读取数据重排序深度。</p><h5 id=a-ida661-读数据交错a661-读数据交错a><a id="a6.6.1 读数据交错">A6.6.1 读数据交错</a></h5><p>对于读取数据传输允许使用不同的ID值交织进行，这包括所有可以有多个读取数据传输的事务，包括原子事务。</p><p>如果确定附加的从机将交织不同事务的读取数据，一些AXI主机和互联组件可以更有效地设计。</p><p>Read_Interleaving_Disabled属性用于指示接口是否支持来自不同事务的读取数据传输交织。</p><p><a id="表 a6.8">表 A6.8</a> Read_Interleaving_Disabled</p><table><thead><tr><th>Read_Interleaving_Disabled</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>主机无法接收交织的读取数据。<br>从机保证不会交织读取数据。</td></tr><tr><td>False</td><td>Y</td><td>主机能够接收交织的读取数据。<br>从机可能会将具有不同<strong>ARID</strong>值读取事务的数据交织。</td></tr></tbody></table><p>对于某些接口，此属性可用作配置控制。对于其他接口，它是一个功能指示器。
所有发出具有不同ID的事务的主机必须被设计为接受交织数据。
作为一种优化，当附加的从机支持禁用交错时，主机可能使用配置选项来禁用交错。</p><h5 id=a-ida662读取数据分块a662读取数据分块a><a id=a6.6.2读取数据分块>A6.6.2读取数据分块</a></h5><p>读取数据分块选项使从机能够使用128bit粒度重新排序事务中的读取数据。
起始地址可能用作决定首先发送哪个块的提示，但从机允许以任何顺序返回数据块。</p><p>属性Read_Data_Chunking用于指示接口是否支持以可重新排序的块形式返回读取数据。</p><p><a id="表 a6.9">表 A6.9</a> Read_Data_Chunking 属性</p><table><thead><tr><th>Read_Data_Chunking</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持读取数据分块。</td></tr><tr><td>False</td><td>Y</td><td>不支持读取数据分块，相关的分块信号也不存在。</td></tr></tbody></table><h6 id=a-ida6621-读取数据分块信号a6621-读取数据分块信号a><a id="a6.6.2.1 读取数据分块信号">A6.6.2.1 读取数据分块信号</a></h6><p><a id="表 a6.10">表 A6.10</a> 读取数据分块信号</p><p>当支持读取数据分块时，在读取请求和数据通道中会添加如 <em><a href="#表 a6.10">表 A6.10</a></em> 所示的信号。</p><p><a id="表 a6.10">表 A6.10</a> 读取数据分块信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>ARCHUNKEN</strong></td><td>1</td><td>0b0</td><td>如果在读取请求中断言，从机可以以128bit块发送读取数据。</td></tr><tr><td><strong>RCHUNKV</strong></td><td>1</td><td>0b0</td><td>断言为高表示<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>是有效的。每个事务响应必须相同。</td></tr><tr><td><strong>RCHUNKNUM</strong></td><td>RCHUNKNUM_WIDTH</td><td>全0</td><td>指示正在传输的块的编号。<br>块的编号根据事务的数据宽度和基地址从零开始递增。</td></tr><tr><td><strong>RCHUNKSTRB</strong></td><td>RCHUNKSTRB_WIDTH</td><td>全1</td><td>指示了有效的读取数据块。<br>对于每次传输每个位对应128 bit数据，<strong>RCHUNKSTRB</strong>最低位对应<strong>RDATA</strong>最低128位。</td></tr></tbody></table><p>属性RCHUNKNUM_WIDTH定义了<strong>RCHUNKNUM</strong>信号的宽度。</p><p><a id="表 a6.11">表 A6.11</a> RCHUNKNUM_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>RCHUNKNUM_WIDTH</td><td>0,1,5,6,7,8</td><td>0</td><td>RCHUNKNUM的位宽。<br>0：Read_Data_Chunking = False<br>0/1：DATA_WIDTH &lt; 128<br>8:DATA_WIDTH = 128<br>7:DATA_WIDTH = 256<br>6:DATA_WIDTH = 512<br>5DATA_WIDTH=1024</td></tr></tbody></table><p>RCHUNKSTRB_WIDTH属性定义RCHUNKSTRB信号的宽度.</p><p><a id="表 a6.12">表 A6.12</a> RCHUNKSTRB_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>RCHUNKSTRB_WIDTH</td><td>0,1,2,4,8</td><td>0</td><td>RCHUNKSTRB的位宽。<br>0：Read_Data_Chunking = False<br>0/1：DATA_WIDTH &lt; 256<br>2:DATA_WIDTH = 256<br>4:DATA_WIDTH512256<br>8:DATA_WIDTH = 1024</td></tr></tbody></table><p>具有较小DATA_WIDTH的接口可以包含<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>信号，
宽度为1位，也可以从接口中省略它们。
当使用接口保护时，<strong>RCHUNKCHK</strong>信号涵盖这两个信号，
因此连接组件的<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>必须具有相同的宽度。</p><p>建议在接口不需要时省略<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>。</p><h6 id=a-ida622-读数据分块协议规则a622-读数据分块协议规则a><a id="a6.2.2 读数据分块协议规则">A6.2.2 读数据分块协议规则</a></h6><p>在读取数据分块协议中，所有以下规则都适用：</p><ul><li><strong>ARCHUNKEN</strong> 仅针对具有以下属性的事务：<ul><li>大小等于数据通道宽度，或长度为一次传输。</li><li>大小为 128 位或更大。</li><li>Addr 对齐到 16 字节。</li><li>Burst 为 INCR 或 WRAP。</li><li>操作码为 ReadNoSnoop、ReadOnce、ReadOnceCleanInvalid 或 ReadOnceMakeInvalid。</li></ul></li><li>ID 值必须在飞行中是唯一的，这意味着：<ul><li>只有在没有使用相同<strong>ARID</strong>值的未完成读取事务的情况下，才能断言<strong>ARCHUNKEN</strong>。</li><li>主机不得在读取通道上发出与具有断言<strong>ARCHUNKEN</strong>的未完成请求具有相同<strong>ARID</strong>的请求。</li><li>如果在接口上存在，则如果断言<strong>ARCHUNKEN</strong>，则必须断言<strong>ARIDUNQ</strong>。</li></ul></li><li>如果解除断言<strong>ARCHUNKEN</strong>，则必须为事务的所有响应传输解除断言<strong>RCHUNKV</strong>。</li><li>如果断言<strong>ARCHUNKEN</strong>，则可以为事务的响应传输断言<strong>RCHUNKV</strong>。</li><li><strong>RCHUNKV</strong> 必须对事务的每个响应传输相同。</li><li>当断言<strong>RVALID</strong>和<strong>RCHUNKV</strong>时，<strong>RCHUNKNUM</strong>必须介于零和<strong>ARLEN</strong>之间。</li><li>当断言<strong>RVALID</strong>和<strong>RCHUNKV</strong>时，<strong>RCHUNKSTRB</strong>必须不为零。</li><li>当断言<strong>RVALID</strong>和<strong>RCHUNKV</strong>时，<strong>RLAST</strong>仅针对事务的最终响应传输断言，
与<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>无关。</li><li>当断言<strong>RVALID</strong>且解除断言<strong>RCHUNKV</strong>时，<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>可以取任何值。</li></ul><p>传输的数据块数量必须与<strong>ARLEN</strong>和<strong>ARSIZE</strong>一致，
因此事务中传输的字节数无论是否启用分块都相同。</p><p>请注意，当使用读取数据分块时，事务可能比 ARLEN 指示的具有更多读取数据传输。</p><p>对于未对齐的事务，地址低于<strong>ARADDR</strong>的块不会传输，并且必须解除断言<strong>RCHUNKSTRB</strong>。</p><h6 id=a-ida6623-互操作性a6623-互操作性a><a id="a6.6.2.3 互操作性">A6.6.2.3 互操作性</a></h6><p>如果主机支持读数据分块，从机也支持分块，那么下游互联和从机可以减少其缓冲。
一种连接到具有混合分块支持组件的互联可以根据所附组件的能力驱动<strong>ARCHUNKEN</strong>和<strong>RCHUNKV</strong>。</p><p>当连接具有不同Read_Data_Chunking属性值的接口时，适用以下规则，如 <em><a href="#表 a6.13">表 A6.13</a></em> 所示。</p><p><a id="表 a6.13">表 A6.13</a> Read_Data_Chunking互操作性</p><table><thead><tr><th>Read_Data_Chunking</th><th>从机: False</th><th>从机: True</th></tr></thead><tbody><tr><td>主机: False</td><td><strong>ARCHUNKEN</strong>不存在。<br><strong>RCHUNKV</strong> 不存在。<br><strong>RCHUNKNUM</strong> 不存在。<br><strong>RCHUNKSTRB</strong>不存在。<br>读取数据以全数据的形式自然排序。</td><td>从机<strong>ARCHUNKEN</strong> 输入连接为LOW。<br>从机<strong>RCHUNKV</strong>输出不连接。<br>从机<strong>RCHUNKNUM</strong>输出不连接。<br>从机<strong>RCHUNKSTRB</strong>输出不连接。<br>读取数据以全数据的形式自然排序。</td></tr><tr><td>主机: True</td><td>主机<strong>ARCHUNKEN</strong>输出不连接。<br>主机<strong>RCHUNKV</strong> 输入连接为LOW。<br>主机<strong>RCHUNKNUM</strong> 输入连接为任意值。<br>主机<strong>RCHUNKSTRB</strong>输入连接为任意值。</td><td>分块信号对应连接<br>读取数据被分块排序。</td></tr></tbody></table><h6 id=a-ida6624-分块实例a6624-分块实例a><a id="a6.6.2.4 分块实例">A6.6.2.4 分块实例</a></h6><p>在这些示例中，图中的每一行表示一次传输，阴影单元格表示未传输的字节。</p><p><em><a href="#图 a6.1">图 A6.1</a></em> 显示了在256位宽的读数据通道上的一次事务，其中：</p><ul><li>地址为0x00</li><li>长度为2次传输</li><li>尺寸为256位</li><li>突发为INCR</li></ul><p><a id="图 a6.1">图 A6.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A6.1_Example_of_read_data_returned_in_128-bit_chunks.png alt></a></p><p><em><a href="#图 a6.2">图 A6.2</a></em> 在256位宽读数据通道上的一次事务，其中：</p><ul><li>地址是0x10</li><li>长度是2次传输</li><li>尺寸是256位</li><li>突发是INCR</li></ul><p><a id="图 a6.2">图 A6.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A6.2_Example_with_an_unaligned_address_and_a_mixture_of_128-bit_and_256-bit_chunks.png alt></a></p><p>在一个128位宽的读数据通道上的事务，其中：</p><ul><li>地址是0x10。</li><li>长度是4个传输。</li><li>尺寸是128位。</li><li>突发是WRAP。</li><li>RCHUNKSTRB不存在。</li></ul><p>从机使用起始地址作为提示，并首先发送0x10处的块。</p><p><a id="图 a6.3">图 A6.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A6.3_Example_of_a_wrapping_transaction.png alt></a></p><h3 id=a-ida第7章-原子访问a第7章-原子访问a><a id="a第7章 原子访问">A第7章 原子访问</a></h3><p>本章描述了单副本和多副本的原子性以及如何执行独占访问和原子事务。<br>它包含以下部分：</p><ul><li><em><a href="#a7.1 单副本原子大小">A7.1 单副本原子大小</a></em></li><li><em><a href="#a7.2 多副本原子大小">A7.2 多副本原子大小</a></em></li><li><em><a href="#a7.3 独占访问">A7.3 独占访问</a></em></li><li><em><a href="#a7.4 原子事务">A7.4 原子事务</a></em></li></ul><h4 id=a-ida71-单副本原子大小a71-单副本原子大小a><a id="a7.1 单副本原子大小">A7.1 单副本原子大小</a></h4><p>单副本原子性大小是一个事务原子更新的最小字节数。
AXI协议要求大小超过单副本原子性大小的事务以至少单副本原子性大小的块更新内存。</p><p>原子性并不定义数据更新的确切时刻。必须确保没有主机能够观察到原子数据的部分更新形式。
例如，在许多系统中，数据结构如链表由32位原子元素组成。
对这些元素之一的原子更新需要在同一时间更新整个32位值。
任何主机都不能观察到一次仅更新16位，然后再更新另外16位的情况。</p><p>更复杂的系统需要对更大原子元素的支持，特别是64位原子元素，以便主机能够使用基于这些更大原子元素的数据结构进行通信。</p><p>系统中支持的单副本原子性大小很重要，因为涉及某一通信的所有组件必须支持所需的原子元素大小。
如果两个主机通过互连和一个从机进行通信，则所有相关组件必须确保所需大小的事务被视为原子。</p><p>AXI协议不要求特定的单副本原子性大小，系统可以设计为支持不同的单副本原子性大小。</p><p>在AXI中，单副本原子组一词描述了一组可以在特定原子性下进行通信的组件。例如，<em><a href="#图 a7.1">图 A7.1</a></em> 显示了这样一个系统，其中：</p><ul><li>CPU、DSP、DRAM控制器、DMA控制器、外设、SRAM内存和相关互连处于32位单副本原子组中。</li><li>CPU、DSP、DRAM控制器和相关互连也处于64位单副本原子组中。</li></ul><p><a id="图 a7.1">图 A7.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A7.1_Example_system_with_different_single-copy_atomic_groups.png alt></a></p><p>一个事务的原子性保证从来没有超过其起始地址的对齐程度。
例如，在一个64位单副本原子组中的事务，如果没有与8字节边界对齐，则没有任何64位单副本原子保证。</p><p>与事务相关的字节strobes不会影响单副本原子性大小。</p><h4 id=a-ida72-多副本原子写a72-多副本原子写a><a id="a7.2 多副本原子写">A7.2 多副本原子写</a></h4><p>如果满足下列情况，则一个系统被定义为多副本原子性：</p><ul><li>所有代理观察到对同一位置的写入是按照相同的顺序进行的。</li><li>对一个代理可观察位置的写入，对于所有代理都是可观察的。</li></ul><p>为了说明一个系统提供多副本原子性，定义了一个Multi_Copy_Atomicity属性。</p><p><a id="表 a7.1">表 A7.1</a> Multi_Copy_Atomicity 属性</p><table><thead><tr><th>Multi_Copy_Atomicity</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持多副本原子性</td></tr><tr><td>False</td><td>Y</td><td>不支持多副本原子性</td></tr></tbody></table><p>多副本原子性可以通过以下方式确保：</p><ul><li>对于给定地址使用单一的序列化点（Point of Serialization - PoS），以便对同一位置的所有访问都被排序。
这必须确保在新值对任何代理可见之前，位置的所有一致缓存副本都失效。</li><li>避免使用在任何代理上游的转发缓冲区。这防止了某些代理在所有代理可见之前看到位置的缓冲写入。</li></ul><p>要求该多副本原子性属性在本规范的第G期及之后为真。</p><h4 id=a-ida73--独占访问a73--独占访问a><a id="a7.3  独占访问">A7.3 独占访问</a></h4><p>独占访问机制可以提供信号量类型的操作，而无需在操作期间将连接专门分配给特定的主机。</p><p><strong>AxLOCK</strong>信号用于指示独占访问，
而<strong>BRESP</strong>和<strong>RRESP</strong>信号分别指示独占访问写入或读取的成功或失败。</p><p><a id="表 a7.2">表 A7.2</a> AxLOCK 信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWLOCK</strong><br><strong>ARLOCK</strong></td><td>1</td><td>0b0</td><td>断言为高表明需要进行独占访问。</td></tr></tbody></table><p>Exclusive_Accesses属性用于定义主机是否能够发放独占访问权限或从机是否支持这些权限。</p><p><a id="表 a7.3">表 A7.3</a> Exclusive_Accesses 属性</p><table><thead><tr><th>Exclusive_Accesses</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td>支持独占访问，<strong>AWLOCK</strong>和<strong>ARLOCK</strong>出现在接口上。</td></tr><tr><td>False</td><td></td><td>不支持独占访问，<strong>AWLOCK</strong>和<strong>ARLOCK</strong>不出现在接口上。</td></tr></tbody></table><p><em><a href="#表 a7.4">表 A7.4</a></em> 提供了在连接具有不同属性值的主机和从机组件时适用的指导。</p><p><a id="表 a7.4">表 A7.4</a> 独占访问的互操作性</p><table><thead><tr><th>Exclusive_Accesses</th><th>从机：False</th><th>从机：False</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容。<br><strong>AWLOCK</strong>和<strong>ARLOCK</strong>接LOW。</td></tr><tr><td>主机：True</td><td>不兼容。<br>独占访问只会失败，但是接口不会产生死锁。</td><td>兼容。</td></tr></tbody></table><h5 id=a-ida731-独占访问序列a731-独占访问序列a><a id="a7.3.1 独占访问序列">A7.3.1 独占访问序列</a></h5><p>独占访问序列的机制是：</p><ol><li>主机从一个地址发出独占读取请求。</li><li>在稍后的时间，主机尝试通过向同一地址发出独占写入请求来完成独占操作，
并且<strong>AWID</strong>与用于独占读取的<strong>ARID</strong>相匹配。</li><li>该独占写入访问被标记为：<ul><li>成功，如果自独占读取访问以来没有其他主机写入该位置。在这种情况下，独占写入更新内存。</li><li>失败，如果自独占读取访问以来其他主机已向该位置写入。在这种情况下，内存位置不更新。</li></ul></li></ol><p>主机可能没有完成独占操作的写入部分。独占访问监控硬件仅监控每个事务ID的一个地址。
如果主机没有完成独占操作的写入部分，则该主机使用相同的事务ID进行的后续独占读取将改变监控的独占访问地址。</p><h5 id=a-ida732-从主机的角度进行独占访问a732-从主机的角度进行独占访问a><a id="a7.3.2 从主机的角度进行独占访问">A7.3.2 从主机的角度进行独占访问</a></h5><p>一个主机通过执行独占读取开始独占操作。
如果事务成功，从机返回EXOKAY响应，表示从机记录了需要监控的独占访问地址。</p><p>如果主机尝试对不支持独占访问的从机进行独占读取，从机返回OKAY响应，而不是EXOKAY响应。
在这种情况下，读取的数据是有效的，但位置并没有被独占性监控。</p><p>主机可以将OKAY响应视为错误条件，表示不支持独占访问。
建议主机不要执行此独占操作的写入部分。</p><p>在独占读取后，主机尝试对同一位置执行独占写入。
如果所寻址位置的内容自独占读取以来没有被更新，则独占写入操作成功。
从机返回EXOKAY响应，并更新内存位置。</p><p>如果所寻址位置的内容自独占读取以来已被更新，则独占写入尝试失败，从机返回OKAY响应，而不是EXOKAY响应。独占写入尝试不会更新内存位置。</p><p>主机可能无法完成独占操作的写入部分。
如果发生这种情况，从机继续监控该地址的独占访问，直到另一个独占读取开始新的独占访问序列。
主机在读取部分完成之前，不得开始独占访问序列的写入部分。</p><h5 id=a-ida733-独占访问限制a733-独占访问限制a><a id="a7.3.3 独占访问限制">A7.3.3 独占访问限制</a></h5><p>以下限制适用于独占访问：</p><ul><li>独占访问的地址必须与事务中的字节总数对齐，即 Size 和 Length 的乘积。</li><li>在独占访问事务中传输的字节数必须是 2 的幂，即 1、2、4、8、16、32、64 或 128 字节。</li><li>独占事务中可以传输的最大字节数为 128。</li><li>独占访问的长度不得超过 16 次传输。</li><li>域不得是可共享的，请参见 <em><a href="#a9.3.3 可共享域">A9.3.3 可共享域</a></em> 。</li><li>操作码必须是 ReadNoSnoop 或 WriteNoSnoop。请参见 <em><a href="#a第8章 请求操作码">A第8章 请求操作码</a></em> 。</li><li><strong>AWTAGOP</strong> 必须不匹配，请参见 <em><a href=#a1.3.2内存标记扩展>A1.3.2内存标记扩展</a></em> 。</li></ul><p>未遵守这些限制会导致UNPREDICTABLE的行为。</p><p>为了使独占序列成功，<strong>AxCACHE</strong>值必须适当，以确保读写请求到达独占访问监控器。</p><p>在独占操作期间需要监控的最小字节数是 Size 和 Length 的乘积。</p><p>从机可以监控更多的字节，最多可达 128，这是独占访问中的最大字节数。
然而，这可能导致成功的独占访问被指示为失败，因为相邻的字节被更新。
如果在独占序列中的读请求和写请求之间显示的任何信号在表 A7.5 中不同，则即使该位置未被其他代理更新，独占写入也可能失败。</p><p><a id="表 a7.5">表 A7.5</a> 独占序列中应该保持不变的信号</p><table><thead><tr><th><strong>AxID     </strong></th><th><strong>AxADDR    </strong></th><th><strong>AxREGION</strong></th><th><strong>AxSUBSYSID</strong></th><th><strong>AxDOMAIN   </strong></th></tr></thead><tbody><tr><td><strong>AxLEN</strong></td><td><strong>AxSIZE</strong></td><td><strong>AxBURST</strong></td><td><strong>AxLOCK</strong></td><td><strong>AxCACHE[1:0]</strong></td></tr><tr><td><strong>AxPROT</strong></td><td><strong>AxNSE</strong></td><td><strong>AxSNOOP</strong></td><td><strong>AxMMUATST</strong></td><td><strong>AxMMUFLOW</strong></td></tr><tr><td><strong>AxMMUVALID</strong></td><td><strong>AxMMUSECSID</strong></td><td><strong>AxMMUSID</strong></td><td><strong>AxMMUSSID</strong></td><td><strong>AxMMUSSIDV</strong></td></tr></tbody></table><h5 id=a-ida734-从从机的角度进行独占访问a734-从从机的角度进行独占访问a><a id="a7.3.4 从从机的角度进行独占访问">A7.3.4 从从机的角度进行独占访问</a></h5><p>一个支持独占访问的从机必须具有监视硬件。
建议每个支持独占功能的主机ID都配有一个监视单元，
可以访问该从机。</p><p>当从机接收到独占读取请求时，它会记录任何独占读取操作的地址和<strong>ARID</strong>值。
然后它监视该位置，直到该位置发生写入，或直到另一个具有相同<strong>ARID</strong>值的独占读取将监视器重置为另一个地址。</p><p>如果从机能够成功处理独占读取，它会对每个读取数据传输回应EXOKAY。</p><p>如果从机无法处理独占读取，它会以不是EXOKAY的响应作出回应。
一个独占读取可以有多个响应传输。对于单个事务不允许同时出现OKAY和EXOKAY响应。</p><p>当从机接收到具有给定<strong>AWID</strong>值的独占写入时，监视器会检查该地址是否正在监视该<strong>AWID</strong>的独占访问。
如果是，这表明自独占读取访问以来，该位置没有发生写入，独占写入继续进行，并完成独占访问。
从机向主机返回EXOKAY响应，并更新指定的存储位置。</p><p>如果在独占写入时，该地址未使用相同的<strong>AWID</strong>值进行，这表示以下情况之一：</p><ul><li>该位置自独占读取访问以来已被更新。</li><li>监视器已重置到另一个位置。</li><li>主机没有以与独占写入相同的属性发出独占读取。</li></ul><p>在所有独占写入都不得更新指定位置的情况下，从机必须返回OKAY响应，而不是EXOKAY响应。</p><p>如果一个不支持独占访问的从机接收到独占写入，它会以OKAY响应作出回应，并更新该位置。</p><h4 id=a-ida74-原子事务a74-原子事务a><a id="a7.4 原子事务">A7.4 原子事务</a></h4><p>原子事务不仅仅执行单一访问，还有与事务相关联的操作。
原子事务允许将操作发送到数据上，从而使操作能够在更靠近数据位置的地方执行。
原子事务适用于数据与必须执行操作的代理相距较远的情况。</p><p>与使用独占访问相比，该方法减少了在系统中必须使数据对其他代理不可访问的时间。</p><h5 id=a-ida741-概述a741-概述a><a id="a7.4.1 概述">A7.4.1 概述</a></h5><p>在原子事务中，主机发送一个地址、控制信息和出站数据。从机发送入站数据（原子存储除外）和响应。
该规格支持四种形式的原子事务：</p><p><strong>原子存储 - AtomicStore</strong></p><ul><li>主机发送一个带地址的单一数据值和要执行的原子操作。</li><li>从机使用发送的数据和位于地址位置的值作为操作数执行操作。
•-结果存储在地址位置。</li><li>提供一个没有数据的单一响应。</li><li>出站数据大小为1、2、4或8字节。</li></ul><p><strong>原子加载 - AtomicLoad</strong></p><ul><li>主机发送一个带地址的单一数据值和要执行的原子操作。</li><li>从机返回位于地址位置的原始数据值。</li><li>从机使用发送的数据和位于地址位置的值作为操作数执行操作。</li><li>结果存储在地址位置。</li><li>出站数据大小为1、2、4或8字节。</li><li>入站数据大小与出站数据大小相同。</li></ul><p><strong>原子交换 - AtomicSwap</strong></p><ul><li>主机发送一个带地址的单一数据值。</li><li>从机使用事务中提供的数据值交换地址位置的值。</li><li>从机返回位于地址位置的原始数据值。</li><li>出站数据大小为1、2、4或8字节。</li><li>入站数据大小与出站数据大小相同。</li></ul><p><strong>原子比较 - AtomicCompare</strong></p><ul><li>主机发送两个数据值，即比较值和交换值，至地址位置。比较值和交换值大小相等。</li><li>从机将地址位置的数据值与比较值进行检查：<ul><li>如果值匹配，则将交换值写入地址位置。</li><li>如果值不匹配，则不将交换值写入地址位置。</li></ul></li><li>从机返回位于地址位置的原始数据值。</li><li>出站数据大小为2、4、8、16或32字节。</li><li>入站数据大小为出站数据大小的一半，因为出站数据包含比较值和交换值，而入站数据仅具有原始数据值。</li></ul><h5 id=a-ida742-原子事务操作a742-原子事务操作a><a id="a7.4.2 原子事务操作">A7.4.2 原子事务操作</a></h5><p>该规范支持八种不同的操作，可将 <em><a href=#a7.6>A7.6</a></em> 所示的与AtomicStore和AtomicLoad事务一起使用。</p><p><a id=a7.4.2>A7.4.2</a> 原子事务操作</p><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>ADD</td><td>内存中的值与发送的数据相加，结果存储在内存中。</td></tr><tr><td>CLR</td><td>发送数据中的每个已设置位用于清除内存中对应的位。</td></tr><tr><td>EOR</td><td>发送数据与内存中值的按位异或。</td></tr><tr><td>SET</td><td>发送数据中的每个已设置位用于设置内存中对应的位。</td></tr><tr><td>SMAX</td><td>存储在内存中的值是现有值和发送数据中的最大值。<br>该操作假定数据为带符号数。</td></tr><tr><td>SMIN</td><td>存储在内存中的值是现有值和发送数据中的最小值。<br>该操作假定数据为带符号数。</td></tr><tr><td>UMAX</td><td>存储在内存中的值是现有值和发送数据中的最大值。<br>该操作假定数据为无符号数。</td></tr><tr><td>UMIN</td><td>存储在内存中的值是现有值和发送数据中的最小值。<br>该操作假定数据为无符号数。</td></tr></tbody></table><h5 id=a-ida743-原子事务属性a743-原子事务属性a><a id="a7.4.3 原子事务属性">A7.4.3 原子事务属性</a></h5><p>原子事务的规则如下：</p><ul><li><strong>AWLEN</strong> 和 <strong>AWSIZE</strong> 指定事务中写数据的字节数。
对于 AtomicCompare，字节数必须包括比较值和交换值。</li><li>如果 <strong>AWLEN</strong> 指示的事务长度大于 1，则 <strong>AWSIZE</strong> 必须是完整的数据通道宽度。</li><li>在 <strong>AWADDR</strong> 和 <strong>AWSIZE</strong> 指定的数据窗口之外的写 strobe必须被禁止。</li><li>数据窗口内的写 strobes必须被使能。</li></ul><p><strong>对于 AtomicStore、AtomicLoad 和 AtomicSwap</strong></p><ul><li>写数据为 1、2、4 或 8 字节，读数据分别为 1、2、4 或 8 字节。</li><li><strong>AWADDR</strong> 必须与总写数据大小对齐。</li><li><strong>AWBURST</strong> 必须为 INCR。</li></ul><p><em>对于 AtomicCompare</em></p><ul><li>写数据为 2、4、8、16 或 32 字节，读数据为 1、2、4、8 或 16 字节。</li><li><strong>AWADDR</strong> 必须与总写数据大小的一半对齐。</li><li>如果 <strong>AWADDR</strong> 指向事务的下半部分：<ul><li>首先发送比较值。比较值位于单次传输事务的低字节中，或位于多次传输事务的第一次传输中。</li><li><strong>AWBURST</strong> 必须为 INCR。</li></ul></li><li>如果 <strong>AWADDR</strong> 指向事务的上半部分：<ul><li>首先发送交换值。交换值位于单次传输事务的低字节中，或位于多次传输事务的第一次传输中。</li><li><strong>AWBURST</strong> 必须为 WRAP。</li></ul></li><li>对于 WRAP 类型的事务，通常规则有所放宽：<ul><li>允许长度为 1。</li><li><strong>AWADDR</strong> 不需要与传输大小对齐。</li></ul></li></ul><p>具有 64 位数据通道的 AtomicCompare 事务示例如 <em><a href="#图 a7.2">图 A7.2</a></em> 所示。</p><p><a id="图 a7.2">图 A7.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A7.2_Examples_showing_the_location_of_the_Compare_and_Swap_values_for_an_AtomicCompare.png alt></a></p><h5 id=a-ida744-原子事务使用ida744-原子事务使用ida><a id="a7.4.4 原子事务使用id">A7.4.4 原子事务使用ID</a></h5><p>一个单一的AXI ID用于原子事务。
相同的AXI ID用于请求、写响应和读数据。
这个要求意味着主机只能使用可以在<strong>AWID</strong>和<strong>RID</strong>信号上进行信号传递的ID值。</p><p>原子事务不能使用与同时存在的非原子事务所使用的AXI ID值。
这条规则适用于<strong>AR</strong>或<strong>AW</strong>通道上的事务。
这条规则确保了原子事务和非原子事务之间没有排序约束。</p><p>如果一个事务在另一个事务发出之前已完全完成，原子事务和非原子事务可以使用相同的AXI ID值。</p><p>同时存在的多个原子事务不能使用相同的AXI ID值。</p><p>对于使用读数据通道的原子事务，如果接口包括唯一ID信号，则如果<strong>AWIDUNQ</strong>被确认，则必须确认<strong>RIDUNQ</strong>。
有关更多细节，请参见 <em><a href="#a6.2 唯一id">A6.2 唯一id</a></em> 。</p><h5 id=a-ida745-原子事务的请求属性限制a745-原子事务的请求属性限制a><a id="a7.4.5 原子事务的请求属性限制">A7.4.5 原子事务的请求属性限制</a></h5><p>对于原子事务，请求属性适用以下限制：</p><ul><li><strong>AWCACHE</strong> 和 <strong>AWDOMAIN</strong> 可以是接口类型有效的任何组合。请参见 <em><a href="#表 a9.1">表 A9.1</a></em> 。</li><li><strong>AWSNOOP</strong> 必须设置为全零。如果 <strong>AWSNOOP</strong> 有其他值，则 <strong>AWATOP</strong> 必须全为零。</li><li><strong>AWLOCK</strong> 必须不被声明为独占访问。</li></ul><h5 id=a-ida746-原子事务信号a746-原子事务信号a><a id="a7.4.6 原子事务信号">A7.4.6 原子事务信号</a></h5><p>为了支持原子事务，<strong>AWATOP</strong> 应该被添加到一个接口中。</p><p><a id="表 a7.7">表 A7.7</a> id信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWATOP</strong></td><td>6</td><td>0x00</td><td>指示原子事务的类型和字节顺序。</td></tr></tbody></table><p>AWATOP的编码如 <em><a href="#表 a7.8">表 A7.8</a></em> 和 <em><a href="#表 a7.9">表 A7.9</a></em> 所示</p><p><em><a href="#表 a7.8">表 A7.8</a></em> <strong>AWATOP</strong>编码</p><table><thead><tr><th><strong>AWATOP[5:0]</strong></th><th>描述</th></tr></thead><tbody><tr><td>0b000000</td><td>非原子操作</td></tr><tr><td>0b01exxx</td><td>原子存储 （AtomicStore）</td></tr><tr><td>0b10exxx</td><td>原子加载 （AtomicLoad）</td></tr><tr><td>0b110000</td><td>原子交换 （AtomicSwap）</td></tr><tr><td>0b110001</td><td>原子比较 （AtomicCompare）</td></tr></tbody></table><p>对于原子存储（AtomicStore）和原子加载（AtomicLoad）事务，<strong>AWATOP[3]</strong>表示原子操作所需的字节序：</p><ul><li>当未断言时，此位表示操作为小端。</li><li>当断言时，此位表示操作为大端。</li></ul><p><strong>AWATOP[3]</strong>的值仅适用于算术操作，对于按位逻辑操作则被忽略。</p><p>对于原子存储（AtomicStore）和原子加载（AtomicLoad）事务，
<em><a href="#表 a7.9">表 A7.9</a></em> 显示了低位<strong>AWATOP[2:0]</strong>信号上的操作编码。</p><p><a id="表 a7.9">表 A7.9</a> 低位<strong>AWATOP[2:0]</strong>编码</p><table><thead><tr><th><strong>AWATOP[2:0]</strong></th><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>0b000</td><td>ADD</td><td>加法</td></tr><tr><td>0b001</td><td>CLR</td><td>位清零</td></tr><tr><td>0b010</td><td>EOR</td><td>异或</td></tr><tr><td>0b011</td><td>SET</td><td>位设定</td></tr><tr><td>0b100</td><td>SMAX</td><td>有符号最大值</td></tr><tr><td>0b101</td><td>SMIN</td><td>有符号最小值</td></tr><tr><td>0b110</td><td>UMAX</td><td>无符号最大值</td></tr><tr><td>0b111</td><td>UMIN</td><td>无符号最小值</td></tr></tbody></table><h5 id=a-ida747-事务结构a747-事务结构a><a id="a7.4.7 事务结构">A7.4.7 事务结构</a></h5><p>对于AtomicLoad、AtomicSwap和AtomicCompare事务，事务结构如下：</p><ul><li>请求在AW通道上发出。</li><li>相关的事务数据在W通道上发送。</li><li>W通道上所需的写数据传输数量由AWLEN信号决定。</li><li>原子事务请求与原子事务写数据的相对时序未指定。</li><li>从机通过R通道返回原始数据值。</li><li>读取数据传输的数量由<strong>AWLEN</strong>和<strong>AWATOP</strong>信号决定。
对于AtomicCompare操作，如果<strong>AWLEN</strong>指示事务长度大于1，则读取数据传输的数量为<strong>AWLEN</strong>指定数量的一半。</li><li>允许从机在发送读取数据之前等待所有写数据。主机必须能够在未接收任何读取数据的情况下发送所有写数据。</li><li>允许从机在接受任何写数据之前发送所有读取数据。主机必须能够在未接受任何写数据的情况下接受所有读取数据。</li><li>在B通道上返回单个写响应。写响应必须由从机在接收到所有写数据传输并且原子事务的结果可观察后给出。</li></ul><p>AtomicLoad、AtomicSwap和AtomicCompare事务涉及的传输如 <em><a href="#图 a7.3">图 A7.3</a></em> 所示。</p><p><a id="图 a7.3">图 A7.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A7.3_AtomicLoad,_AtomicSwap,_or_AtomicCompare_transaction.png alt></a></p><p>对于AtomicStore事务，事务结构如下：</p><ul><li>请求在AW通道上发出。</li><li>相关的事务数据在W通道上发送。</li><li>W通道上所需的写数据传输次数由<strong>AWLEN</strong>信号决定。</li><li>Atomic事务请求和Atomic事务写数据的相对时序未指定。</li><li>在B通道上返回单个写响应。写响应必须由从机在收到所有写数据传输并且观察到原子事务的结果之后给出。</li></ul><p>涉及AtomicStore事务的传输如 <em><a href="#图 a7.4">图 A7.4</a></em> 所示。</p><p><a id="图 a7.4">图 A7.4
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A7.4_AtomicStore_transaction.png alt></a></p><h5 id=a-ida748-响应信号a748-响应信号a><a id="a7.4.8 响应信号">A7.4.8 响应信号</a></h5><p>写响应指示原子事务对所有必需的观察者可见。</p><p>包含读取响应的原子事务在接收到第一项读取数据时对所有必需的观察者可见。</p><p>主机被允许使用读取或写入响应作为事务对所有必需的观察者可见的指示。</p><p>与操作相关的错误概念是不存在的，例如溢出。一个操作对所有输入组合是完全指定的。</p><p>对于如原子比较等事务，当事务有多个结果时，不会提供事务结果的指示。
为了确定比较和交换指令是否已更新内存位置，必须检查作为事务一部分返回的原始数据值。</p><p>当事务达到不支持原子事务的组件时，可以对原子事务给出错误响应。</p><p>对于原子加载（AtomicLoad）、原子交换（AtomicSwap）和原子比较（AtomicCompare）事务：</p><ul><li>从机必须发送正确数量的读取数据传输，即使写响应是DECERR或SLVERR。</li><li>主机可能会忽略写响应，仅使用随读取数据一起返回的响应。</li></ul><h5 id=a-ida749-原子事务的依赖a749-原子事务的依赖a><a id="a7.4.9 原子事务的依赖">A7.4.9 原子事务的依赖</a></h5><p>对于AtomicLoad，AtomicSwap和AtomicCompare事务，<em><a href="#图 a7.5">图 A7.5</a></em> 显示以下原子事务握手信号依赖关系：</p><ul><li>主机在断言<strong>AWVALID</strong>或<strong>WVALID</strong>之前不应等待从机断言<strong>AWREADY</strong>或<strong>WREADY</strong>。</li><li>从机可以在断言<strong>AWREADY</strong>之前等待<strong>AWVALID</strong>或<strong>WVALID</strong>，或两者。</li><li>从机可以在<strong>AWVALID</strong>或<strong>WVALID</strong>，或者两者被断言之前断言<strong>AWREADY</strong>。</li><li>从机可以在断言<strong>WREADY</strong>之前等待<strong>AWVALID</strong>或<strong>WVALID</strong>，或两者。</li><li>从机可以在<strong>AWVALID</strong>或<strong>WVALID</strong>，或者两者被断言之前断言<strong>WREADY</strong>。</li><li>从机在断言<strong>BVALID</strong>之前必须等待<strong>AWVALID</strong>、<strong>AWREADY</strong>、<strong>WVALID</strong>和<strong>WREADY</strong>被断言。</li><li>从机还必须在断言<strong>BVALID</strong>之前等待<strong>WLAST</strong>被断言，因为写响应<strong>BRESP</strong>必须在写事务的最后一次数据传输后才发出信号。</li><li>从机在断言<strong>BVALID</strong>之前不应等待主机断言<strong>BREADY</strong>。</li><li>主机可以在断言<strong>BREADY</strong>之前等待<strong>BVALID</strong>。</li><li>主机可以在<strong>BVALID</strong>被断言之前断言<strong>BREADY</strong>。</li><li>从机必须在<strong>AWVALID</strong>和<strong>AWREADY</strong>都被断言之后才能断言<strong>RVALID</strong>，以指示有效数据可用。</li><li>从机在断言<strong>RVALID</strong>之前不应等待主机断言<strong>RREADY</strong>。</li><li>主机可以在断言<strong>RREADY</strong>之前等待<strong>RVALID</strong>被断言。</li><li>主机可以在<strong>RVALID</strong>被断言之前断言<strong>RREADY</strong>。</li><li>主机在断言<strong>WVALID</strong>之前不应等待从机断言<strong>RVALID</strong>。</li><li>从机可以在所有写数据传输之前等待<strong>WVALID</strong>被断言，然后再断言<strong>RVALID</strong>。</li><li>主机可以在<strong>RVALID</strong>被断言之前断言<strong>WVALID</strong>。</li></ul><p>在 <em><a href="#图 a7.5">图 A7.5</a></em> 所示的依赖性图中：</p><ul><li>单头箭头指向可以在箭头起始信号之前或之后被断言的信号。</li><li>双头箭头指向必须在箭头起始信号被断言之后才能被断言的信号。</li></ul><p><a id="图 a7.5">图 A7.5
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A7.5_Atomic_transaction_handshake_dependencies.png alt></a></p><h5 id=a-ida7410-原子事务的支持a7410-原子事务的支持a><a id="a7.4.10 原子事务的支持">A7.4.10 原子事务的支持</a></h5><p>Atomic_Transactions属性用于指示一个组件是否支持原子事务。</p><p><a id="表 a7.10">表 A7.10</a> Atomic_Transactions属性</p><table><thead><tr><th>Atomic_Transactions</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持原子事务。</td></tr><tr><td>False</td><td>Y</td><td>不支持原子事务。</td></tr></tbody></table><p>在某些实现中，这将是一个固定的接口属性，而其他实现可能支持在设计时设置该属性。</p><p>如果一个从机或互连组件声明它支持原子事务，那么它必须支持所有操作类型、大小和字节顺序。</p><p><strong>主机支持</strong></p><p>一个支持原子事务的主机组件还可以包括一个机制来抑制原子事务的生成，以确保在不支持原子事务的系统中的兼容性。<br>指定了一个可选的BROADCASTATOMIC引脚。当该存在并未被断言时，主机不会发出原子事务。</p><p><a id="表 a7.11">表 A7.11</a> BROADCASTATOMIC 绑定输入</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>BROADCASTATOMIC</td><td>1</td><td>0b1</td><td>主机绑定输入，用于控制从接口发出的原子事务。</td></tr></tbody></table><p><strong>从机支持</strong></p><p>从机支持原子事务是可选的。<br>如果从机仅支持特定内存类型或特定地址区域的原子事务，则从机必须对其不支持的原子事务给出适当的错误响应。</p><p><strong>互连支持</strong></p><p>互连支持原子事务是可选的。</p><p>如果互连不支持原子事务，则所有连接的主机必须配置为不生成原子事务。</p><p>在支持原子事务的互连中的任何点都可以支持原子事务，包括将原子事务向下传递到从机。</p><p>并非每个地址位置都要求支持原子事务。如果给定地址位置不支持原子事务，则可以对此事务给出适当的错误响应。详见 <em><a href="#a4.3 事务响应">A4.3 事务响应</a></em> 。</p><p>对于设备事务，原子事务必须传递给端点从机。如果从机被配置为指示其不支持原子事务，则互连必须对此事务给出错误响应。
不得将原子事务传递给不支持原子事务的组件。</p><p>对于可缓存事务，互连可以选择：</p><ul><li>在互连内执行原子操作。此方法要求互连执行适当的读取、写入和侦听事务以完成操作。</li><li>如果适当的端点从机被配置为指示其支持原子操作，则互连可以将原子操作传递给从属。</li></ul><h3 id=a-ida第8章-请求操作码a第8章-请求操作码a><a id="a第8章 请求操作码">A第8章 请求操作码</a></h3><hr><ul class=pager><li class=previous><a href=/icer/post/git%E5%B0%8F%E7%9F%A5%E8%AF%86/ data-toggle=tooltip data-placement=top title="Git 小知识">&larr;
Previous Post</a></li><li class=next><a href=/icer/post/amba5-apb-%E7%9F%A5%E8%AF%86%E6%8F%90%E7%BA%B2/ data-toggle=tooltip data-placement=top title="AMBA5 APB 知识提纲">Next
Post &rarr;</a></li></ul><script src=https://giscus.app/client.js data-repo=ICJJ/icer data-repo-id=R_kgDOMWEQRg data-category=General data-category-id=DIC_kwDOMWEQRs4CgyrH data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light data-lang=en crossorigin=anonymous async></script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/icer/tags/ahb title=ahb>ahb
</a><a href=/icer/tags/amba title=amba>amba
</a><a href=/icer/tags/amba5 title=amba5>amba5
</a><a href=/icer/tags/apb title=apb>apb
</a><a href=/icer/tags/axi title=axi>axi
</a><a href=/icer/tags/bus title=bus>bus
</a><a href=/icer/tags/git title=git>git
</a><a href=/icer/tags/html title=html>html
</a><a href=/icer/tags/i2c title=i2c>i2c
</a><a href=/icer/tags/multi-layer-ahb title=multi-layer-ahb>multi-layer-ahb
</a><a href=/icer/tags/nxp title=nxp>nxp
</a><a href=/icer/tags/spi title=spi>spi
</a><a href=/icer/tags/uart title=uart>uart
</a><a href=/icer/tags/%E4%B8%B2%E5%8F%A3 title=串口>串口
</a><a href=/icer/tags/%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91 title=协议翻译>协议翻译
</a><a href=/icer/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF title=大小端>大小端
</a><a href=/icer/tags/%E5%AD%97%E8%8A%82%E5%BA%8F title=字节序>字节序
</a><a href=/icer/tags/%E7%9F%A5%E8%AF%86%E6%8F%90%E7%BA%B2 title=知识提纲>知识提纲</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://zhaozhihan.com>Linda的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:chengjj9527@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/icjj><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/ICJJ><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-gitlab fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://stackoverflow.com/users/26381389><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="ICJJ Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; ICJJ Blog 2024<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/icer/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script><script src=https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js integrity="sha256-Qsk2KRBCN5qVZX7B+8+2IvQl1Aqc723qV1tBCQaVoqo=" crossorigin=anonymous></script><script>(function(){let e="language-plantuml";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.parentNode.insertBefore(t,e.parentNode),e.parentNode.style.display="none"})})()</script></body></html>