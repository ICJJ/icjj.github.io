<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="ICJJ Blog"><meta property="og:type" content="article"><meta property="og:image" content="img/site/小米汽车/原型车壁纸/2880x1280/2880x1280-06.png"><meta property="twitter:image" content="img/site/小米汽车/原型车壁纸/2880x1280/2880x1280-06.png"><meta name=title content="AMBA5 AXI 协议翻译"><meta property="og:title" content="AMBA5 AXI 协议翻译"><meta property="twitter:title" content="AMBA5 AXI 协议翻译"><meta name=description content="AMBA5 AXI的协议翻译"><meta property="og:description" content="AMBA5 AXI的协议翻译"><meta property="twitter:description" content="AMBA5 AXI的协议翻译"><meta property="twitter:card" content="summary"><meta name=keyword content="程建军, chengjianjun, ChengJianjun, , 程建军的网络日志, 程建军的博客, ChengJianjun Blog, 博客, 个人网站, AMBA, FPGA, SPINALHDL, PCIE"><link rel="shortcut icon" href=/icer/img/site/favicon.ico><title>AMBA5 AXI 协议翻译 | 程建军的博客 | ChengJianjun Blog</title>
<link rel=canonical href=/icer/post/amba5-axi-%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91/><link rel=stylesheet href=/icer/css/bootstrap.min.css><link rel=stylesheet href=/icer/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/icer/css/zanshang.css><link rel=stylesheet href=/icer/css/font-awesome.all.min.css><script src=/icer/js/jquery.min.js></script><script src=/icer/js/bootstrap.min.js></script><script src=/icer/js/hux-blog.min.js></script><script src=/icer/js/lazysizes.min.js></script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-FWR2FVFK68"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FWR2FVFK68")}</script><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/icer>ICJJ Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/icer>Posts</a></li><li><a href=/icer/categories/bus/>bus</a></li><li><a href=/icer/categories/tech/>tech</a></li><li><a href=/icer/categories/tips/>tips</a></li><li><a href=/icer/archive/>ARCHIVE</a></li><li><a href=/icer/about/>ABOUT</a></li><li><a href=/icer/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/icer/img/site/%e5%b0%8f%e7%b1%b3%e6%b1%bd%e8%bd%a6/%e5%8e%9f%e5%9e%8b%e8%bd%a6%e5%a3%81%e7%ba%b8/2880x1280/2880x1280-06.png)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/amba5 title=AMBA5>AMBA5
</a><a class=tag href=/tags/axi title=AXI>AXI
</a><a class=tag href=/tags/%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91 title=协议翻译>协议翻译</a></div><h1>AMBA5 AXI 协议翻译</h1><h2 class=subheading></h2><span class=meta>Posted by
程建军
on
Tuesday, April 23, 2024</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=amba-axi-协议规范>AMBA AXI 协议规范</h1><blockquote><p><a href=https://icjj.github.io/icer/document/IHI0022K_amba_axi_protocol_spec.pdf>IHI0022K_amba_axi_protocol_spec.pdf</a></p></blockquote><h2 id=ahb-协议规范>AHB 协议规范</h2><h3 id=a-id引言引言a><a id=引言>引言</a></h3><p>本前言描述了本规范中使用的内容组织和文档约定。</p><h4 id=a-id目标受众目标受众a><a id=目标受众>目标受众</a></h4><p>该规范是为希望熟悉AMBA协议的硬件和软件工程师编写的，旨在设计与AXI协议兼容的系统和模块</p><h4 id=a-id使用本规范使用本规范a><a id=使用本规范>使用本规范</a></h4><p>本规范中的信息分为几个部分，如本节所述：</p><p><strong>A部分 规范</strong></p><ul><li><em><a href="#a第1章 介绍">A第1章 介绍</a></em> ：介绍了本规格中使用的AXI协议架构和术语。</li><li><em><a href="#a第2章 信号列表">A第2章 信号列表</a></em> ：介绍了本规格中使用的AXI协议架构和术语。</li><li><em><a href="#a第3章 传输">A第3章 传输</a></em> ：提供有关AXI协议的基本操作的信息，例如读写事务、通道信号要求以及通道之间的关系。</li><li><em><a href="#a第4章 事务">A第4章 事务</a></em> ：包含有关AXI协议事务的信息，例如事务请求、事务响应、以及读写数据。</li><li><em><a href="#a第5章 请求属性">A第5章 请求属性</a></em> ：描述内存属性、内存类型、内存保护和多个区域接口。</li><li><em><a href="#a第6章 事务标识和顺序">A第6章 事务标识和顺序</a></em> ：描述事务ID信号、请求顺序、写数据和响应顺序 以及读数据顺序。</li><li><em><a href="#a第7章 原子操作">A第7章 原子操作</a></em> ：包含关于原子访问、单一和多副本原子性及独占访问的信息。</li><li><em><a href="#a第8章 请求操作码">A第8章 请求操作码</a></em> ：提供有关操作码字段的信息，该字段描述请求的功能并指示如何由从机处理。</li><li><em><a href="#a第9章 缓存">A第9章 缓存</a></em> ：描述了AXI协议中的缓存，包括I/O一致性、缓存可共享行以及使用特定事务管理缓存分配。</li><li><em><a href="#a第10章 缓存维护">A第10章 缓存维护</a></em> 提供有关使用缓存维护操作来控制缓存内容的信息，以确保数据的可见性。</li><li><em><a href="#a第11章 额外请求限定">A第11章 额外请求限定</a></em> ：描述AXI协议中的额外请求限定符，例如非安全访问标识符(NSAID)基于Page的硬件属性(PBHA)和子系统标识符。</li><li><em><a href="#a第12章 其他写事务">A第12章 其他写事务</a></em> ：包含有关AXI协议中其他写事务的信息，例如WriteDeferrable和WriteZero。</li><li><em><a href="#a第13章 系统监控、调试和用户扩展">A第13章 系统监控、调试和用户扩展</a></em> ：描述了AXI协议的系统调试、跟踪和监控功能，例如内存系统资源分区和监控（MPAM）、内存标记扩展（MTE）以及用户回环和用户定义信号。</li><li><em><a href="#a第14章 未转换事务">A第14章 未转换事务</a></em> ：描述了AXI如何支持在系统内存管理单元（SMMU）上游组件中使用虚拟地址和转换缓存提示</li><li><em><a href="#a第15章 虚拟内存消息分布">A第15章 虚拟内存消息分布</a></em> ：描述AXI如何支持分布式系统MMU使用分布式虚拟内存DVM消息来维护虚拟内存系统中的所有MMU。</li><li><em><a href="#a第16章 唤醒信号">A第16章 唤醒信号</a></em> ：描述可用于接口时钟或电源控制的唤醒信号。</li><li><em><a href="#a第17章 接口和数据保护">A第17章 接口和数据保护</a></em> ：解释如何使用poison信号和奇偶校验信号来保护数据或接口。</li></ul><p><strong>B部分 附录</strong></p><ul><li><em><a href="#b1 接口类">B1 接口汇总</a></em> ：对所有AMBA 5 AXI接口类的描述，包括信号和属性表。</li><li><em><a href="#b2 约束总结">B2 约束总结</a></em> ：AXI协议中ID约束的总结。</li><li><em><a href="#b3 版本">B3 版本</a></em> ：本次规格与上一版本之间变化的详细信息。</li></ul><p><strong>C部分 术语</strong></p><ul><li><em><a href="#c1 术语表">C1 术语表</a></em></li></ul><h4 id=a-id约定约定a><a id=约定>约定</a></h4><p>本节描述了本规格使用的约定：</p><ul><li><a href=#排版>排版</a></li><li><a href=#时序图>时序图</a></li><li><a href=#信号>信号</a></li><li><a href=#数字>数字</a></li></ul><h5 id=a-id排版排版a><a id=排版>排版</a></h5><p>排版惯例是：</p><ul><li>italic(斜体)：突出重要笔记，介绍特殊术语，并指示内部交叉引用和引用。</li><li>bold(粗体)：表示信号名称，并用于描述性列表中的术语(如果适用)。</li><li>monospace(等宽)：该字体用于汇编程序语法描述、伪代码和源代码示例。</br>同时用于主要文本中的指令助记符，以及对出现在汇编程序语法描述、伪代码和源代码示例中的其他项目的引用。</li><li>SMALL CAPITALS(小写大写字母)：用于几个具有特定技术含义的术语。</li></ul><h5 id=a-id时序图时序图a><a id=时序图>时序图</a></h5><p>在时序图中使用的组件在 <em><a href="#图 1">图 1</a></em> 中进行了说明。当变化发生时，会有明确的标签。请不要假设图中没有明确的时序信息</p><p><a id="图 1">图 1</a>
<img src=https://icjj.github.io/icer/img/post/axi/Figure1_Key_to_timing_diagram_conventions.png alt></p><p>时序图有时将单比特信号同时显示为高和低，它们看起来与 <em><a href="#图 1">图 1</a></em> 显示的总线变化类似。
如果时序图以这种方式显示单比特信号，则其值不会影响附带的描述。</p><h5 id=a-id信号信号a><a id=信号>信号</a></h5><p>下面是关于信号方面的约定：</p><ul><li>信号电平：</br>断言信号的水平取决于信号是高有效还是低有效，断言意味着<ul><li>HIGH：表示高电平有效。</li><li>LOW：表示低电平有效。</li></ul></li><li>小写n：出现在信号名的开始或结束都表示低电平有效。</li><li>小写x：信号名称的第二个字母表示读取和写入的统称。例如<strong>AxCACHE</strong>既指<strong>ARCACHE</strong>信号也指<strong>AWCACHE</strong>信号。</li></ul><h5 id=a-id数字数字a><a id=数字>数字</a></h5><p>数字通常以十进制书写。二进制数字以0b开头，十六进制数字以0x开头。
在这两种情况下，前缀和相关的值都以monospace字体书写。例如0xFFFF0000。
为了提高可读性，较长的数字可以在每四个字符之间加下划线分隔。
例如0xFFFF_0000_0000_0000，在解释数字的值时忽略任何下划线。</p><h5 id=a-id伪代码描述伪代码描述a><a id=伪代码描述>伪代码描述</a></h5><p>本规范使用一种伪代码形式来提供对指定功能的精确描述。
该伪代码以等宽字体书写。伪代码语言在Arm®架构参考手册中描述，适用于A型架构。</p><h4 id=a-id额外阅读额外阅读a><a id=额外阅读>额外阅读</a></h4><p>本节列出了Arm和第三方的出版物。</p><p>查看Arm开发者网站<a href=http://developer.arm.com>http://developer.arm.com</a> 以获取Arm文档的访问权限。</p><p><a id=[1]>[1]</a> AMBA® AXI and ACE Protocol Specification. (ARM IHI 0022 H.c).<br><a id=[2]>[2]</a> AMBA® AXI Protocol Specification. (ARM IHI 0022 J).<br><a id=[3]>[3]</a> Arm® Architecture Reference Manual for A-profile architecture. (ARM DDI 0487).<br><a id=[4]>[4]</a> Arm® Realm Management Extension (RME) System Architecture. (ARM DEN 0129).<br><a id=[5]>[5]</a> AMBA® 5 CHI Architecture Specification. (ARM IHI 0050).<br><a id=[6]>[6]</a> Arm® Architecture Reference Manual Supplement, Memory System Resource Partitioning and Monitoring<br>(MPAM), for A-profile architecture. (ARM DDI 0598).<br><a id=[7]>[7]</a> Arm® System Memory Management Unit Architecture Specification, SMMU architecture version 3. (ARM IHI0070)</p><h4 id=a-id反馈反馈a><a id=反馈>反馈</a></h4><ul><li>请通过填写 <em><a href=https://developer.arm.com/feedback/survey>https://developer.arm.com/feedback/survey</a></em>
上的表单，提交关于Arm产品文档的反馈意见。</li><li>有关Arm产品、架构和规格的技术反馈、问题或咨询，请在 <em><a href=https://support.developer.arm.com/my-cases/open-case/>https://support.developer.arm.com/my-cases/open-case/</a></em>
上提交支持请求。</li></ul><h3 id=a-ida第1章-介绍a第1章-介绍a><a id="a第1章 介绍">A第1章 介绍</a></h3><p>本章介绍了AXI协议的架构和本规范中使用的术语。</p><p>它包含以下部分：</p><ul><li><em><a href="#1.1 关于axi协议">1.1 关于AXI协议</a></em></li><li><em><a href="#1.2 axi架构">1.2 AXI架构</a></em></li><li><em><a href="#1.3 术语">1.3 术语</a></em></li></ul><h4 id=a-ida11-关于axi协议a11-关于axi协议a><a id="a1.1 关于axi协议">A1.1 关于AXI协议</a></h4><p>AXI协议支持高性能、高频率的系统设计，用于主机与从机之间的通信。</p><p>AXI协议的特点包括：</p><ul><li>适用于高带宽和低延迟的设计。</li><li>无需使用复杂的桥接器，提供高频率操作。</li><li>该协议满足广泛组件的接口要求。</li><li>适用于具有高首次访问延迟的内存控制器。</li><li>提供互联架构实施的灵活性。</li><li>向后兼容AHB和APB接口。</li></ul><p>AXI协议的关键特性包括：</p><ul><li>独立的地址/控制和数据阶段。</li><li>支持使用字节时钟的非对齐数据传输。</li><li>仅发出起始地址的基于突发的事务。</li><li>分开的写和读数据通道，可以提供低成本的直接内存访问（DMA）。</li><li>支持发出多个未完成的地址。</li><li>支持无序事务完成。</li><li>允许轻松添加寄存器阶段以提供时序闭合。</li></ul><p>有关本规范的前期版本，请参见 <sup><em><a href=#[1]>[1]</a></em> </sup>和 <sup><em><a href=#[2]>[2]</a></em> </sup>。</p><h4 id=a-ida12-axi架构a12-axi架构a><a id="a1.2 axi架构">A1.2 AXI架构</a></h4><p>AXI协议是基于事务的，定义了五个独立的通道：</p><ul><li>写请求，其信号名称以AW开头</li><li>写数据，其信号名称以W开头</li><li>写响应，其信号名称以B开头</li><li>读请求，其信号名称以AR开头</li><li>读数据，其信号名称以R开头</li></ul><p>请求通道携带控制信息，描述要传输数据的性质。这个称为请求。</p><p>数据在主机和从机之间使用以下方式传输：</p><ul><li>写数据通道将数据从主机传输到从机。在写事务中，从机使用写响应通道向主机发出表示完成传输的信号。</li><li>读数据通道将数据从从机传输到主机。</li></ul><p>AXI协议：</p><ul><li>允许在实际数据传输之前发出地址信息。</li><li>支持多个未决事务。</li><li>支持事务的乱序完成。</li></ul><p><em><a href="#图 a1.1">图 A1.1</a></em> 展示了写事务如何使用写请求、写数据和写响应通道。</p><p><a id="图 a1.1">图 A1.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A1.1_Channel_architecture_of_writes.png alt></a></p><p><em><a href="#图 a1.1">图 a1.1</a></em></p><p><a id="图 a1.2">图 A1.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A1.2_Channel_architecture_of_reads.png alt></a></p><h5 id=a-ida121-通道定义a121-通道定义a><a id="a1.2.1 通道定义">A1.2.1 通道定义</a></h5><p>每个独立的五个通道由一组信息信号以及<strong>VALID</strong>和<strong>READY</strong>信号组成，
提供双向握手机制。信息源使用<strong>VALID</strong>信号来表示通道上何时有有效的地址、数据或控制信息可用。
目的地使用<strong>READY</strong>信号来表示何时可以接受这些信息。
读数据通道和写数据通道还包括<strong>LAST</strong>信号，以指示在事务中最后一个数据项的传输。</p><h6 id=a-ida1211-读写请求通道a1211-读写请求通道a><a id="a1.2.1.1 读写请求通道">A1.2.1.1 读写请求通道</a></h6><p>存在单独的写请求和读请求通道。适当的请求通道携带一个事务所需的所有地址和控制信息。</p><h6 id=a-ida1212-写数据通道a1212-写数据通道a><a id="a1.2.1.2 写数据通道">A1.2.1.2 写数据通道</a></h6><p>写数据通道将写数据从主机传输到从机，包括：</p><ul><li>数据信号<strong>WDATA</strong>，可以为8、16、32、64、128、256、512或1024位宽。宽度使用DATA_WIDTH属性表示。</li><li>每8个数据位都有一个字节通道时钟信号，指示有效的数据字节。</li></ul><p>写数据通道信息始终被视为缓存，这样主机可以在没有从机确认先前写操作的情况下执行写事务。</p><h6 id=a-ida1213-写响应通道a1213-写响应通道a><a id="a1.2.1.3 写响应通道">A1.2.1.3 写响应通道</a></h6><p>从机使用写响应通道来响应写事务。
所有写事务都需要在写响应通道上进行完成信号传输。
如 <a href="#图 a1.1">图 A1.1</a>所示，只有在完整事务中才会发出完成信号，而不是在事务中的每个数据传输中发出。</p><h6 id=a-ida1214-读数据通道a1214-读数据通道a><a id="a1.2.1.4 读数据通道">A1.2.1.4 读数据通道</a></h6><p>读取数据通道携带从从机到主机的读取数据和读取响应信息，包括：</p><ul><li>数据信号<strong>RDATA</strong>，其宽度可以是8、16、32、64、128、256、512或1024位。宽度通过DATA_WIDTH属性表示。</li><li>表示读取事务完成状态的读取响应信号。</li></ul><h5 id=a-ida122-接口与互联a122-接口与互联a><a id="a1.2.2 接口与互联">A1.2.2 接口与互联</a></h5><p>一个典型的系统由多个主机和从机组成，这些设备通过某种形式的连接相互连接，如 <em><a href="#图 a1.3">图 A1.3</a></em> 所示</p><p><a id="图 a1.3">图 A1.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A1.3_Interface_and_interconnect.png alt></a></p><p>AXI协议为以下接口之间提供了单一的接口定义：</p><ul><li>主机与互连之间</li><li>从机与互连之间</li><li>主机与从机之间</li></ul><p>此接口定义支持许多不同的互连实现。</p><p>设备之间的互连相当于另一个具有对称的主机和从机端口的设备，实际的主机和从机通过这一互联可以连接在一起。</p><h6 id=a-ida1221-典型系统拓扑a1221-典型系统拓扑a><a id="a1.2.2.1 典型系统拓扑">A1.2.2.1 典型系统拓扑</a></h6><p>大多数系统使用三种互连拓扑之一：</p><ul><li>共享请求和数据通道。</li><li>共享请求通道和多个数据通道。</li><li>多层次，具有多个请求和数据通道。</li></ul><p>在大多数系统中，请求通道的带宽需求显著低于数据通道的带宽需求。
这种系统可以通过使用一个共享请求通道和多个数据通道来实现系统性能和互连复杂性之间的良好平衡，从而启用并行数据传输。</p><h6 id=a-ida123-寄存器切片a123-寄存器切片a><a id="a1.2.3 寄存器切片">A1.2.3 寄存器切片</a></h6><p>每个AXI通道仅以单一方向传输信息，并且架构不要求通道之间有任何固定关系。
这些特性意味着可以在任意通道的几乎任何位置插入寄存器切片，代价是增加一个周期的延迟。
这些特性使以下情况成为可能：</p><ul><li>在延迟周期和最大操作频率之间进行权衡。</li><li>处理器与高性能内存之间的直接快速连接，同时使用简单的寄存器切片来隔离到性能要求较低外设的较长路径。</li></ul><h4 id=a-ida13-术语a13-术语a><a id="a1.3 术语">A1.3 术语</a></h4><p>本节总结了本规范中使用的术语，这些术语在 <em><a href="#c1 术语表">C1 术语表</a></em> 中或其他地方有定义。
在适当的情况下，本节中列出的术语链接到相应的术语表定义。</p><h5 id=a-ida131-axi组件和拓扑a131-axi组件和拓扑a><a id="a1.3.1 axi组件和拓扑">A1.3.1 AXI组件和拓扑</a></h5><p>以下术语描述了AXI组件：</p><ul><li><em><a href=#组件>组件</a></em></li><li><em><a href=#主机组件>主机组件</a></em></li><li><em><a href=#从机组件>从机组件</a></em> ，包括内存从机组件和外设从机组件</li><li><em><a href=#互联组件>互联组件</a></em></li></ul><p>对于特定的AXI事务，<em><a href=#上游>上游</a></em> 和 <em><a href=#下游>下游</a></em> 指的是AXI拓扑中AXI组件的相对位置。</p><h5 id=a-ida132-axi事务与传输a132-axi事务与传输a><a id="a1.3.2 axi事务与传输">A1.3.2 AXI事务与传输</a></h5><p>AXI传输是在AXI通道上一个周期内的通信。</p><p>AXI事务是AXI主机与AXI从机进行通信所需的传输集合。</p><p>例如，读事务由请求传输和一个或多个读数据传输组成。</p><h5 id=a-ida133-缓存与缓存操作a133-缓存与缓存操作a><a id="a1.3.3 缓存与缓存操作">A1.3.3 缓存与缓存操作</a></h5><p>本规范没有定义任何缓存参考书中定义的标准缓存术语。</p><p>然而，<em><a href=#缓存>缓存</a></em> 和 <em><a href=#缓存行>缓存行</a></em> 的词汇条目澄清了这些术语在本文档中的使用方式。</p><h5 id=a-ida134-时间描述a134-时间描述a><a id="a1.3.4 时间描述">A1.3.4 时间描述</a></h5><p>AXI规范使用了 <em><a href=#时间描述>时间描述</a></em> 的解释。</p><h3 id=a-ida第2章-信号列表a第2章-信号列表a><a id="a第2章 信号列表">A第2章 信号列表</a></h3><p>本章列出了本规范中描述的所有信号。
有些通道和信号是可选的，因此并不包含在每个接口中。
每个信号名称包含一个超链接，指向定义该信号的章节。
奇偶校验信号不包含在本章中，但在 <em><a href="#a17.2.3 校验检查信号">A17.2.3 校验检查信号</a></em> 中列出。</p><p>信号根据通道和类别分组，如以下各节所述。</p><ul><li><em><a href="#a2.1 写通道">A2.1 写通道</a></em></li><li><em><a href="#a2.2 读通道">A2.2 读通道</a></em></li><li><em><a href="#a2.3 侦听通道">A2.3 侦听通道</a></em></li><li><em><a href="#a2.4 接口信号">A2.4 接口信号</a></em></li></ul><h4 id=a-ida21-写通道a21-写通道a><a id="a2.1 写通道">A2.1 写通道</a></h4><p>写通道用于传输请求、数据和响应以进行写事务以及一些其他无数据事务。</p><h5 id=a-ida211-写请求通道a211-写请求通道a><a id="a2.1.1 写请求通道">A2.1.1 写请求通道</a></h5><p>写请求通道传输使用写通道的事务所需的所有地址和控制信息。该通道上的信号前缀为AW。</p><p><a id="表 a2.1">表 A2.1</a> 写请求通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>AWREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>AWID</strong></td><td>ID_W_WIDTH</td><td>主机</td><td>事务ID</td></tr><tr><td><strong>AWADDR</strong></td><td>ADDR_WIDTH</td><td>主机</td><td>地址</td></tr><tr><td><strong>AWREGION</strong></td><td>4</td><td>主机</td><td>区域ID</td></tr><tr><td><strong>AWLEN</strong></td><td>8</td><td>主机</td><td>长度</td></tr><tr><td><strong>AWSIZE</strong></td><td>3</td><td>主机</td><td>大小</td></tr><tr><td><strong>AWBURST</strong></td><td>2</td><td>主机</td><td>突发属性</td></tr><tr><td><strong>AWLOCK</strong></td><td>1</td><td>主机</td><td>锁定</td></tr><tr><td><strong>AWCACHE</strong></td><td>4</td><td>主机</td><td>缓存属性</td></tr><tr><td><strong>AWPROT</strong></td><td>3</td><td>主机</td><td>访问属性</td></tr><tr><td><strong>AWNSE</strong></td><td>1</td><td>主机</td><td>RME的非安全扩展bit</td></tr><tr><td><strong>AWQOS</strong></td><td>4</td><td>主机</td><td>Qos ID</td></tr><tr><td><strong>AWUSER</strong></td><td>USER_REQ_WIDTH</td><td>主机</td><td>用户写请求</td></tr><tr><td><strong>AWDOMAIN</strong></td><td>2</td><td>主机</td><td>可共享域</td></tr><tr><td><strong>AWSNOOP</strong></td><td>AWSNOOP_WIDTH</td><td>主机</td><td>操作码</td></tr><tr><td><strong>AWSTASHNID</strong></td><td>11</td><td>主机</td><td>Stash 节点 ID</td></tr><tr><td><strong>AWSTASHNIDEN</strong></td><td>1</td><td>主机</td><td>Stash 节点 ID 使能</td></tr><tr><td><strong>AWSTASHLPID</strong></td><td>5</td><td>主机</td><td>Stash 逻辑处理器 ID</td></tr><tr><td><strong>AWSTASHLPIDEN</strong></td><td>1</td><td>主机</td><td>Stash 逻辑处理器 ID 使能</td></tr><tr><td><strong>AWTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr><tr><td><strong>AWLOOP</strong></td><td>LOOP_W_WIDTH</td><td>主机</td><td>环回信号</td></tr><tr><td><strong>AWMMUVALID</strong></td><td>1</td><td>主机</td><td>MMU有效</td></tr><tr><td><strong>AWMMUSECSID</strong></td><td>SECSID_WIDTH</td><td>主机</td><td>MMU安全流 ID</td></tr><tr><td><strong>AWMMUSID</strong></td><td>SID_WIDTH</td><td>主机</td><td>MMU流ID</td></tr><tr><td><strong>AWMMUSSIDV</strong></td><td>1</td><td>主机</td><td>MMU子流ID有效</td></tr><tr><td><strong>AWMMUSSID</strong></td><td>SSID_WIDTH</td><td>主机</td><td>MMU子流ID</td></tr><tr><td><strong>AWMMUATST</strong></td><td>1</td><td>主机</td><td>地址转换指示</td></tr><tr><td><strong>AWMMUFLOW</strong></td><td>2</td><td>主机</td><td>MMU flow type</td></tr><tr><td><strong>AWPBHA</strong></td><td>4</td><td>主机</td><td>Page-based 硬件属性</td></tr><tr><td><strong>AWNSAID</strong></td><td>4</td><td>主机</td><td>非安全访问 ID</td></tr><tr><td><strong>AWSUBSYSID</strong></td><td>SUBSYSID_WIDTH</td><td>主机</td><td>子系统 ID</td></tr><tr><td><strong>AWATOP</strong></td><td>6</td><td>主机</td><td>原子事务操作码</td></tr><tr><td><strong>AWMPAM</strong></td><td>MPAM_WIDTH</td><td>主机</td><td>MPAM 写请求</td></tr><tr><td><strong>AWIDUNQ</strong></td><td>1</td><td>主机</td><td>唯一ID</td></tr><tr><td><strong>AWCMO</strong></td><td>AWCMO_WIDTH</td><td>主机</td><td>CMO type</td></tr><tr><td><strong>AWTAGOP</strong></td><td>2</td><td>主机</td><td>内存标签</td></tr><tr><td><strong>AWMECID</strong></td><td>MECID_WIDTH</td><td>主机</td><td>内存加密ID</td></tr></tbody></table><h5 id=a-ida212-写数据通道a212-写数据通道a><a id="a2.1.2 写数据通道">A2.1.2 写数据通道</a></h5><p>写数据通道携带来自主机到从机的写数据和控制信息。该通道上的信号以W为前缀。</p><p><a id="表 a2.2">表 A2.2</a> 写数据通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>WVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>WREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>WDATA</strong></td><td>DATA_WIDTH</td><td>主机</td><td>写数据</td></tr><tr><td><strong>WSTRB</strong></td><td>DATA_WIDTH / 8</td><td>主机</td><td>strobes写</td></tr><tr><td><strong>WTAG</strong></td><td>ceil(DATA_WIDTH/128)*4</td><td>主机</td><td>内存Tag</td></tr><tr><td><strong>WTAGUPDATE</strong></td><td>ceil(DATA_WIDTH/128)</td><td>主机</td><td>内存Tag更新</td></tr><tr><td><strong>WLAST</strong></td><td>1</td><td>主机</td><td>最后写数据标识</td></tr><tr><td><strong>WUSER</strong></td><td>USER_DATA_WIDTH</td><td>主机</td><td>用户写数据</td></tr><tr><td><strong>WPOISON</strong></td><td>ceil(DATA_WIDTH / 64)</td><td>主机</td><td>中毒标识</td></tr><tr><td><strong>WTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr></tbody></table><h4 id=a-ida213写响应通道a写响应通道a><a id=a2.1.3写响应通道>A写响应通道</a></h4><p>写响应通道用于传递从从机到主机的响应，适用于使用写数据通道的事务。该通道上的信号以字母B为前缀。</p><p><a id="表 a2.3">表 A2.3</a> 写响应通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>BVALID</strong></td><td>1</td><td>从机</td><td>有效</td></tr><tr><td><strong>BREADY</strong></td><td>1</td><td>主机</td><td>就绪</td></tr><tr><td><strong>BID</strong></td><td>ID_W_WIDTH</td><td>从机</td><td>事务ID</td></tr><tr><td><strong>BIDUNQ</strong></td><td>1</td><td>从机</td><td>唯一ID</td></tr><tr><td><strong>BRESP</strong></td><td>BRESP_WIDTH</td><td>从机</td><td>写响应</td></tr><tr><td><strong>BCOMP</strong></td><td>1</td><td>从机</td><td>完成标识</td></tr><tr><td><strong>BPERSIST</strong></td><td>1</td><td>从机</td><td>持久响应</td></tr><tr><td><strong>BTAGMATCH</strong></td><td>2</td><td>从机</td><td>内存标签匹配</td></tr><tr><td><strong>BUSER</strong></td><td>USER_RESP_WIDTH</td><td>从机</td><td>用户写响应</td></tr><tr><td><strong>BTRACE</strong></td><td>1</td><td>从机</td><td>跟踪</td></tr><tr><td><strong>BLOOP</strong></td><td>LOOP_W_WIDTH</td><td>从机</td><td>回环</td></tr><tr><td><strong>BBUSY</strong></td><td>2</td><td>从机</td><td>繁忙</td></tr></tbody></table><h4 id=a-ida22-读通道a22-读通道a><a id="a2.2 读通道">A2.2 读通道</a></h4><p>读通道用于传输读取事务、缓存维护操作和DVM完成消息的请求、数据和响应。</p><h5 id=a-ida221-读请求通道a221-读请求通道a><a id="a2.2.1 读请求通道">A2.2.1 读请求通道</a></h5><p>读请求通道携带所有使用读取通道的事务所需的地址和控制信息。该通道上的信号以前缀AR开头。</p><p><a id="表 a2.4">表 A2.4</a> 读请求信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ARVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>ARREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>ARID</strong></td><td>ID_R_WIDTH</td><td>主机</td><td>ID</td></tr><tr><td><strong>ARADDR</strong></td><td>ADDR_WIDTH</td><td>主机</td><td>地址</td></tr><tr><td><strong>ARREGION</strong></td><td>4</td><td>主机</td><td>区域</td></tr><tr><td><strong>ARLEN</strong></td><td>8</td><td>主机</td><td>长度</td></tr><tr><td><strong>ARSIZE</strong></td><td>3</td><td>主机</td><td>大小</td></tr><tr><td><strong>ARBURST</strong></td><td>2</td><td>主机</td><td>突发</td></tr><tr><td><strong>ARLOCK</strong></td><td>1</td><td>主机</td><td>锁定</td></tr><tr><td><strong>ARCACHE</strong></td><td>4</td><td>主机</td><td>缓存属性</td></tr><tr><td><strong>ARPROT</strong></td><td>3</td><td>主机</td><td>访问属性</td></tr><tr><td><strong>ARNSE</strong></td><td>1</td><td>主机</td><td>RME的非安全扩展位</td></tr><tr><td><strong>ARQOS</strong></td><td>4</td><td>主机</td><td>QoS标识</td></tr><tr><td><strong>ARUSER</strong></td><td>USER_REQ_WIDTH</td><td>主机</td><td>用户读请求</td></tr><tr><td><strong>ARDOMAIN</strong></td><td>2</td><td>主机</td><td>共享域</td></tr><tr><td><strong>ARSNOOP</strong></td><td>ARSNOOP_WIDTH</td><td>主机</td><td>操作码</td></tr><tr><td><strong>ARTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr><tr><td><strong>ARLOOP</strong></td><td>LOOP_R_WIDTH</td><td>主机</td><td>环回</td></tr><tr><td><strong>ARMMUVALID</strong></td><td>1</td><td>主机</td><td>MMU有效</td></tr><tr><td><strong>ARMMUSECSID</strong></td><td>SECSID_WIDTH</td><td>主机</td><td>MMU安全流ID</td></tr><tr><td><strong>ARMMUSID</strong></td><td>SID_WIDTH</td><td>主机</td><td>MMU流ID</td></tr><tr><td><strong>ARMMUSSIDV</strong></td><td>1</td><td>主机</td><td>MMU子流ID有效</td></tr><tr><td><strong>ARMMUSSID</strong></td><td>SSID_WIDTH</td><td>主机</td><td>MMU子流ID</td></tr><tr><td><strong>ARMMUATST</strong></td><td>1</td><td>主机</td><td>地址已转换</td></tr><tr><td><strong>ARMMUFLOW</strong></td><td>2</td><td>主机</td><td>MMU flow类型</td></tr><tr><td><strong>ARPBHA</strong></td><td>4</td><td>主机</td><td>Page-based硬件属性</td></tr><tr><td><strong>ARNSAID</strong></td><td>4</td><td>主机</td><td>非安全访问ID</td></tr><tr><td><strong>ARSUBSYSID</strong></td><td>SUBSYSID_WIDTH</td><td>主机</td><td>子系统ID</td></tr><tr><td><strong>ARMPAM</strong></td><td>MPAM_WIDTH</td><td>主机</td><td>带请求的MPAM信息</td></tr><tr><td><strong>ARCHUNKEN</strong></td><td>1</td><td>主机</td><td>分块使能</td></tr><tr><td><strong>ARIDUNQ</strong></td><td>1</td><td>主机</td><td>唯一ID标识</td></tr><tr><td><strong>ARTAGOP</strong></td><td>2</td><td>主机</td><td>内存标签操作码</td></tr><tr><td><strong>ARMECID</strong></td><td>MECID_WIDTH</td><td>主机</td><td>内存加密标识</td></tr></tbody></table><h5 id=a-ida222-读数据通道a222-读数据通道a><a id="a2.2.2 读数据通道">A2.2.2 读数据通道</a></h5><p>读数据通道传输来自从机设备到管理器的读数据和响应。该通道上的信号以R为前缀。</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>RVALID</strong></td><td>1</td><td>从机</td><td>有效</td></tr><tr><td><strong>RREADY</strong></td><td>1</td><td>主机</td><td>就绪</td></tr><tr><td><strong>RID</strong></td><td>ID_R_WIDTH</td><td>从机</td><td>事务ID</td></tr><tr><td><strong>RIDUNQ</strong></td><td>1</td><td>从机</td><td>唯一ID指示</td></tr><tr><td><strong>RDATA</strong></td><td>DATA_WIDTH</td><td>从机</td><td>读取数据</td></tr><tr><td><strong>RTAG</strong></td><td>ceil(DATA_WIDTH/128)*4</td><td>从机</td><td>内存标签</td></tr><tr><td><strong>RRESP</strong></td><td>RRESP_WIDTH</td><td>从机</td><td>读取响应</td></tr><tr><td><strong>RLAST</strong></td><td>1</td><td>从机</td><td>最后读取标识</td></tr><tr><td><strong>RUSER</strong></td><td>USER_DATA_WIDTH + USER_RESP_WIDTH</td><td>从机</td><td>用户的读取数据和响应</td></tr><tr><td><strong>RPOISON</strong></td><td>ceil(DATA_WIDTH / 64)</td><td>从机</td><td>中毒标识</td></tr><tr><td><strong>RTRACE</strong></td><td>1</td><td>从机</td><td>跟踪</td></tr><tr><td><strong>RLOOP</strong></td><td>LOOP_R_WIDTH</td><td>从机</td><td>回环</td></tr><tr><td><strong>RCHUNKV</strong></td><td>1</td><td>从机</td><td>分块有效</td></tr><tr><td><strong>RCHUNKNUM</strong></td><td>RCHUNKNUM_WIDTH</td><td>从机</td><td>分块编号</td></tr><tr><td><strong>RCHUNKSTRB</strong></td><td>RCHUNKSTRB_WIDTH</td><td>从机</td><td>分块 strobe</td></tr><tr><td><strong>RBUSY</strong></td><td>2</td><td>从机</td><td>繁忙</td></tr></tbody></table><h5 id=a-ida23-侦听通道a23-侦听通道a><a id="a2.3 侦听通道">A2.3 侦听通道</a></h5><p>在本规范中，旁路通道仅用于传输DVM消息。</p><h5 id=a-ida231-侦听请求通道a231-侦听请求通道a><a id="a2.3.1 侦听请求通道">A2.3.1 侦听请求通道</a></h5><p>侦听请求通道携带DVM消息请求的地址和控制信息。该通道上的信号具有前缀AC。</p><p><a id="表 a2.6">表 A2.6</a> 侦听请求通道</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ACVALID</strong></td><td>1</td><td>从机</td><td>有效</td></tr><tr><td><strong>ACREADY</strong></td><td>1</td><td>主机</td><td>就绪</td></tr><tr><td><strong>ACADDR</strong></td><td>ADDR_WIDTH</td><td>从机</td><td>地址</td></tr><tr><td><strong>ACVMIDEXT</strong></td><td>4</td><td>从机</td><td>VMID</td></tr><tr><td><strong>ACTRACE</strong></td><td>1</td><td>从机</td><td>跟踪</td></tr></tbody></table><h5 id=a-ida232-侦听响应通道a232-侦听响应通道a><a id="a2.3.2 侦听响应通道">A2.3.2 侦听响应通道</a></h5><p>侦听响应通道承载对DVM消息的响应。该通道上的信号具有前缀CR.</p><p><a id="表 a2.7">表 A2.7</a> 侦听响应通道信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>CRVALID</strong></td><td>1</td><td>主机</td><td>有效</td></tr><tr><td><strong>CRREADY</strong></td><td>1</td><td>从机</td><td>就绪</td></tr><tr><td><strong>CRTRACE</strong></td><td>1</td><td>主机</td><td>跟踪</td></tr></tbody></table><h4 id=a-ida24-接口信号a24-接口信号a><a id="a2.4 接口信号">A2.4 接口信号</a></h4><p>接口级信号是非信道信号。每个接口最多可以有一组信号。</p><h5 id=a-ida241-时钟和复位信号a241-时钟和复位信号a><a id="a2.4.1 时钟和复位信号">A2.4.1 时钟和复位信号</a></h5><p>接口上的所有信号与全局时钟同步，并通过全局复位信号进行复位。</p><p><a id="表 a2.8">表 A2.8</a> 时钟和复位信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ACLK</strong></td><td>1</td><td>时钟源</td><td>全局时钟</td></tr><tr><td><strong>ARESETn</strong></td><td>1</td><td>复位源</td><td>全局复位</td></tr></tbody></table><h5 id=a-ida242-唤醒信号a242-唤醒信号a><a id="a2.4.2 唤醒信号">A2.4.2 唤醒信号</a></h5><p><a id="表 a2.9">表 A2.9</a> 唤醒信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWAKEUP</strong></td><td>1</td><td>主机</td><td>读写通道唤醒。</td></tr><tr><td><strong>WCWAKEUP</strong></td><td>1</td><td>从机</td><td>侦听通道唤醒。</td></tr></tbody></table><h5 id=a-ida243-qos接收信号a243-qos接收信号a><a id="a2.4.3 Qos接收信号">A2.4.3 Qos接收信号</a></h5><p>QoS接受信号可以被从机接口用于指示它接受的请求的最小QoS值。</p><p><a id="表 a2.10">表 A2.10</a> Qos接收信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>VAWQOSACCEPT</strong></td><td>4</td><td>从机</td><td>写请求的Qos值</td></tr><tr><td><strong>VARQOSACCEPT</strong></td><td>4</td><td>从机</td><td>读请求的Qos值</td></tr></tbody></table><h5 id=a-ida244-连贯性连接信号a244-连贯性连接信号a><a id="a2.4.4 连贯性连接信号">A2.4.4 连贯性连接信号</a></h5><p>连贯性连接信号由主机使用，以控制其是否接收AC通道上的DVM消息。</p><p><a id="表 a2.11">表 A2.11</a> 连贯性连接信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>SYSCOREQ</strong></td><td>1</td><td>主机</td><td>连贯性连接请求</td></tr><tr><td><strong>SYSCOACK</strong></td><td>1</td><td>从机</td><td>连贯性连接回应</td></tr></tbody></table><h5 id=a-ida245-接口控制信号a245-接口控制信号a><a id="a2.4.5 接口控制信号">A2.4.5 接口控制信号</a></h5><p>接口控制信号是主机接口的静态输入，可用于配置接口行为。</p><p><a id="表 a2.12">表 A2.12</a> 接口控制信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>BROADCASTATOMIC</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于原子事务</td></tr><tr><td><strong>BROADCASTSHAREABLE</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于可共享事务</td></tr><tr><td><strong>BROADCASTCACHEMAINT</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于维护操作</td></tr><tr><td><strong>BROADCASTCMOPOPA</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于 CleanInvalidPoPA CMO</td></tr><tr><td><strong>BROADCASTPERSIST</strong></td><td>1</td><td>Tie-off</td><td>控制输入用于 CleanSharedPersist and CleanSharedDeepPersist</td></tr></tbody></table><h3 id=a-ida第3章-传输a第3章-传输a><a id="a第3章 传输">A第3章 传输</a></h3><p>本章描述了AXI中使用的通道传输
它包含以下部分：</p><ul><li><em><a href="#a3.1 时钟和复位">A3.1 时钟和复位</a></em></li><li><em><a href="#a3.2 通道握手">A3.2 通道握手</a></em></li><li><em><a href="#a3.3 读写通道">A3.3 读写通道</a></em></li><li><em><a href="#a3.4 通道关系">A3.4 通道关系</a></em></li><li><em><a href="#a3.5 通道握手依赖">A3.5 通道握手依赖</a></em></li><li><em><a href="#a3.6 侦听通道">A3.6 侦听通道</a></em></li></ul><h4 id=a-ida31-时钟和复位a31-时钟和复位a><a id="a3.1 时钟和复位">A3.1 时钟和复位</a></h4><p>本节描述了实现AXI全局时钟和复位信号<strong>ACLK</strong>和<strong>ARESETn</strong>的要求。</p><h5 id=a-ida311-时钟a311-时钟a><a id="a3.1.1 时钟">A3.1.1 时钟</a></h5><p>每个AXI接口都有一个单一的时钟信号<strong>ACLK</strong>。
所有输入信号在<strong>ACLK</strong>的上升沿被采样。
所有输出信号的变化只能在<strong>ACLK</strong>的上升沿之后发生。</p><p>在主机和从机之间，输入和输出信号之间必须没有组合路径。</p><h5 id=a-ida312-复位a312-复位a><a id="a3.1.2 复位">A3.1.2 复位</a></h5><p>AXI协议使用一个单一的低电平有效复位信号<strong>ARESETn</strong>。
复位信号可以异步地被断言，但去分断言只能在<strong>ACLK</strong>上升沿同步进行。
在复位期间，以下接口要求适用：</p><ul><li>主机必须将<strong>AWVALID</strong>、<strong>WVALID</strong>和<strong>ARVALID</strong>驱动为低。</li><li>从机必须将<strong>BVALID</strong>和<strong>RVALID</strong>驱动为低。</li><li>所有其他信号可以被驱动为任何值。</li></ul><p>复位后，主机被允许开始将<strong>AWVALID</strong>、<strong>WVALID</strong>和<strong>ARVALID</strong>
驱动为高的最早时刻是在<strong>ARESETn</strong>高后的<strong>ACLK</strong>上升沿。</p><p><em><a href="#图 a3.1">图 A3.1</a></em> 显示了复位后<strong>AWVALID</strong>、<strong>WVALID</strong>和<strong>ARVALID</strong>
可以被驱动为高的最早时间点 <em>b</em>。</p><p><a id="图 a3.1">图 A3.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.1_Exit_from_reset.png alt></a></p><h4 id=a-ida32-通道握手a32-通道握手a><a id="a3.2 通道握手">A3.2 通道握手</a></h4><p>所有AXI通道使用相同的<strong>VALID</strong>/<strong>READY</strong>握手过程来传输地址、数据和控制信息。
这种双向流控制机制意味着主机和从机都可以控制信息在主机和从机之间移动的速率。
源生成<strong>VALID</strong>信号以指示地址、数据或控制信息可用。
目标生成<strong>READY</strong>信号以指示它可以接受信息。
仅当<strong>VALID</strong>和<strong>READY</strong>信号均为高电平时，传输才会发生。</p><p>在主机和从机之间，输入信号和输出信号之间必须没有组合路径。
<em><a href="#图 a3.2">图 A3.2</a></em> 到 <em><a href="#图 a3.4">图 A3.4</a></em> 展示了握手过程的示例。</p><p>源可以在<strong>READY</strong>被断言之前就断言<strong>VALID</strong>。</p><p>源在边缘1之后呈现信息，并如 <em><a href="#图 a3.2">图 A3.2</a></em> 所示声明<strong>VALID</strong>信号。
目标在边缘2之后声明<strong>READY</strong>信号。
源必须保持其信息稳定，直到在边缘3时发生传输，此时该声明被识别。</p><p><a id="图 a3.2">图 A3.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.2_VALID_before_READY_handshake.png alt></a></p><p>源不能在断言<strong>VALID</strong>之前去等待<strong>READY</strong>被断言。</p><blockquote><p>Note：</br>也就是说源不能依靠等待<strong>READY</strong>被断言之后才去断言<strong>VALID</strong>。</p></blockquote><p>当<strong>VALID</strong>被断言时，它必须保持断言状态直到握手发生，
握手发生在<strong>VALID</strong>和<strong>READY</strong>同时被断言的上升时钟边缘。</p><p>在 <em><a href="#图 a3.3">图 A3.3</a></em> 中，目标在边缘1之后断言<strong>READY</strong>，在地址、数据或控制信息有效之前。
这一确认表明它可以接受信息。源在边缘2之后提供信息并断言<strong>VALID</strong>，然后在边缘3时被识别时进行传输。
在这种情况下，传输发生在一个周期内。</p><p><a id="图 a3.3">图 A3.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.3_READY_before_VALID_handshake.png alt></a></p><p>允许目的在相应的<strong>READY</strong>断言之前等待<strong>VALID</strong>被断言。</p><p>如果<strong>READY</strong>被断言，它被允许<strong>VALID</strong>断言之前去分断言<strong>READY</strong>。
在 <em><a href="#图 a3.4">图 A3.4</a></em> 中，源和目的地恰好都表示它们在边缘1之后可以传送地址、数据或控制信息。
在这种情况下，传输发生在<strong>VALID</strong>和<strong>READY</strong>同时被断言的上升时钟边缘。这意味着传输发生在边缘2。</p><p><a id="图 a3.4">图 A3.4
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.4_VALID_with_READY_handshake.png alt></a></p><p>个别AXI通道握手机制在 <em><a href="#a3.4 通道关系">A3.4 通道关系</a></em> 中描述。</p><blockquote><p>Note：</br></p><ul><li><strong>VALID</strong>不能等待<strong>READY</strong>，</br></li><li><strong>READY</strong>可以等待<strong>VALID</strong>。</li></ul></blockquote><h4 id=a-ida33-读写通道a33-读写通道a><a id="a3.3 读写通道">A3.3 读写通道</a></h4><p>这一部分描述了AXI写通道和读通道。通道如下：</p><ul><li><em><a href="#a3.3.1 写请求通道">A3.3.1 写请求通道</a></em></li><li><em><a href="#a3.3.2 写数据通道">A3..3.2 写数据通道</a></em></li><li><em><a href="#a3.3.3 写响应通道">A3.3.3 写响应通道</a></em></li><li><em><a href="#a3.3.4 读请求通道">A3.3.4 读请求通道</a></em></li><li><em><a href="#a3.3.5 读数据通道">A3.3.5 读数据通道</a></em></li></ul><p>对于使用 <em><a href="#a15.3 dvm 消息">A15.3 dvm 消息</a></em> 的接口，额外有两个通道：</p><ul><li><em><a href="#a3.6.1 侦听请求通道（ac）">A3.6.1 侦听 请求通道（ac）</a></em></li><li><em><a href="#a3.6.2 侦听响应通道（cr）">A3.6.2 侦听响应通道（cr）</a></em></li></ul><h5 id=a-ida331-写请求通道awa331-写请求通道awa><a id="a3.3.1 写请求通道（aw）">A3.3.1 写请求通道（aw）</a></h5><p>写请求通道的控制信号如 <em><a href="#表 a3.1">表 A3.1</a></em> 所示。</p><p><a id="表 a3.1">表 A3.1</a> 写请求通道控制信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWVALID</strong></td><td>1</td><td>主机</td><td>写请求有效</td></tr><tr><td><strong>AWREADY</strong></td><td>1</td><td>从机</td><td>写请求就绪</td></tr></tbody></table><p>当主机驱动有效请求时，可以断言<strong>AWVALID</strong>信号。
当被断言时，<strong>AWVALID</strong>必须保持断言状态，直到从机在上升时钟边缘断言<strong>AWREADY</strong>。</p><p><strong>AWREADY</strong>的默认状态可以是高或低。
建议将<strong>AWREADY</strong>的默认状态设置为高。
当<strong>AWREADY</strong>为高时，从机必须能够接受呈现给它的任何有效请求。</p><p>不建议将<strong>AWREADY</strong>默认设置为低，因为这会强制传输至少需要两个周期，
一个周期用于断言<strong>AWVALID</strong>，另一个周期用于断言<strong>AWREADY</strong>。</p><h5 id=a-ida332-写数据通道wa332-写数据通道wa><a id="a3.3.2 写数据通道（w）">A3.3.2 写数据通道（w）</a></h5><p>写数据通道的控制信号如 <em><a href="#表 a3.2">表 A3.2</a></em> 所示。</p><p><a id="表 a3.2">表 A3.2</a> 写数据通道控制信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>WVALID</strong></td><td>1</td><td>主机</td><td>写数据有效</td></tr><tr><td><strong>WREADY</strong></td><td>1</td><td>从机</td><td>写数据就绪</td></tr><tr><td><strong>WLAST</strong></td><td>1</td><td>主机</td><td>写事务最后一个传输</td></tr></tbody></table><p>在写事务期间，主机只能在其驱动有效写数据时断言<strong>WVALID</strong>信号。
当断言时，<strong>WVALID</strong>必须保持断言状态，
直到从机断言<strong>WREADY</strong>之后的上升时钟边缘。</p><p><strong>WREADY</strong>的默认状态可以是高，但前提是从机始终能够在单个周期内接受写数据。</p><p>主机在驱动事务中的最后写传输时必须断言<strong>WLAST</strong>信号。</p><p>建议对于非活跃的字节通道，将<strong>WDATA</strong>驱动为零。</p><p>未使用<strong>WLAST</strong>的从机可以省略其接口中的输入。
属性WLAST_Present用于确定<strong>WLAST</strong>信号是否存在。</p><p><a id="表 a3.3">表 A3.3</a> WLAST_Present 属性</p><table><thead><tr><th>WLAST_Present</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>WLAST</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>WLAST</strong>不存在</td></tr></tbody></table><h5 id=a-ida333-写响应通道ba333-写响应通道ba><a id="a3.3.3 写响应通道（b）">A3.3.3 写响应通道（b）</a></h5><p>写响应通道的控制信号如 <em><a href="#表 a3.4">表 A3.4</a></em> 所示。</p><p><a id="表 a3.4">表 A3.4</a> 写响应通道控制信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>BVALID</strong></td><td>1</td><td>从机</td><td>写响应信号有效</td></tr><tr><td><strong>BREADY</strong></td><td>1</td><td>主机</td><td>写响应信号就绪</td></tr></tbody></table><p>从机只能在驱动有效写响应时断言<strong>BVALID</strong>信号。
当断言时，<strong>BVALID</strong>必须保持断言状态，
直到主机断言<strong>BREADY</strong>后的上升时钟边缘。</p><p><strong>BREADY</strong>BREADY的默认状态可以是高电平，但是前提是主机必须始终能在一个周期内接受写响应。</p><h5 id=a-ida334-读请求通道a334-读请求通道a><a id="a3.3.4 读请求通道">A3.3.4 读请求通道</a></h5><p>读取请求通道的控制信号如 <em><a href="#表 a3.5">表 A3.5</a></em> 所示。</p><p><a id="表 a3.5">表 A3.5</a> 读请求控制信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ARVALID</strong></td><td>1</td><td>主机</td><td>读请求有效</td></tr><tr><td><strong>ARREADY</strong></td><td>1</td><td>从机</td><td>读请求就绪</td></tr></tbody></table><p>主机只能在发出有效读请求时断言<strong>ARVALID</strong>信号。
一旦断言，<strong>ARVALID</strong>必须保持断言状态，直到从机在上升时钟边缘断言<strong>ARREADY</strong>信号。</p><p><strong>ARREADY</strong>的默认状态可以是高或低。
建议将<strong>ARREADY</strong>的默认状态设置为高。
如果<strong>ARREADY</strong>为高，则从机必须能够接受任何呈现给它的有效读请求。</p><p>不建议将<strong>ARREADY</strong>设为低，因为这会使传输至少需要两个周期，一个用于将<strong>ARVALID</strong>置为有效，
另一个用于将<strong>ARREADY</strong>置为有效</p><h5 id=a-ida235-读数据通道ra235-读数据通道ra><a id="a2.3.5 读数据通道（r）">A2.3.5 读数据通道（r）</a></h5><p>读取数据通道的控制信号如 <em><a href="#表 a3.6">表 A3.6</a></em> 所示</p><p><a id="表 a3.6 读数据通道控制信号">表 A3.6 读数据通道控制信号</a></p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>RVALID</strong></td><td>1</td><td>从机</td><td>读数据有效</td></tr><tr><td><strong>RREADY</strong></td><td>1</td><td>主机</td><td>读数据就绪</td></tr><tr><td><strong>RLAST</strong></td><td>1</td><td>从机</td><td>读事务中的最后一个传输</td></tr></tbody></table><p>从机仅在驱动读取数据通道上的有效信号时才能断言<strong>RVALID</strong>信号。
当<strong>RVALID</strong>被断言时，它必须保持断言状态，直到主机断言<strong>ARREADY</strong>RREADY后的上升时钟边缘。
即使从机只有一个读取数据源，它也必须仅在响应请求时断言<strong>RVALID</strong>信号。</p><p>主机使用信号<strong>RREADY</strong>指示它接受数据。
<strong>RREADY</strong>的默认状态可以是高，但只有在主机能够在开始读取事务且立即接受读取数据时。</p><p>每当从机驱动事务中的最终读取传输时，必须断言<strong>RLAST</strong>信号。
建议对不活动的字节通道将<strong>RDATA</strong>驱动为零。</p><p>不使用<strong>RLAST</strong>的主机可以从其接口中省略该输入。属性RLAST_Present用于确定<strong>RLAST</strong>信号是否存在。</p><p><a id="表 a3.7">表 A3.7</a> RLAST_Present 属性</p><table><thead><tr><th>RLAST_Present</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>RLAST</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>RLAST</strong>不存在</td></tr></tbody></table><h4 id=a-ida34-通道关系a34-通道关系a><a id="a3.4 通道关系">A3.4 通道关系</a></h4><p>AXI协议要求保持以下关系：</p><ul><li>写响应必须始终跟随写事务中的最后一次写传输。</li><li>读数据和读响应必须始终跟随读请求。</li><li>通道握手必须符合 <em><a href="#a3.5 通道握手依赖关系">A3.5 通道握手依赖关系</a></em> 定义。</li><li>当主机发出写请求时，必须能够提供该事务的所有写数据，而不依赖于该主机的其他事务。</li><li>当主机已发出写请求并提供所有写数据时，必须能够接受该事务的所有响应，而不依赖于该主机的其他事务。</li><li>当主机已发出读请求时，必须能够接受该事务的所有读数据，而不依赖于该主机的其他事务。</li></ul><blockquote><p>Note：</br>主机可以依赖于使用相同ID的事务按顺序返回读数据，因此主机只需要足够的存储空间来存储具有不同ID的事务的读数据。</p></blockquote><ul><li>主机被允许在发出另一个事务请求之前等待一个事务完成。</li><li>从机被允许在接受或发出另一个事务的传输之前等待一个事务完成。</li><li>从机不能因带有前导写数据的事务而阻止接受无数据的写请求。</li></ul><p>该协议未定义通道之间的其他关系。</p><p>缺乏关系意味着写数据可以在写请求之前出现在接口处。
如果写请求通道包含比写数据通道更多的寄存器级别，就会发生这种情况。
同样，写数据可能在与写请求相同的周期内出现。</p><p>当互连需要确定目标地址空间或从机空间时，必须重新对齐请求和写数据。
此重新对齐是为了确保写数据仅向被标记为有效的从机发送。</p><h4 id=a-ida35-通道握手依赖关系a35-通道握手依赖关系a><a id="a3.5 通道握手依赖关系">A3.5 通道握手依赖关系</a></h4><p>通道之间存在写、读和侦听事务的依赖关系。这些在下面的章节中进行了描述，并包含依赖图，其中：</p><ul><li>单箭头指向可以在箭头起始信号之前或之后被断言的信号。</li><li>双箭头指向必须在箭头起始信号断言之后才能被断言的信号。</li></ul><h5 id=a-ida351-写事务依赖a351-写事务依赖a><a id="a3.5.1 写事务依赖">A3.5.1 写事务依赖</a></h5><p>对于写通道上的事务， <em><a href="#图 a3.5">图 A3.5</a></em> 显示了握手信号的依赖关系。规则如下：</p><ul><li><a id=a3.5.1.1>A3.5.1.1</a> 主机在断言<strong>AWVALID</strong>或<strong>WVALID</strong>
之前不得等待从机断言<strong>AWREADY</strong>或<strong>WREADY</strong>。这适用于事务中的每个写数据传输。</li><li><a id=a3.5.1.2>A3.5.1.2</a> 从机可以在断言<strong>AWREADY</strong>之前等待<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者。</li><li><a id=a3.5.1.3>A3.5.1.3</a> 从机可以在<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者被断言之前断言<strong>AWREADY</strong>。</li><li><a id=a3.5.1.4>A3.5.1.4</a> 从机可以在断言<strong>WREADY</strong>之前等待<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者。</li><li><a id=a3.5.1.5>A3.5.1.5</a> 从机可以在<strong>AWVALID</strong>或<strong>WVALID</strong>，
或两者被断言之前断言<strong>WREADY</strong>。</li><li><a id=a3.5.1.6>A3.5.1.6</a> 从机必须在断言<strong>BVALID</strong>之前等待
<strong>AWVALID</strong>、<strong>AWREADY</strong>、<strong>WVALID</strong>和<strong>WREADY</strong>被断言。</li><li><a id=a3.5.1.7>A3.5.1.7</a> 从机还必须在断言<strong>BVALID</strong>之前等待<strong>WLAST</strong>被断言。
这是因为写响应<strong>BRESP</strong>必须在写事务的最后一次数据传输之后发送信号。</li><li><a id=a3.5.1.8>A3.5.1.8</a> 从机不得在断言<strong>BVALID</strong>之前等待主机断言<strong>BREADY</strong>。</li><li><a id=a3.5.1.9>A3.5.1.9</a> 主机可以在断言<strong>BREADY</strong>之前等待<strong>BVALID</strong>。</li><li><a id=a3.5.1.10>A3.5.1.10</a> 主机可以在<strong>BVALID</strong>被断言之前断言<strong>BREADY</strong>。</li></ul><p><a id="图 a3.5">图 A3.5
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.5_Write_transaction_handshake_dependencies.png alt></a></p><h5 id=a-ida352-读事务依赖a352-读事务依赖a><a id="a3.5.2 读事务依赖">A3.5.2 读事务依赖</a></h5><p>对于读取通道上的事务，<em><a href="#图 a3.6">图 A3.6</a></em> 显示了握手信号的依赖关系。规则如下：</p><ul><li><a id=a3.5.2.1>A3.5.2.1</a> 主机在断言<strong>ARVALID</strong>之前不得等待从机断言<strong>ARREADY</strong>。</li><li><a id=a3.5.2.2>A3.5.2.2</a> 从机可以在断言<strong>ARREADY</strong>之前等待<strong>ARVALID</strong>被断言。</li><li><a id=a3.5.2.3>A3.5.2.3</a> 从机可以在<strong>ARVALID</strong>被断言之前断言<strong>ARREADY</strong>。</li><li><a id=a3.5.2.4>A3.5.2.4</a> 从机必须等到<strong>ARVALID</strong>和<strong>ARREADY</strong>都被断言后，
才能断言<strong>RVALID</strong>以指示有效数据可用。</li><li><a id=a3.5.2.5>A3.5.2.5</a> 从机不得等待主机断言<strong>RREADY</strong>后再断言<strong>RVALID</strong>。</li><li><a id=a3.5.2.6>A3.5.2.6</a> 主机可以在断言<strong>RREADY</strong>之前等待<strong>RVALID</strong>被断言。</li><li><a id=a3.5.2.7>A3.5.2.7</a> 主机可以在<strong>RVALID</strong>被断言之前断言<strong>RREADY</strong>。</li></ul><p><a id="图 a3.6">图 A3.6
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.6_Read_transaction_handshake_dependencies.png alt></a></p><p>总结：</p><ul><li>断言<strong>VALID</strong>不等断言<strong>READY</strong>：</br><em><a href=#a3.5.1.1>A3.5.1.1</a></em> 写请求和写</br><em><a href=#a3.5.1.8>A3.5.1.8</a></em> 写响应</br><em><a href=#a3.5.2.1>A3.5.2.1</a></em> 读请求</br><em><a href=#a3.2.2.5>A3.2.2.5</a></em> 读</br><em><a href=#a3.6.3.1>A3.6.3.1</a></em> 侦听请求</br><em><a href=#a3.6.3.5>A3.6.3.5</a></em> 侦听响应</li><li>断言<strong>READY</strong>可等断言<strong>VALID</strong>：</br><em><a href=#a3.5.1.2>A3.5.1.2</a></em> 写请求和写</br><em><a href=#a3.5.1.9>A3.5.1.9</a></em> 写响应</br><em><a href=#a3.5.1.4>A3.5.1.4</a></em> 写请求和写</br><em><a href=#a3.5.2.2>A3.5.2.2</a></em> 读请求</br><em><a href=#a3.5.2.6>A3.5.2.6</a></em> 读</br><em><a href=#a3.6.3.2>A3.6.3.2</a></em> 侦听请求</br><em><a href=#a3.6.3.6>A3.6.3.6</a></em> 侦听响应</li><li>断言<strong>VALID</strong>和断言<strong>READY</strong>没有先后关系：</br><em><a href=#a3.5.1.3>A3.5.1.3</a></em> 写请求和写</br><em><a href=#a3.5.1.5>A3.5.1.5</a></em> 写请求和写</br><em><a href=#a3.5.1.10>A3.5.1.10</a></em> 写响应</br><em><a href=#a3.5.2.3>A3.5.2.3</a></em> 读请求</br><em><a href=#a3.5.2.7>A3.5.2.7</a></em> 读</br><em><a href=#a3.6.3.3>A3.6.3.3</a></em> 侦听请求</br><em><a href=#a3.6.3.6>A3.6.3.7</a></em> 侦听响应</li><li>断言<strong>BVALID</strong>必须在写传输完成之后：</br><em><a href=#a3.5.1.6>A3.5.1.6</a></em> 写响应在写请求和写之前</br><em><a href=#a3.5.1.7>A3.5.1.7</a></em> 写响应在最后一笔写传输之前</br></li><li>断言<strong>RVALID</strong>必须在<strong>ARVALID</strong>和<strong>ARREADY</strong>断言之后：</br><em><a href=#a3.5.2.4>A3.5.2.4</a></em> 读有效在读请求有效和就绪之前</li><li>断言<strong>CRVALID</strong>必须在<strong>ACVALID</strong>和<strong>ACREADY</strong>断言之后：</br><em><a href=#a3.6.3.4>A3.6.3.4</a></em> 侦听响应有效在侦听请求有效和就绪之前</li></ul><h4 id=a-ida36-侦听通道a36-侦听通道a><a id="a3.6 侦听通道">A3.6 侦听通道</a></h4><p>DVM消息在互连和管理组件之间通过侦听通道传输。
当支持DVM消息时，会有一个侦听请求通道（AC）和一个侦听响应通道（CR）。</p><h5 id=a-ida361-侦听请求通道aca361-侦听请求通道aca><a id="a3.6.1 侦听请求通道（ac）">A3.6.1 侦听请求通道（ac）</a></h5><p>侦听请求通道的控制信号如 <em><a href="#表 a3.8">表 A3.8</a></em> 所示。</p><p><a id="表 a3.8">表 A3.8</a> 侦听请求通道控制</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>ACVALID</strong></td><td>1</td><td>从机</td><td>侦听请求有效。</td></tr><tr><td><strong>ACREADY</strong></td><td>1</td><td>主机</td><td>侦听请求就绪。</td></tr></tbody></table><p>从机只能在驱动有效地址和控制信息时断言<strong>ACVALID</strong>信号。
当<strong>ACVALID</strong>被断言时，它必须保持断言状态，直到主机断言<strong>ACREADY</strong>信号的上升时钟边缘。</p><p><strong>ACREADY</strong>的默认状态可以是高或低。
建议将<strong>ACREADY</strong>的默认状态设置为高。
如果<strong>ACREADY</strong>为高，则主机必须能够接受任何呈现给它的有效请求。</p><p>不推荐将<strong>ACREADY</strong>的默认状态设置为低，因为这会迫使传输至少需要两个时钟周期，
一个用于断言<strong>ACVALID</strong>，另一个用于断言<strong>ACREADY</strong>。</p><h5 id=a-ida362-侦听响应信号cra362-侦听响应信号cra><a id="a3.6.2 侦听响应信号（cr）">A3.6.2 侦听响应信号（cr）</a></h5><p>侦听响应通道的控制信号如 <em><a href="#表 a3.9">表 A3.9</a></em> 所示。</p><p><a id="表 a3.9">表 A3.9</a> 侦听响应信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>信号源</th><th>描述</th></tr></thead><tbody><tr><td><strong>CRVALID</strong></td><td>1</td><td>主机</td><td>侦听响应有效。</td></tr><tr><td><strong>CRREADY</strong></td><td>1</td><td>从机</td><td>侦听响应就绪。</td></tr></tbody></table><p>主机只有在它在侦听响应通道上驱动有效信号时才能断言<strong>CRVALID</strong>CRVALID信号。
当<strong>CRVALID</strong>被断言时，必须保持断言状态，直到从机断言<strong>CRREADY</strong>后的时钟上升沿。</p><p>从机使用<strong>CRREADY</strong>信号表示它接受响应。
<strong>CRREADY</strong>的默认状态可以为高，但前提是从机能够在开始侦听事务时立即接受侦听响应。</p><h5 id=a-ida363-侦听事务依赖a363-侦听事务依赖a><a id="a3.6.3 侦听事务依赖">A3.6.3 侦听事务依赖</a></h5><p>对于侦听通道上的事务，<em><a href="#图 a3.7">图 A3.7</a></em> 显示了握手信号依赖关系。规则如下：</p><ul><li><a id=a3.6.3.1>A3.6.3.1</a> 从机在断言<strong>ACVALID</strong>之前不得等待主机断言<strong>ACREADY</strong>。</li><li><a id=a3.6.3.2>A3.6.3.2</a> 主机可以在断言<strong>ACREADY</strong>之前等待<strong>ACVALID</strong>被断言。</li><li><a id=a3.6.3.3>A3.6.3.3</a> 主机可以在<strong>ACVALID</strong>被断言之前断言<strong>ACREADY</strong>。</li><li><a id=a3.6.3.4>A3.6.3.4</a> 主机必须等待<strong>ACVALID</strong>和<strong>ACREADY</strong>都被断言后才能断言<strong>CRVALID</strong>，以表示有效响应可用。</li><li><a id=a3.6.3.5>A3.6.3.5</a> 主机不得等待从机断言<strong>CRREADY</strong>后再断言<strong>CRVALID</strong>。</li><li><a id=a3.6.3.6>A3.6.3.6</a> 从机可以在断言<strong>CRREADY</strong>之前等待<strong>CRVALID</strong>被断言。</li><li><a id=a3.6.3.7>A3.6.3.7</a> 从机可以在<strong>CRVALID</strong>被断言之前断言<strong>CRREADY</strong>。</li></ul><p><a id="图 a3.7">图 A3.7
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A3.7_Snoop_transaction_handshake_dependencies.png alt></a></p><h3 id=a-ida第4章-事务a第4章-事务a><a id="a第4章 事务">A第4章 事务</a></h3><p>AXI协议使用事务在主机和从机之间进行通信。
所有事务包括请求和响应。</p><p>写和读事务也包括一个或多个数据传输。</p><p>本章描述了事务请求、响应和数据传输。它包含以下几个部分</p><ul><li><em><a href="#a4.1 事务请求">A4.1 事务请求</a></em></li><li><em><a href="#a4.2 读写数据">A4.2 读写数据</a></em></li><li><em><a href="#a4.3 事务响应">A4.3 事务响应</a></em></li></ul><h4 id=a-ida41-事务请求a41-事务请求a><a id="a4.1 事务请求">A4.1 事务请求</a></h4><p>AXI主机通过向从机发出请求来启动事务。
请求包括事务属性和第一次数据传输的地址。
如果事务包含多个数据传输，从机必须计算后续传输的地址。</p><p>事务不得跨越4KB地址边界，这防止了事务跨越两个从机之间的边界。
这也限制了从机必须支持的地址增量数量。</p><h5 id=a-ida411-大小属性a411-大小属性a><a id="a4.1.1 大小属性">A4.1.1 大小属性</a></h5><p>size表示每次数据传输中的最大字节数.</p><p>对于读取事务，size表示每次读取数据传输中必须有效的数据字节数.</p><p>对于写入事务，size表示允许活动的数据字节通道数，<strong>WSTRB</strong> 指示在每次传输中哪些字节是有效的。</p><p>size不得超过接口的数据宽度，这由DATA_WIDTH属性确定。</p><p>如果size小于DATA_WIDTH，则在每次传输中使用字节通道的一个子集。</p><p>size通过写请求和读请求通道上的<strong>AWSIZE</strong>和<strong>ARSIZE</strong>信号进行传达，
在本规范中，<strong>AxSIZE</strong>表示<strong>AWSIZE</strong>和<strong>ARSIZE</strong>。</p><p><a id="表 a4.1">表 A4.1</a> <strong>AxSIZE</strong>信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWSIZE</strong></br><strong>ARSIZE</strong></td><td>3</td><td>DATA_WIDTH/8</td><td>一个事务中每次传输的最大字节数</td></tr></tbody></table><p>size通过<strong>AxSIZE</strong>信号进行编码，如 <em><a href="#表 a4.2">表 A4.2</a></em> 所示。</p><table><thead><tr><th><strong>AxSIZE</strong></th><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>0b000</td><td>1</td><td>每次传输最多1Byte</td></tr><tr><td>0b001</td><td>2</td><td>每次传输最多2Byte</td></tr><tr><td>0b010</td><td>4</td><td>每次传输最多4Byte</td></tr><tr><td>0b011</td><td>8</td><td>每次传输最多8Byte</td></tr><tr><td>0b100</td><td>16</td><td>每次传输最多16Byte</td></tr><tr><td>0b101</td><td>32</td><td>每次传输最多32Byte</td></tr><tr><td>0b110</td><td>64</td><td>每次传输最多64Byte</td></tr><tr><td>0b111</td><td>128</td><td>每次传输最多128Byte</td></tr></tbody></table><p>如 <em><a href="#表 a4.3">表 A4.3</a></em> 所示，属性 SIZE_Present 用于确定 <strong>AxSIZE</strong> 信号是否存在。</p><p><a id="表 a4.3">表 A4.3</a> SIZE_Present 属性</p><table><thead><tr><th>SIZE_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWSIZE</strong>和<strong>ARSIZE</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWSIZE</strong>和<strong>ARSIZE</strong>不存在</td></tr></tbody></table><p>一个只发出全数据宽度请求的主机可以从其接口中省略<strong>AxSIZE</strong>输出。
相应的从机必须根据数据宽度将其<strong>AxSIZE</strong>输入连接起来。</p><h5 id=a-ida412-长度属性a412-长度属性a><a id="a4.1.2 长度属性">A4.1.2 长度属性</a></h5><p>Length属性定义了事务中的数据传输次数。</p><p>Size x Length是一个事务中可以传输的最大字节数。如果地址未对齐或存在未使能的<strong>WSTRB</strong>，实际传输的字节数可能低于Size x Length。</p><p>主机必须根据Length发出写数据传输的数量。</p><p>从机必须根据Length发出读数据传输的数量。</p><p>Length通过写请求和读请求通道上的<strong>AWLEN</strong>和<strong>ARLEN</strong>信号进行通信。</p><p>在本规范中<strong>AxLEN</strong>表示<strong>AWLEN</strong>和<strong>ARLEN</strong>，如 <em><a href="#表 a4.4">表 A4.4</a></em> 所示。</p><p><a id="表 a4.4">表 A4.4</a> <strong>AxLEN</strong>信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWLEN</strong><br><strong>ARLEN</strong></td><td>8</td><td>0x00</td><td>事务的传输数量，Length=AxLEN+1</td></tr></tbody></table><p>属性 LEN_Present 用于确定信号是否存在，<em><a href="#表 a4.5">表 A4.5</a></em> 显示了 LEN_Present 的合法值。</p><p><a id="表 a4.5">表 A4.5</a> LEN_Present属性</p><table><thead><tr><th>LEN_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWLEN</strong>和 <strong>ARLEN</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWLEN</strong>和 <strong>ARLEN</strong>不存在</td></tr></tbody></table><p>一个只发出长度为1请求的主机可以从其接口中省略<strong>AxLEN</strong>输出。
相应的下属必须将其<strong>AxLEN</strong>输入连接到0x00。以下规则适用于事务长度：</p><ul><li>对于wrap突发，长度可以是2、4、8或16。</li><li>对于固定突发，长度可以达到16。</li><li>事务不得跨越4KB地址边界。</li><li>不支持事务的提前终止。</li></ul><p>没有组件可以提前终止事务。
然而，为了减少写事务中的数据传输次数，主机可以通过取消所有<strong>WSTRB</strong>的有效状态来禁用进一步的写入。
在这种情况下，主机必须完成事务中的其余传输。
在读取事务中，主机可以丢弃读取数据，但必须完成事务中的所有传输。</p><h5 id=a-ida413-事务的最大传输byea413-事务的最大传输byea><a id="a4.1.3 事务的最大传输bye">A4.1.3 事务的最大传输bye</a></h5><p>一个事务的最大字节数为4KB，事务不允许跨越4KB边界。
然而，许多主机生成的事务可能始终小于此值。</p><p>一个从机或互连可能会从这些信息中受益。例如，一个从机可借此优化一些解码逻辑。
一个在小于4KB粒度下进行条带化的互连如果知道事务不会跨越条带边界，可能能够避免突发拆分。</p><p>属性Max_Transaction_Bytes定义了一个事务的最大字节数，如 <em><a href="#表 a4.6">表 A4.6</a></em> 所示。</p><p><a id="表 a4.6">表 A4.6</a> Max_Transaction_Bytes 属性</p><table><thead><tr><th>名字</th><th>值</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>Max_Transaction_Bytes</td><td>64,128,256,512,1024048,4096</td><td>4096</td><td>一个主机发起的事务大小与长度之积不得超过最大传输字节数，且传输不得跨越最大传输字节数的边界。<br>一个从机只能接受大小与长度之积不超过最大传输字节数的传输。</td></tr></tbody></table><p>在连接主机和从机时，<em><a href="#表 a4.7">表 A4.7</a></em> 指示了兼容的 Max_Transaction_Bytes 组合。</p><p><a id="表 a4.7">表 A4.7</a> Max_Transaction_Bytes 互联</p><table><thead><tr><th>主机 &lt; 从机</th><th>主机 == 从机</th><th>主机 > 从机</th></tr></thead><tbody><tr><td>兼容</td><td>兼容</td><td>不兼容</td></tr></tbody></table><h5 id=a-ida414-突发属性a414-突发属性a><a id="a4.1.4 突发属性">A4.1.4 突发属性</a></h5><p>Burst属性描述了在事务中传输之间地址的递增方式。有三种不同的Burst类型：</p><ul><li><p>固定（FIXED）</br>此Burst类型用于对同一位置的重复访问，例如在加载或清空FIFO时。</p><ul><li>在Burst中的每次传输的地址都相同。</li><li>有效的字节通道对于所有传输都是恒定的。然而，在这些字节通道内，实际的<strong>WSTRB</strong>有效的字节在每次传输中可能不同。</li><li>Burst的长度可以达到16次传输。</li><li>固定Burst类型仅可与WriteNoSnoop或ReadNoSnoop操作码一起使用。
有关更多信息，请参见 <em><a href=#a第8章请求操作码>A第8章请求操作码</a></em> 。</li></ul></li><li><p>增量（INCR）</br>对于此Burst类型，每次传输的地址是前一次传输地址的递增。
递增值取决于事务的大小。例如，对于对齐的起始地址，事务中每次传输的地址是前一个地址加4。此Burst类型用于对正常顺序内存的访问。</p></li><li><p>回环（WRAP）</br></p><ul><li>此Burst类型类似于增量，除了在达到上限地址时地址会回环到较低的地址。适用以下限制：<ul><li>起始地址必须与每次传输的大小对齐。</li><li>Burst的长度必须为2、4、8或16次传输。</br></li></ul></li><li>回环事务的行为是：<ul><li>事务访问的最低地址是与要传输的数据总大小对齐的起始地址，即Size * Length。此地址被定义为回环边界。</li><li>每次传输后，地址的递增方式与增量Burst相同。然而，如果这个递增的地址是((回环边界) + (Size * Length))，则地址会回环到回环边界。</li><li>事务中的第一次传输可以使用高于回环边界的地址，前提是遵守适用于回环事务的限制。
当第一次地址高于回环边界时，地址会回环。此Burst类型用于缓存行访问。</li></ul></li></ul></li></ul><p>通过<strong>AWBURST</strong>和<strong>ARBURST</strong>信号分别在写请求和读请求通道上传达Burst。
在本规范中，<strong>AxBURST</strong>指示<strong>AWBURST</strong>和<strong>ARBURST</strong>。</p><p><a id="表 a4.8">表 A4.8</a> <strong>AxBURST</strong>信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWBURST</strong><br><strong>ARBURST</strong></td><td>2</td><td>0b01（INCR）</td><td>描述了事务中传输之间地址递增方式</td></tr></tbody></table><p>Burst在<strong>AxBURST</strong>信号上进行编码如 <em><a href="#表 a4.9">表 A4.9</a></em> 所示。</p><p><a id="表 a4.9">表 A4.9</a> <strong>AxBURST</strong>编码</p><table><thead><tr><th><strong>AxBURST</strong></th><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>FIXED</td><td>固定突发</td></tr><tr><td>0101</td><td>INCR</td><td>增量突发</td></tr><tr><td>0b10</td><td>WRAP</td><td>回环突发</td></tr><tr><td>0b11</td><td>保留</td><td>-</td></tr></tbody></table><p>属性BURST_Present用于确定<strong>AxBURST</strong>信号是否存在。
只发出类型为INCR的Burst请求的主机可以从其接口中省略<strong>AxBURST</strong>输出。
相应的从机必须将其<strong>AxBURST</strong>输入连接到0b01。</p><p><a id="表 a4.10">表 A4.10</a> BURST_Present属性</p><table><thead><tr><th>BURST_Present</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWBURST</strong>和<strong>ARBURST</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWBURST</strong>和<strong>ARBURST</strong>不存在</td></tr></tbody></table><p>一种突发类型的固定不常用属性，并在 <em><a href="#表 a4.11">表 A4.11</a></em> 中定义了属性Fixed_Burst_Disable以指示组件是否支持它。</p><p><a id="表 a4.11">表 A4.11</a> Fixed_Burst_Disable属性</p><table><thead><tr><th>Fixed_Burst_Disable</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>突发类型为FIXED的请求不支持由从机生成，也不由主机生成</td></tr><tr><td>False</td><td>Y</td><td>突发类型为FIXED的请求支持由从机生成，或主机生成</td></tr></tbody></table><p>根据 Fixed_Burst_Disable 属性的值，<em><a href="#表 a4.12">表 A4.12</a></em> 显示了主机和从机之间的兼容性。</p><p><a id="表 a4.12">表 A4.12</a>Fixed_Burst_Disable 兼容性</p><table><thead><tr><th>Fixed_Burst_Disable</th><th>从机：False</th><th>从机True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>不兼容</td></tr><tr><td>主机：True</td><td>兼容</td><td>兼容</td></tr></tbody></table><h5 id=a-ida415-传输地址a415-传输地址a><a id="a4.1.5 传输地址">A4.1.5 传输地址</a></h5><p>本节提供了在事务中确定传输的地址和字节通道的方法。事务的起始地址通过<strong>AxADDR</strong>信号指示。</p><p><a id="表 a4.13">表 A4.13</a> <strong>AxADDR</strong>信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWADDR</strong><br><strong>ARADDR</strong></td><td>ADDR_WIDTH</td><td>−</td><td>事务第一次传输的地址</td></tr></tbody></table><p>属性ADDR_WIDTH用于定义地址宽度。</p><p><a id="表 a4.14">表 A4.14</a> ADDR_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>ADDR_WIDTH</td><td>1&mldr;64</td><td>32</td><td><strong>AWADDR</strong>、<strong>ARADDR</strong>、<strong>ACADDR<strong>的地址</td></tr></tbody></table><p>该协议支持具有不同物理地址空间大小的组件之间的通信。</p><p>具有不同物理地址空间大小的组件必须按如下方式进行通信</p><ul><li>物理地址空间较小的组件必须位于较大物理地址空间中的对齐窗口内。
通常，窗口位于较大物理地址空间的底部。
但是，物理地址空间较小的组件可以位于较大物理地址空间中的偏移窗口内。</li><li>外部事务必须将所需的额外高位添加到事务地址中。</li><li>内部事务必须做以下检查：<ul><li>在地址窗口内的事务去掉高位地址位并被传递。</li><li>不具有所需高位地址位的事务被抑制。</li></ul></li></ul><blockquote><p>Note：</br>高位地址位通常携带了用于选择存储器或I/O设备特定区域的信息。</br>在计算机系统中，地址被分为高位和低位，高位地址线用于选择更大的地址范围或特定的存储区域，而低位地址线用于具体单元或设备的寻址.</p></blockquote><p>提供所需功能是互联的责任</p><h5 id=a-ida416-事务方程a416-事务方程a><a id="a4.1.6 事务方程">A4.1.6 事务方程</a></h5><p>该文中列出的方程用于确定事务中每次传输的地址和活动数据字节通道。方程使用以下变量：</p><ul><li>Start_Addr：由主机发出的起始地址。</li><li>Data_Bytes：数据通道的宽度（以字节为单位）（DATA_WIDTH/8）。</li><li>Aligned_Addr：起始地址的对齐地址。</li><li>Address_N：事务中传输N的地址。事务中第一次传输N的值为1。</li><li>Wrap_Boundary：wrap突发事务中的回环边界地址。</li><li>Lower_Byte_Lane：传输中最低寻址字节的字节通道。</li><li>Upper_Byte_Lane：传输中最高寻址字节的字节通道。</li><li>INT(x)：对x向下取整的整数值。</li></ul><p>这些方程确定突发内传输的地址：<br><code>Start_Addr = AxADDR</code><br><code>Aligned_Addr = INT(Start_Addr / Size)* Size</code></p><p>该方程确定突发中第一次传输的地址：<br><code>Address_1 = Start_Addr</code></p><p>对于INCR突发和地址未回环的WRAP突发，该方程确定突发中首次传输后的任何传输地址：<br><code>Address_N = Aligned_Addr + (N - 1)* Size</code></p><p>对于WRAP突发，Wrap_Boundary变量定义回环边界：<br><code>Wrap_Boundary = INT(Start_Addr / (Size * Length))* Size * Length</code></p><p>对于WRAP突发，如果Address_N = Wrap_Boundary + Size * Length，则：</p><ul><li>对于当前传输使用该方程：<br><code>Address_N = Wrap_Boundary</code></li><li>对于任何后续传输使用该方程：<br><code>Address_N = Start_Addr + ((N - 1)* Size)- (Size * Length)</code></li></ul><p>这些方程确定突发中第一次传输使用的字节通道：<br><code>Lower_Byte_Lane = Start_Addr - (INT(Start_Addr/Data_Bytes)* Data_Bytes)</code><br><code>Upper_Byte_Lane = Aligned_Addr + (Size-1)- (INT(Start_Addr/Data_Bytes)* Data_Bytes)</code></p><p>这些方程确定突发中第一次传输之后所有传输使用的字节通道：<br><code>Lower_Byte_Lane = Address_N - (INT(Address_N / Data_Bytes)* Data_Bytes)</code><br><code>Upper_Byte_Lane = Lower_Byte_Lane + Size - 1</code></p><p>数据传输在：<br><code>DATA((8 * Upper_Byte_Lane)+ 7: (8 * Lower_Byte_Lane))</code></p><p>事务容器描述在该事务中可以访问的所有字节，如果地址对齐且触发信号得到确认：<br><code>Container_Size = Size * Length</code></p><p>对于INCR突发：<br><code>Container_Lower = Aligned_Addr</code><br><code>Container_Upper = Aligned_Addr + Container_Size</code></p><p>对于WRAP突发：<br><code>Container_Lower = Wrap_Boundary</code><br><code>Container_Upper = Wrap_Boundary + Container_Size</code></p><h5 id=a-ida417-传输描述的伪代码a417-传输描述的伪代码a><a id="a4.1.7 传输描述的伪代码">A4.1.7 传输描述的伪代码</a></h5><pre tabindex=0><code>// DataTransfer()
// IsWrite is TRUE for a write, and FALSE for a read
DataTransfer(Start_Addr, Size, Length, Data_Bytes, Burst, IsWrite)

	addr = Start_Addr; // Variable for current address
	Aligned_Addr = (INT(addr/Size) * Size);
	aligned = (Aligned_Addr == addr); // Check whether addr aligned to Size
	Container_Size = Size * Length;
	
	if Burst == WRAP then
		Lower_Wrap_Boundary = (INT(addr/Container_Size) * Container_Size);
		// addr must be aligned for a wrapping burst
		Upper_Wrap_Boundary = Lower_Wrap_Boundary + Container_Size;

	for n = 1 to Length
		Lower_Byte_Lane = addr - (INT(addr/Data_Bytes) * Data_Bytes);
		if aligned then
			Upper_Byte_Lane = Lower_Byte_Lane + Size - 1
		else
			Upper_Byte_Lane = Aligned_Addr + Size - 1 - (INT(addr/Data_Bytes) * Data_Bytes);

		// Perform data transfer
		if IsWrite then
			dwrite(addr, Lower_Byte_Lane, Upper_Byte_Lane)
		else
			dread(addr, Lower_Byte_Lane, Upper_Byte_Lane);

		// Increment address if necessary
		if Burst != FIXED then
			if aligned then
				addr = addr + Size;
				if Burst == WRAP then
					if addr &gt;= Upper_Wrap_Boundary then 
						addr = Lower_Wrap_Boundary;
					else
						addr = Aligned_Addr + Size;
						aligned = TRUE; // All transfers after the first are aligned
		return;
</code></pre><h5 id=a-ida418-常规事务a418-常规事务a><a id="a4.1.8 常规事务">A4.1.8 常规事务</a></h5><p>事务有许多突发、大小和长度的选项。
然而，一些接口和事务类型可能只使用这些选项的一个子集。
如果一个从机连接到一个仅使用事务选项子集的主机，它可以设计为简化型解码逻辑。</p><p>Regular属性被定义为识别符合以下标准的事务：</p><ul><li>长度为1、2、4、8或16次传输。</li><li>如果长度大于1，则大小与数据通道宽度相同。</li><li>突发为INCR或WRAP，而不是FIXED。<ul><li>对于INCR事务，地址与事务容器对齐。</li><li>对于WRAP事务，地址与大小对齐。</li></ul></li></ul><p>Regular_Transactions_Only属性用于定义一个主机是否仅发出常规类型的事务，
以及一个从机是否仅支持常规事务。</p><p><a id="表 a4.15">表 A4.15</a> Regular_Transaction_Only属性</p><table><thead><tr><th>Regular_Transactions_Only</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>只有常规事务被支持</td></tr><tr><td>False</td><td>Y</td><td>所有合法<strong>AxBURST</strong>、<strong>AxSIZE</strong>、<strong>AxLEN</strong>的组合都支持</td></tr></tbody></table><p>常规交易的互操作性规则见 <em><a href=#a4.16>A4.16</a></em></p><p><a id="表 a4.16">表 A4.16</a> Regular_Transactions_Only互操作性</p><table><thead><tr><th>Regular_Transactions_Only</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>不兼容<br>如果主机发布的事务不是常规的，那么可能会发生数据损坏或死锁</td></tr><tr><td>主机：True</td><td>兼容</td><td>兼容</td></tr></tbody></table><h4 id=a-ida42-读写数据a42-读写数据a><a id="a4.2 读写数据">A4.2 读写数据</a></h4><p>本节描述了AXI写入和读取数据通道上不同大小的传输，以及接口如何执行混合字节序和非对齐传输。</p><h5 id=a-ida421-write-strobesa421-write-strobesa><a id="a4.2.1 write strobes">A4.2.1 write strobes</a></h5><p><strong>WSTRB</strong>信号携带写使能信号，指定写数据通道的哪些字节通道包含有效的信息。</p><p><a id="表 a4.17">表 A4.17</a> <strong>WSTRB</strong>信号</p><table><thead><tr><th>信号</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>WSTRB</strong></td><td>WDATA_WIDTH/8</td><td>全1</td><td>表明写事务中每次传输<strong>WDATA</strong>的哪些字节有效</td></tr></tbody></table><p>每8位写数据通道都对应一位的<strong>WSTRB</strong>，因此WSTRB[n]对应于WDATA[(8n)+7:(8n)]。<br>当<strong>WVALID</strong>为高电平时：</p><ul><li>要写入的数据字节与<strong>WSTRB</strong>信号相应的bit被设为高电平。</li><li>在事务容器内部，可以有任意数量的<strong>WSTRB</strong>信号bit为高电平。
如果所有<strong>WSTRB</strong>信号bit都为低电平，则该传输不写入任何数据。</li><li>在事务容器外部，所有<strong>WSTRB</strong>信号bit必须为低电平。</li></ul><p>当<strong>WVALID</strong>为低电平时，<strong>WSTRB</strong>信号可以取任何值，
但建议将其保持在低电平或保持在之前的值上。</p><p>建议在<strong>WSTRB</strong>信号为低电平时，<strong>WDATA</strong>的字节通道设为零。</p><p>属性WSTRB_Present用于指示接口上是否存在<strong>WSTRB</strong>信号。</p><p><a id="表 a4.18">表 A4.18</a> WSTRB_Present属性</p><table><thead><tr><th>WSTRB_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>WSTRB</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>WSTRB</strong>不存在</td></tr></tbody></table><p>一个只在所有<strong>WSTRB</strong>信号bit都被激活时发出事务的主机可以省略其接口中的<strong>WSTRB</strong>输出。
相应的从机必须将其<strong>WSTRB</strong>输入固定为高电平。</p><h5 id=a-ida422-窄传输a422-窄传输a><a id="a4.2.2 窄传输">A4.2.2 窄传输</a></h5><p>当主机生成的传输比其数据通道窄时，地址和控制信息决定了传输使用的字节通道：</p><ul><li>当突发模式为INCR或WRAP时，事务中的每个数据传输使用不同的字节通道。</li><li>当突发模式为FIXED时，事务中的每个数据传输使用相同的字节通道。</li></ul><p>字节通道使用的两个示例显示在 <em><a href="#图 a4.1">图 A4.1</a></em> 和 <em><a href="#图 a4.2">图 A4.2</a></em> 中。
阴影单元表示未传输的字节。
在 <em><a href="#图 a4.1">图 A4.1</a></em> 中：</p><ul><li>事务有五个数据传输。</li><li>起始地址为0。</li><li>每个传输为8位。</li><li>传输在32位数据通道上进行。</li><li>突发类型为INC。</li></ul><p><a id="图 a4.1">图 A4.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.1_Narrow_transfer_example_with_8-bit_transfers.png alt></a></p><p>在 <em><a href="#图 a4.2">图 A4.2</a></em> 中</p><ul><li>该事务有三个数据传输。</li><li>起始地址是4。</li><li>每个传输为32位。</li><li>传输在64位数据通道上。</li><li>突发类型是INCR。</li></ul><p><a id="图 a4.2">图 A4.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.2_Narrow_transfer_example_with_32-bit_transfers.png alt></a></p><h5 id=a-ida423-字节不变性a423-字节不变性a><a id="a4.2.3 字节不变性">A4.2.3 字节不变性</a></h5><p>为了在单一内存空间中访问混合字节序的数据结构，AXI协议使用了字节不变的字节序方案。</p><p>字节不变的字节序意味着在数据结构中的任何多字节元素：</p><ul><li>元素使用相同的连续内存字节，与数据的字节序无关。</li><li>字节序决定了内存中这些字节的顺序，这意味着它决定了内存中的第一个字节是元素的最高有效字节（MSB）还是最低有效字节（LSB）。</li><li>任何字节传输到一个地址时，会将8位数据通过相同的数据通道线传输到相同的地址位置，无论它所属的较大数据元素的字节序如何。</li></ul><p>只有一种传输宽度的组件必须将其字节通道连接到数据通道的适当字节通道。
支持多种传输宽度的组件可能需要更复杂的接口来转换不是自然字节不变的接口。</p><p>大多数小端组件可以直接连接到字节不变接口。
仅支持大端传输的组件需要一个转换函数以实现字节不变操作。</p><p><em><a href="#图 a4.3">图 A4.3</a></em> 和 <em><a href="#图 a4.4">图 A4.4</a></em> 中的示例显示了一个32位数字0x0A0B0C0D，
存储在寄存器和内存中。</p><p>在 <em><a href="#图 a4.3">图 A4.3</a></em> 中，有一个大端字节不变数据结构的示例，在该结构中：</p><ul><li>数据的最高有效字节（MSB），即0x0A，存储在寄存器的最高有效字节位置。</li><li>数据的最高有效字节（MSB），存储在最低地址的内存位置。</li><li>其他数据字节按重要性递减顺序排列。</li></ul><p><a id="图 a4.3">图 A4.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.3_Example_big-endian_byte-invariant_data_structure.png alt></a></p><p>在 <em><a href="#图 a4.4">图 A4.4</a></em> 中，有一个小端字节不变数据结构的示例在这个结构中：</p><ul><li>数据的最低有效位（LSB），即0x0D，存储在寄存器的最低有效位位置。</li><li>数据的最低有效位（LSM），存储在地址最低的内存位置。</li><li>其他数据字节按重要性递增的顺序排列。</li></ul><p><a id="图 a4.4">图 A4.4
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.4_Example_little-endian_byte-invariant_data_structure.png alt></a></p><p><em><a href="#图 a4.3">图 A4.3</a></em> 和 <em><a href="#图 a4.4">图 A4.4</a></em> 中的示例显示了
字节不变性确保大端和小端结构可以在单一内存空间中共存且不会出现损坏。</p><p><em><a href="#图 a4.5">图 A4.5</a></em> 中有一个需要字节不变访问的数据结构示例，在这个示例中标头字段使用小端排序而有效负载使用大端排序。</p><p><a id="图 a4.5">图 A4.5
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.5_Example_mixed-endian_data_structure.png alt></a></p><p>在这个示例结构中，Data items是一个两字节的小端元素，这意味着其最低地址是最低有效位。
字节不变量的使用确保了大端对负载的访问不会破坏小端元素。</p><h5 id=a-ida424-不对齐传输a424-不对齐传输a><a id="a4.2.4 不对齐传输">A4.2.4 不对齐传输</a></h5><p>AXI支持非对齐传输。
对于由超过1kB的数据传输组成的任何事务，初始访问的字节可能与自然地址边界不对齐。
例如开始于字节地址0x1002的32位数据包未对齐到自然32位地址边界，</p><p>主机可以：</p><ul><li>使用低位地址线来表示非对齐的起始地址.</li><li>提供对齐地址并使用字节行strobes来表示非对齐的起始地址。</li></ul><p>低位地址线上的信息必须与字节行strobes上的信息一致。</p><p>从机不需要基于主机提供的任何对齐信息采取特殊行动。</p><p><em><a href="#图 a4.6">图 A4.6</a></em> 显示了32位数据通道上对齐和非对齐32位事务的示例。
图中的每一行表示一次传输并且阴影单元表示未传输的字节。</p><p><a id="图 a4.6">图 A4.6
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.6_Aligned_and_unaligned_transfers_on_a_32-bit_data_channel.png alt></a></p><p>在 <em><a href="#图 a4.7">图 A4.7</a></em> 中，有一些在64位数据通道上对齐和未对齐的32位事务示例。
图中每一行代表一次传输，阴影单元格表示未传输的字节。</p><p><a id="图 a4.7">图 A4.7
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.7_Aligned_and_unaligned_transfers_on_a_64-bit_data_channel.png alt></a></p><p>在 <em><a href="#图 a4.8">图 A4.8</a></em> 中有一个在64位数据通道上对齐的32位回环事务的示例。
图中的每一行表示一个传输，阴影的单元格表示未传输的字节。</p><p><a id="图 a4.8">图 A4.8
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A4.8_Aligned_wrapping_transfers_on_a_64-bit_channel.png alt></a></p><h4 id=a-ida43-事务响应a43-事务响应a><a id="a4.3 事务响应">A4.3 事务响应</a></h4><p>每个AXI事务都包括一个或多个由从机发送的响应传输，以指示事务的结果。</p><p>写通道上的事务有一个或多个写响应。</p><p>读通道上的事务有一个或多个读响应。</p><p>原子事务有写和读响应，请参见 <em><a href="#a7.4 原子事务">A7.4 原子事务</a></em> 。</p><h5 id=a-ida431-写响应a431-写响应a><a id="a4.3.1 写响应">A4.3.1 写响应</a></h5><p>写响应通过写响应通道上的<strong>BRESP</strong>信号进行传输。
写通道上的所有事务都有一个完成响应，它指示事务的结果。
一些事务还有第二个写响应，例如指示持久性。
参见 <em><a href="#a10.8.4 b通道上的pcmo响应">A10.8.4 B通道上的PCMO响应</a></em> 。</p><p><strong>BRESP</strong>和<strong>BCOMP</strong>信号用于发送写响应。</p><p><a id="表 a4.19">表 A4.19</a> <strong>BRESP</strong> 和 <strong>BCOMP</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>BRESP</strong></td><td>BRESP_WIDTH</td><td>0b00（OKAY）</td><td>写通道的事务响应</td></tr><tr><td><strong>BCOMP</strong></td><td>1</td><td>0b1</td><td>断言为高，表明完成响应</td></tr></tbody></table><p>BRESP_WIDTH属性在 <em><a href="#表 a4.20">表 A4.20</a></em> 中有显示。</p><p><a id="表 a4.20">表 A4.20</a> BRESP_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>BRESP_WIDTH</td><td>0,2,3</td><td>2</td><td><strong>BRESP</strong>的位宽。<br>如果是下列情况，则必须是3：<br>Untranslated_Transactions = v2<br>Untranslated_Transactions =v3<br>WriteDeferrable_Transaction = True</td></tr></tbody></table><p><strong>BRESP</strong>是一个可选信号。如果BRESP_WIDTH属性为0，则该信号不存在，并被假定为0b000（OKAY）。</p><p>只有在接口使用可以具有两个写响应的特性时，BCOMP才会出现，这些特性包括：</p><ul><li>持久性的缓存维护，参见 <em><a href="#a10.8 持久性cmos">A10.8 持久性CMOs</a></em> 。</li><li>内存标签，参见 <em><a href="#a13.2 内存标签扩展（mte）">A13.2 内存标签扩展（MTE）</a></em> 。</li></ul><p>如果<strong>BCOMP</strong>存在，则必须在写通道每个事务的响应传输中被断言。</p><p><strong>BRESP</strong>编码见 <em><a href="#表 a4.21">表 A4.21</a></em> 。</p><p><a id="表 a4.21">表 A4.21</a> <strong>BRESP</strong>编码</p><table><thead><tr><th><strong>BRESP</strong></th><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>OKAY</td><td>非独占写入：事务成功。如果事务包含写入数据，则更新的值是可观察的。<br>独占写入：更新位置失败</td></tr><tr><td>0n001</td><td>EXOKAY</td><td>独占写入：事务成功。只允许在独占写中使用。</td></tr><tr><td>0b010</td><td>SLVERR</td><td>存在于请求已到达终点但未成功完成。<br>位置可能未完全更新，通常在从机中存在问题时使用，例如尝试访问只读或已断电的功能。</td></tr><tr><td>0b011</td><td>DECERR</td><td>存在于请求尚未达到可以写入数据的阶段。<br>位置可能尚未完全更新。通常在地址解码为无效地址时使用</td></tr><tr><td>0b100</td><td>DEFER</td><td>写入未成功，因为此时无法提供服务。<br>位置未更新。此响应仅适用于可延迟写入事务（WriteDeferrable）。</td></tr><tr><td>0b101</td><td>TRANSFAULT</td><td>事务因转换错误而终止，该错误可能通过PRI请求来解决。</td></tr><tr><td>0b110</td><td>RESERVED</td><td>-</td></tr><tr><td>0b111</td><td>UNSUPPORTED</td><td>写入不成功，因为目标不支持该事务类型。位置未更新。此响应仅允许用于可延迟写入的事务（WriteDeferrable）。</td></tr></tbody></table><h5 id=a-ida432-读响应a432-读响应a><a id="a4.3.2 读响应">A4.3.2 读响应</a></h5><p>读取响应指示读取是否成功以及该传输中的数据是否有效。</p><p>读取响应通过读取数据通道上的<strong>RRESP</strong>信号传输，在事务中的每次读取数据传输都有一个读取响应。
响应值不要求在事务中的每次读取数据传输中都相同。</p><p>需要注意的是所有数据传输都应按长度指示始终完成而不考虑响应。
对于某些响应，该传输中的数据不要求有效。</p><p><strong>RRESP</strong>信号的定义如表 <em><a href="#表 a4.22">表 A4.22</a></em> 所示。</p><p><a id="表 a4.22">表 A4.22</a> <strong>RRESP</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>RRESP</strong></td><td>RRESP_WIDTH</td><td>0b00（OKAY）</td><td>读通道的事务响应。<br><strong>RVALID</strong>断言时<strong>RRESP</strong>必须有效。</td></tr></tbody></table><p>RRESP_WIDTH属性在 <em><a href="#表 a4.23">表 A4.23</a></em> 中显示。</p><p><a id="表 a4.23">表 A4.23</a> RRESP_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>RRESP_WIDTH</td><td>0,2,3</td><td>2</td><td><strong>RRESP</strong>的位宽。<br>如果是下列情况，则必须是3：<br>Prefetch_Transaction = True<br>Untranslated_Transactions = v2<br>Untranslated_Transactions =v3<br>Shareable_Cache_Support = True</td></tr></tbody></table><p><strong>RRESP</strong>是一个可选信号。
如果RRESP_WIDTH属性为0，则该信号不存在，并假定为0b000（OKAY）。
RRESP的编码如 <em><a href="#表 a4.24">表 A4.24</a></em> 所示。</p><p>对于数据不要求有效的响应，主机可能仍会采样RDATA值，因此从机不应依赖响应来隐藏敏感数据。</p><p><a id="表 a4.24">表 A4.24</a> <strong>RRESP</strong>编码</p><table><thead><tr><th><strong>RRESP</strong></th><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>OKAY</td><td>非独占读取：事务成功。读取数据有效。<br>独占读取：从机不支持独占访问</td></tr><tr><td>0n001</td><td>EXOKAY</td><td>独占读取：事务成功。只允许在独占读中使用。</td></tr><tr><td>0b010</td><td>SLVERR</td><td>事务遇到了一个包含的错误，仅此位置受影响。<br>通常在从机中出现问题时使用，例如FIFO溢出、不支持的传输大小或尝试访问已断电的功能。<br>读取数据无效</td></tr><tr><td>0b011</td><td>DECERR</td><td>事务已遇到未包含的错误，其他位置可能会受到影响。<br>通常用于地址解码到无效地址。<br>读取数据无效</td></tr><tr><td>0b100</td><td>PREFETCHED</td><td>来自预取的读取值有效。</td></tr><tr><td>0b101</td><td>TRANSFAULT</td><td>事务因转换错误而终止，该错误可能通过PRI请求来解决。</td></tr><tr><td>0b110</td><td>OKAYDIRTY</td><td>读取数据有效且相对于内存中的值是脏的。<br>仅允许响应ReadShared请求</td></tr><tr><td>0b111</td><td>RESERVED</td><td>-</td></tr></tbody></table><p><strong>RRESP</strong>的值并不限制在每次传输中都相同。
当访问从机出现问题时，通常会使用 DECERR 响应。
且在这种情况下，DECERR 在每次读取数据的传输中都会一致地发出信号。</p><p>如果主机可以检查一次读取数据传输以确定是否发生了， DECERR 可能会有效。</p><p>Consistent_DECERR 属性用于定义从机在一个事务中是否一致地发出 DECERR 信号，如表 A4.25 所示。</p><p><a id="表 a4.25">表 A4.25</a> Consistent_DECERR 属性</p><table><thead><tr><th>Consistent_DECERR</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>DECERR信号在每个读取数据传输或每个缓存行数据中没有读取数据传输时发出。<br>比如，跨越缓存行边界的事务可以在一个缓存行的每个读取数据传输中收到DECERR响应，而在下一个缓存行中没有数据传输。</td></tr><tr><td>False</td><td>Y</td><td>DECERR 可能在任意数量的读数据传输中被触发。</td></tr></tbody></table><p>从机不使用DECERR响应的可以将Consistent_DECERR属性设置为真。</p><p>将Consistent_DECERR设置为真的主机可以检查一次数据传输以确定是否发生了DECERR。</p><p>当在AXI和CHI之间桥接时将此属性设置为真可以有用的，因为DECERR会转换为非数据错误。</p><p>在连接主机和从机时 <em><a href="#表 a4.26">表 A4.26</a></em> 显示了兼容的Consistent_DECERR组合。</p><p><a id="表 a4.26">表 A4.26</a> Consistent_DECERR 互操作性</p><table><thead><tr><th>Consistent_DECERR</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容</td></tr><tr><td>主机：True</td><td>不兼容<br>主机可能会错过DECERR响应。</td><td>兼容</td></tr></tbody></table><h5 id=a-ida433-从机繁忙标识a433-从机繁忙标识a><a id="a4.3.3 从机繁忙标识">A4.3.3 从机繁忙标识</a></h5><p>当提供响应时，从机可以使用繁忙标识来表明其当前的活动水平。
这些信息可以用来控制主机的发出速率或它产生的推测性事务的数量。</p><p>繁忙标识对于有共享资源的组件是有用的，
比如内存控制器或系统缓存。例如，繁忙指示可以表示：</p><ul><li>共享队列的繁忙状态。</li><li>读取或写入请求队列的繁忙状态，取决于事务的方向。</li><li>当组件对资源的使用超过或少于其分配值。</li></ul><p>如 <em><a href="#表 a4.27">表 A4.27</a></em> 所示，Busy_Support属性用于定义接口是否包含繁忙标识信号。</p><p><a id="表 a4.27">表 A4.27</a> Busy_Support属性</p><table><thead><tr><th>BUSY_Support</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>从机繁忙支持</td></tr><tr><td>False</td><td>Y</td><td>从机繁忙不支持</td></tr></tbody></table><p>当 Busy_Support 为 True 时，<em><a href="#表 a28">表 A28</a></em> 以下信号将包含在接口上。</p><p><a id="表 a28">表 A28</a> 繁忙标识信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>BBUSY</strong><br><strong>RBUSY</strong></td><td>2</td><td>0b00</td><td>指示在事务响应中从机操作的当前状态，随着从机变得越来越忙 该值会增加</td></tr></tbody></table><p>对于具有多个读取数据传输的事务，Busy必须有效，但每次传输可以有不同的值。</p><p>对于具有多个写入响应的事务，在<strong>BCOMP</strong>断言的响应中，Busy必须有效。
对于其他写入响应，Busy不适用时可以取任何值。</p><p>对于具有写入和读取响应的原子事务，<strong>BBUSY</strong>和<strong>RBUSY</strong>预计但不要求具有相同的值。</p><p>Busy标识值的具体使用方式是实现定义的，在 <em><a href="#表 a4.29">表 A4.29</a></em> 中有展示了使用它的示例。
在这个示例中，如果从机无法生成动态繁忙标识，则默认值0b01是适当的。</p><p><a id="表 a29">表 A29</a> 繁忙标识的使用例子</p><table><thead><tr><th>繁忙标识</th><th>含义</th><th>主机行为</th></tr></thead><tbody><tr><td>0b00</td><td>不繁忙</td><td>增加请求</td></tr><tr><td>0b01</td><td>稍微忙</td><td>无动作</td></tr><tr><td>0b10</td><td>有点忙</td><td>减少请求</td></tr><tr><td>0b11</td><td>特别忙</td><td>大幅度减少请求</td></tr></tbody></table><p><a id=a4.30>A4.30</a> Busy_Support 互操作性</p><table><thead><tr><th>Busy_Support</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容<br>繁忙输出不连接</td></tr><tr><td>主机：True</td><td>兼容 繁忙输入连接到默认值</td><td>兼容</td></tr></tbody></table><h3 id=a-ida第5章-请求属性a第5章-请求属性a><a id="a第5章 请求属性">A第5章 请求属性</a></h3><p>本章描述了请求属性以及下游组件如何对其进行处理。它包含以下部分：</p><ul><li><em><a href="#a5.1 从机类型">A5.1 从机类型</a></em></li><li><em><a href="#a5.2 内存属性">A5.2 内存属性</a></em></li><li><em><a href="#a5.3 内存类型">A5.3 内存类型</a></em></li><li><em><a href="#a5.4 保护错误">A5.4 保护错误</a></em></li><li><em><a href="#a5.5 内存保护和realm管理扩展">A5.5 内存保护和realm管理扩展</a></em></li><li><em><a href="#a5.6 内存加密上下文">A5.6 内存加密上下文</a></em></li><li><em><a href="#a5.7 多区域接口">A5.7 多区域接口</a></em></li><li><em><a href="#a5.8 qos信号">A5.8 Qos信号</a></em></li></ul><h4 id=a-ida51-从机类型a51-从机类型a><a id="a5.1 从机类型">A5.1 从机类型</a></h4><p>从机被分类为内存从机或外设从机：</p><ul><li><p>内存从机：
内存从机需要正确处理所有事务类型。</p></li><li><p>外设从机：
外设从机有一个 IMPLEMENTATION DEFINED 的访问方法。
通常访问方法在组件数据表中定义，该表描述了从机正确处理的事务类型。</p></li></ul><p>任何不是 IMPLEMENTATION DEFINED 访问方法一部分的外设从机，其访问必须完成，并遵循协议。
然而，当这样的访问已被进行时，不要求外设从机继续正常操作。
只要求从机在协议合规的方式下继续完成进一步的事务。</p><h4 id=a-ida52-内存类型a52-内存类型a><a id="a5.2 内存类型">A5.2 内存类型</a></h4><p>本节描述了决定系统组件如缓存、缓冲区和内存控制器应如何处理请求的属性。
<strong>AWCACHE</strong>和<strong>ARCACHE</strong>信号指定了请求的内存属性。
它们控制：</p><ul><li>事务如何在系统中进行。</li><li>任意系统级缓冲区和缓存如何处理事务。</li></ul><p>在本规范中，术语<strong>AxCACHE</strong>统称为<strong>AWCACHE</strong>和<strong>ARCACHE</strong>信号。
<em><a href="#表 a5.1">表 A5.1</a></em> 描述了<strong>AWCACHE</strong>和<strong>ARCACHE</strong>信号。</p><p><a id="表 a5.1">表 A5.1</a> <strong>AxCACHE</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWCACHE</strong><br><strong>ARCACHE</strong></td><td>4</td><td>0x0</td><td>请求的内存属性控制事务在系统中的进展以及缓存和缓冲区如何处理该请求</td></tr></tbody></table><p>属性CACHE_Present用于确定接口上是否存在<strong>AxCACHE</strong>信号。</p><p><a id="表 a5.2">表 A5.2</a> CACHE_Present属性</p><table><thead><tr><th>CACHE_Present</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWCACHE</strong>和<strong>ARCACHE</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWCACHE</strong>和<strong>ARCACHE</strong>不存在</td></tr></tbody></table><p>AWCACHE位被编码为：</p><ul><li>[0] 可缓冲</li><li>[1] 可修改</li><li>[2] 其他分配</li><li>[3] 分配</li></ul><p>ARCACHE位被编码为：</p><ul><li>[0] 可缓冲</li><li>[1] 可修改</li><li>[2] 分配</li><li>[3] 其他分配</li></ul><p>请注意，分配和其他分配位在读请求和写请求中的位置不同。</p><h5 id=a-ida521-可缓冲-strongaxcache0stronga521-可缓冲strong-axcache0stronga><a id="a5.2.1 可缓冲-<strong>AxCACHE[0]</strong>">A5.2.1 可缓冲<strong>-AxCACHE[0]</strong></a></h5><p>对于写入事务：</p><ul><li>如果可缓冲位被去分断言，则写入响应表示数据已到达最终目的地。</li><li>如果可缓冲位被断言，则写入响应可以在满足可观察性要求时从中间点发送。</li></ul><p>对于 ARCACHE[3:2] 被去分断言（不可缓存）且 ARCACHE[1] 被断言（可修改）的读取事务：</p><ul><li>如果可缓冲位被去分断言，则读取的数据必须从最终目的地获取。</li><li>如果可缓冲位被断言，则读取的数据可以从最终目的地或从正在传输到最终目的地的写入中获取。</li></ul><p>对于 ARCACHE[3:1] 的其他组合，可缓冲位无效。</p><h5 id=a-ida522-可修改-strongaxcache1stronga522-可修改-strongaxcache1stronga><a id="a5.2.2 可修改-<strong>AxCACHE[1]</strong>">A5.2.2 可修改-<strong>AxCACHE[1]</strong></a></h5><p>事务可以被修改。当AxCACHE[1]去分断言时，事务是不可修改的。
以下部分描述了不可修改和可修改事务的属性。</p><p><strong>不可修改事务</strong></p><p>不可将其拆分为多个事务或与其他事务合并。
在不可修改事务中，<em><a href="#表 a5.3">表 A5.3</a></em> 中显示的参数不得更改。</p><p><a id="表 a5.3">表 A5.3</a> 不可修改的参数</p><table><thead><tr><th>参数</th><th>信号</th></tr></thead><tbody><tr><td>地址</td><td><strong>AxADDR</strong><br><strong>AxREGION</strong></td></tr><tr><td>大小</td><td><strong>AxSIZE</strong></td></tr><tr><td>长度</td><td><strong>AxLEN</strong></td></tr><tr><td>突发类型</td><td><strong>AxBURST</strong></td></tr><tr><td>保护属性</td><td><strong>AxPROT</strong><br>AxNSE</strong></td></tr></tbody></table><p><strong>AxCACHE</strong>属性只能修改以将事务从可缓冲转换为不可缓冲。对AxCACHE的其他更改是不允许的。</p><p>事务ID和QoS值可以被修改。</p><p>长度大于16的不可修改事务可以分割成多个事务。
每个生成的事务必须满足本小节中给出的要求，但不可避免的带来一些改变，</p><ul><li>长度减少。</li><li>地址要做相应的调整。</li></ul><p><strong>AxLOCK</strong>断言指定的独占访问不可修改事务，可以修改大小<strong>AxSIZE</strong>和长度<strong>AxLEN</strong>，
前提是总访问的字节数保持不变。</p><p>存在一些情况，无法满足不可修改事务的要求。
例如，当缩小到宽度小于大小要求的数据时，事务必须被修改。</p><p>执行该操作的组件可以选择性地包括 IMPLEMENTATION DEFINED 的机制，以指示已发生修改。
这种机制可以帮助软件调试。</p><p><strong>可修改事务</strong></p><p>可修改事务可以通过以下方式进行修改：</p><ul><li>事务可以被分解为多个事务。</li><li>多个事务可以合并为一个事务。</li><li>读取事务可以获取比所需更多的数据。</li><li>写入事务可以访问比所需更大的地址范围，使用<strong>WSTRB</strong>信号确保只有适当的位置被更新。</li><li>在每个生成的事务中，可以修改以下属性：<ul><li>地址，<strong>AxADDR</strong></li><li>大小，<strong>AxSIZE</strong></li><li>长度，<strong>AxLEN</strong></li><li>突发类型，</strong>AxBURST</strong></li></ul></li></ul><p>以下内容不得更改：</p><ul><li>独占访问指示符，<strong>AxLOCK</strong></li><li>保护和安全属性，<strong>AxPROT</strong>和<strong>AxNSE</strong>。</li></ul><p><strong>AxCACHE</strong>可以修改，但任何修改必须确保不减少其他组件对事务的可见性，
既不能阻止事务传播到所需位置，也不能更改在缓存中查找事务的需求。
对内存属性的所有修改必须对同一地址范围内的所有事务保持一致。</p><p>事务ID和QoS值可以被修改。<br>不允许的事务修改包括：</p><ul><li>导致访问与原始事务不同的4KB地址空间。</li><li>导致对单一拷贝原子性大小区域的单个访问被执行为多个访问。见 <em><a href="#a7.1 单副本原子大小">A7.1 单副本原子大小</a></em></li></ul><h5 id=a-ida523-分配和其他分配-strongaxcache32stronga523-分配和其他分配-strongaxcache32stronga><a id="a5.2.3 分配和其他分配-<strong>AxCACHE[3:2]</strong>">A5.2.3 分配和其他分配-<strong>AxCACHE[3:2]</strong></a></h5><p>如果分配位被断言：</p><ul><li>数据可能先前已被分配，因此必须在缓存中查找该行。</li><li>建议将数据分配到缓存中以供将来使用。</li></ul><p>如果其他分配位被断言：</p><ul><li>数据可能先前已被分配，因此必须在缓存中查找该行。</li><li>不建议对数据进行分配，因为预计不会再次访问。</li></ul><p>如果分配和其他分配都未断言，则请求不需要在任何缓存中查找。</p><h5 id=a-ida53-内存类型a53-内存类型a><a id="a5.3 内存类型">A5.3 内存类型</a></h5><p><strong>AxCACHE</strong>信号的组合指示了一种内存类型。
<em><a href=#a5.4>A5.4</a></em> 显示了内存类型编码。
括号中的值是允许的但不是首选的，表中未显示的值是保留的。</p><p><a id="表 a5.4">表 A5.4</a> 内存类型编码</p><table><thead><tr><th><strong>ARCACHE[3:0]</strong></th><th><strong>AWCACHE[3:0]</strong></th><th>Memory type</th></tr></thead><tbody><tr><td>0b0000</td><td>0b0000</td><td><em><a href=#a设备非缓冲>A设备非缓冲</a></em><br>Device Non-bufferable</td></tr><tr><td>0b0001</td><td>0b0001</td><td><em><a href=#a设备可缓冲>A设备可缓冲</a></em><br>Device Bufferable</td></tr><tr><td>0b0010</td><td>0b0010</td><td><em><a href=#a正常非缓存非缓冲>A正常非缓存非缓冲</a></em><br>Normal Non-cacheable Non-bufferable</td></tr><tr><td>0b0011</td><td>0b0011</td><td><em><a href=#a正常非缓存可缓冲>A正常非缓存可缓冲</a></em><br>Normal Non-cacheable Bufferable</td></tr><tr><td>0b1010</td><td>0b0110</td><td><em><a href=#a写直通不分配>A写直通不分配</a></em><br>Write-Through No-Allocate</td></tr><tr><td>0b1110(0b0110)</td><td>0b0110</td><td><em><a href=#a写直通读分配>A写直通读分配</a></em><br>Write-Through Read-Allocate</td></tr><tr><td>0b1010</td><td>0b1110(0b1010)</td><td><em><a href=#a写直通写分配>A写直通写分配</a></em><br>Write-Through Write-Allocate</td></tr><tr><td>0b1110</td><td>0b1110</td><td><em><a href=#a写直通读写分配>A写直通读写分配</a></em><br>Write-Through Read and Write-Allocate</td></tr><tr><td>0b1011</td><td>0b0111</td><td><em><a href=#a写回不分配>A写回不分配</a></em><br>Write-Back No-Allocate</td></tr><tr><td>0b1111(0b0111)</td><td>0b0111</td><td><em><a href=#a写回读分配>A写回读分配</a></em><br>Write-Back Read-Allocate</td></tr><tr><td>0b1011</td><td>0b1111(0b1011)</td><td><em><a href=#a写回写分配>A写回写分配</a></em><br>Write-Back Write-Allocate</td></tr><tr><td>0b1111</td><td>0b1111</td><td><em><a href=#a写回读写分配>A写回读写分配</a></em><br>Write-Back Read and Write-Allocate</td></tr></tbody></table><h5 id=a-ida531-内存类型需求a531-内存类型需求a><a id="a5.3.1 内存类型需求">A5.3.1 内存类型需求</a></h5><p>本节规定了各类内存的必要行为。</p><p><strong><a id=a设备非缓冲>A设备非缓冲</a></strong></br>设备非缓冲内存的必要行为是：</p><ul><li>写操作的响应必须从最终目的地获得。</li><li>读取的数据必须从最终目的地获得。</li><li>事务是不可修改的，请参见 <em><a href="#a5.2.2 可修改-<strong>AxCACHE[1]</strong>">a5.2.2 可修改-<strong>AxCACHE[1]</strong></a></em> 。</li><li>读取的数据不得预取。</li><li>写事务不得合并。</li></ul><p><strong><a id=a设备可缓冲>A设备可缓冲</a></strong></br>设备缓冲内存类型的必要行为是：</p><ul><li>写操作的响应可以从中间点获得。</li><li>写事务必须在最终目的地及时可见。</li><li>读取的数据必须从最终目的地获得。</li><li>事务是不可修改的，请参见。</li><li>读取的数据不得预取。</li><li>写事务不得合并。</li></ul><p>这两种设备内存类型都是不可修改的。在本规范中，设备内存和不可修改内存这两个术语是可以互换的。</p><p>对于读取事务，设备非缓冲和设备缓冲内存类型的必要行为没有区别。</p><p><strong><a id=a正常非缓存非缓冲>A正常非缓存非缓冲</a></strong></br>正常非缓存非缓冲内存类型的必要行为是：</p><ul><li>写操作的响应必须从最终目的地获得。</li><li>读取的数据必须从最终目的地获得。</li><li>事务是可修改的，请参见 <em><a href="#a5.2.2 可修改-<strong>AxCACHE[1]</strong>">a5.2.2 可修改-<strong>AxCACHE[1]</strong></a></em> 。</li><li>写事务可以合并。</li></ul><p><strong><a id=a正常非缓存可缓冲>A正常非缓存可缓冲</a></strong></br>正常非缓存缓冲内存类型的必要行为是：</p><ul><li>写操作的响应可以从中间点获得。</li><li>写事务必须在最终目的地及时可见，具体定义见 <em><a href="#c1 术语表">c1 术语表</a></em> 。
没有机制可以确定写事务何时在最终目的地可见。</li><li>读取的数据必须从以下任一来源获得：<ul><li>最终目的地。</li><li>正在进行的写事务，目标是最终目的地。</li></ul></li><li>如果从写事务获得读取数据：<ul><li>必须从写的最新版本获得。</li><li>数据不得被缓存，用于服务于后续的读取。</li></ul></li><li>事务是可修改的，请参见 <em><a href="#a5.2.2 可修改-<strong>AxCACHE[1]</strong>">a5.2.2 可修改-<strong>AxCACHE[1]</strong></a></em> 。</li><li>写事务可以合并。</li></ul><p>对于正常非缓存可缓冲读取，数据可以从仍在进行中的写事务中获得，目标是最终目的地。
这些数据与同时传播到最终目的地的读取和写入事务无法区分。
以这种方式返回的读取数据并不表示写事务在最终目的地可见。</p><p><strong><a id=a写直通不分配>A写直通不分配</a></strong></br>写直通不分配内存类型的必要行为是：</p><ul><li>写操作的响应可以从中间点获得。</li><li>写事务必须在最终目的地及时可见，具体定义见 <em><a href="#c1 术语表">C1 术语表</a></em> 。
没有机制可以确定写事务何时在最终目的地可见。</li><li>读取数据可以从中间缓存副本获得。</li><li>事务是可修改的，请参见 <em><a href="#a5.2.2 可修改-<strong>AxCACHE[1]</strong>">a5.2.2 可修改-<strong>AxCACHE[1]</strong></a></em> 。</li><li>读取数据可以预取。</li></ul><p><strong><a id=a写直通读分配>A写直通读分配</a></strong></br>写透读取分配内存类型的必要行为与写透不分配内存相同。出于性能原因：</p><ul><li>建议分配读取事务。</li><li>不建议分配写事务。</li></ul><p><strong><a id=a写直通写分配>A写直通写分配</a></strong></br>透写分配内存类型的必要行为与写透不分配内存相同。出于性能原因：</p><ul><li>不建议分配读取事务。</li><li>建议分配写事务。</li></ul><p><strong><a id=a写回读写分配>A写回读写分配</a></strong></br>写直通读写分配内存类型的必要行为与写直通不分配内存相同。出于性能原因：</p><ul><li>建议分配读取事务。</li><li>建议分配写事务。</li></ul><p><strong><a id=a写回不分配>A写回不分配</a></strong></br>写回不分配内存类型的必要行为是：</p><ul><li>写操作的响应可以从中间点获得。</li><li>写事务不要求在最终目的地可见。</li><li>读取数据可以从中间缓存副本获得。</li><li>事务是可修改的，请参见 <em><a href="#a5.2.2 可修改-<strong>AxCACHE[1]</strong>">a5.2.2 可修改-<strong>AxCACHE[1]</strong></a></em> 。</li><li>读取数据可以预取。</li><li>写事务可以合并。</li><li>读取和写入事务需要进行缓存查找。</li><li>不分配属性是一个分配提示，即它是向内存系统推荐的，出于性能原因，这些事务不会被分配。然而，读取和写入事务的分配并不被禁止。</li></ul><p><strong><a id=a写回读分配>A写回读分配</a></strong></br>写回读取分配内存类型的必要行为与写回不分配内存相同。出于性能原因：</p><ul><li>建议分配读取事务。</li><li>不建议分配写事务。</li></ul><p><strong><a id=a写回写分配>A写回写分配</a></strong></br>写回写分配内存类型的必要行为与写回不分配内存相同。出于性能原因：</p><ul><li>不建议分配读取事务。</li><li>建议分配写事务。</li></ul><p><strong><a id=a写回读写分配>A写回读写分配</a></strong></br>写回读写分配内存类型的必要行为与写回不分配内存相同。出于性能原因：</p><ul><li>建议分配读取事务。</li><li>建议分配写事务。</li></ul><h5 id=a-ida532-内存属性不匹配a532-内存属性不匹配a><a id="a5.3.2 内存属性不匹配">A5.3.2 内存属性不匹配</a></h5><p>多个访问同一内存区域的主机可以使用不匹配的内存属性。
但是，为了功能正确性，必须遵循以下规则：</p><ul><li>访问同一区域内存的所有主机在任何层次结构中必须对该区域内存的缓存性有一致的视图。适用的规则是：<ul><li>如果地址区域是不可缓存的，则所有主机必须使用<strong>AxCACHE[3:2]</strong>都未断言的事务。</li><li>如果地址区域是可缓存的，则所有主机必须使用<strong>AxCACHE[3:2]</strong>的任何一个断言的事务。</li></ul></li><li>不同的主机可以使用不同的分配提示。</li><li>如果一个地址区域是正常的不可缓存，任何主机都可以使用设备内存事务访问它。</li><li>如果一个地址区域具有可缓冲属性，任何主机都可以使用不允许缓冲行为的事务访问它。例如，要求从最终目的地响应的事务不允许缓冲行为。</li></ul><h5 id=a-ida533-改变内存属性a533-改变内存属性a><a id="a5.3.3 改变内存属性">A5.3.3 改变内存属性</a></h5><p>特定内存区域的属性可以从一种类型更改为另一种不兼容的类型。
例如，可以将属性从写直通缓存可用更改为普通不可缓存。
这一变化需要适当的过程来执行更改。</p><p>通常，执行以下过程：</p><ol><li>所有主机停止访问该区域。</li><li>一个主机执行任何必要的缓存维护操作。</li><li>所有主机重新开始访问内存区域，使用新的属性。</li></ol><h5 id=a-ida534-事务缓冲a534-事务缓冲a><a id="a5.3.4 事务缓冲">A5.3.4 事务缓冲</a></h5><p>写入对以下内存类型的访问不需要最终目的地的事务响应，但确实需要确保写入事务及时在最终目的地可见：</p><ul><li>设备可缓冲。</li><li>普通非缓存可缓冲。</li><li>写直通。</li></ul><p>对于写入事务，这三种内存类型要求相同的行为。</p><p>对于读取事务，所需行为如下：</p><ul><li>对于设备可缓冲内存，读取的数据必须从最终目的地获得。</li><li>对于普通非缓存可缓冲内存，读取的数据必须从最终目的地获得，或者从正在前往其最终目的地的写入事务中获得。</li><li>对于写直通内存，读取的数据可以从中间缓存副本中获得。</li></ul><p>除了确保写入事务及时向其最终目的地产生进展之外，中间缓冲区必须表现如下：</p><ul><li>一个可以响应事务的中间缓冲区必须确保随着时间的推移，任何对普通非缓存可缓冲内存的读取事务都向其目的地传播。
这种传播意味着在转发读取事务时，尝试的转发不能无限期继续，且用于转发的数据不能无限期存在。
协议未定义任何确定用于转发读取事务的数据能够存在多久的机制。但是，在这样的机制中，读取数据的行为不能重置数据超时期限。</br>如果没有这一要求，持续对同一位置的轮询可能会阻止保存在缓冲区中的读取的超时，从而阻止读取向其目的地的进展。</li><li>一个可以持有和合并写入事务的中间缓冲区必须确保事务不会无限期保留在其缓冲区中。
例如，合并写入事务不得重置确定写入何时向其最终目的地排出的机制。</br>如果没有这一要求，持续向同一位置写入可能会阻止保存在缓冲区中的写入的超时，从而阻止写入向其目的地的进展。</li></ul><p>有关对这些内存类型的读取访问所需行为的信息，请参见：</p><ul><li><em><a href=#a设备可缓冲>A设备可缓冲</a></em></li><li><em><a href=#a正常非缓存可缓冲>A正常非缓存可缓冲</a></em></li><li><em><a href=#a写直通不分配>A写直通不分配</a></em></li></ul><h5 id=a-ida535-设备内存实例a535-设备内存实例a><a id="a5.3.5 设备内存实例">A5.3.5 设备内存实例</a></h5><p>该规范支持设备非缓冲和设备缓冲内存类型的组合使用，以强制写入事务到达其最终目的地，并确保发起的主机知道事务何时对所有其他主机可见。</p><p>标记为设备缓冲的写入事务必须及时地到达其最终目的地。
然而，该事务的写入响应可以由一个中间缓冲区发出信号。
因此，发起的主机无法知道写入何时对所有其他主机可见。</p><p>如果主机发起了一个设备缓冲写入事务，或一系列写入事务，随后是一个设备非缓冲写入事务，并且所有事务使用相同的AXI ID，
则AXI排序要求强制所有设备缓冲写入事务在设备非缓冲事务给予响应之前到达最终目的地。
因此，设备非缓冲事务的响应表明所有事务对所有主机可见。</p><h4 id=a-ida54-协议错误a54-协议错误a><a id="a5.4 协议错误">A5.4 协议错误</a></h4><p>AXI协议定义了两类协议错误，软件协议错误和硬件协议错误。</p><h5 id=a-ida541-软件协议错误a541-软件协议错误a><a id="a5.4.1 软件协议错误">A5.4.1 软件协议错误</a></h5><p>软件协议错误发生在多个访问同一位置时，访问的共享性或缓存属性不匹配。
软件协议错误可能导致一致性丧失，并导致数据值损坏。
该协议要求系统在出现软件协议错误时不发生死锁，并且事务始终在系统中进行推进。</p><p>对一个4KB内存区域的访问导致的软件协议错误不得在另一个4KB内存区域造成数据损坏。
对于保存在正常内存中的位置，可以使用适当的软件屏障和缓存维护将内存位置恢复到定义状态。</p><p>在访问外设时，如果使用可修改事务（<strong>AxCACHE[1]被断言</strong>），则无法保证外设的正常操作。
唯一的要求是外设继续以遵循协议的方式响应事务。
将一个错误访问的外设恢复到已知工作状态所需的事件序列是实现定义的。</p><h5 id=a-ida542-硬件协议错误a542-硬件协议错误a><a id="a5.4.2 硬件协议错误">A5.4.2 硬件协议错误</a></h5><p>硬件协议错误被定义为任何不是软件协议错误的协议错误。
硬件协议错误不需要支持。</p><p>如果发生硬件协议错误，则无法保证从错误中恢复。系统可能会崩溃、锁死或遭遇其他不可恢复的故障。</p><h4 id=a-ida55-内存保护和realm管理扩展a55-内存保护和realm管理扩展a><a id="a5.5 内存保护和realm管理扩展">A5.5 内存保护和realm管理扩展</a></h4><p>AXI提供可以用来保护内存免受意外事务的信号。</p><p>通过领域管理扩展（RME），内存保护也可以被扩展。
它提供基于硬件的隔离，允许执行上下文在不同的安全状态下运行并共享系统中的资源。</p><p>当使用RME时，它扩展了物理寻址和未转换事务的地址空间，影响缓存维护操作的运行并扩展了MPAM信号。
保护信号如 <em><a href="#表 a5.5">表 A5.5</a></em> 所示</p><p><a id="表 a5.5">表 A5.5</a> 保护信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWPROT</strong><br><strong>ARPROT</strong></td><td>3</td><td>−</td><td>请求的访问属性可用于保护内存免受意外事务。</td></tr><tr><td><strong>AWNSE</strong><br><strong>AWNSE</strong></td><td>1</td><td>0b0</td><td>扩展的物理地址空间包含Root和Realm两种。</td></tr></tbody></table><p>属性PROT_Present用于确定接口上是否存在<strong>AxPROT</strong>信号。
一个不使用保护属性的从机可以从其接口中省略<strong>AxPROT</strong>输入。</p><p><a id="表 a5.6">表 A5.6</a> PROT_Present属性</p><table><thead><tr><th>PROT_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWPROT</strong>和<strong>ARPROT</strong> 都存在</td></tr><tr><td>False</td><td></td><td><strong>AWPROT</strong>和<strong>ARPROT</strong> 都不存在</td></tr></tbody></table><p>当使用RME时，RME_Support属性被设置为True，并且<strong>AxNSE</strong>信号出现在一个接口上。</p><p><a id="表 a5.7">表 A5.7</a> RME_Support属性</p><table><thead><tr><th>RME_Support</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>RME支持。<br>所有RME信号都出现在接口上。</td></tr><tr><td>False</td><td>Y</td><td>RME不支持。<br>所有RME讯号都不出现在接口上。</td></tr></tbody></table><p>保护属性分为三个部分：</p><p><strong>非特权与特权</strong></p><p>AXI主机可能支持多于一个级别的操作特权，并且可以选择性地将这一特权概念扩展到内存访问。<br><strong>AxPROT[0]</strong>将访问标识为非特权或特权：</p><ul><li>0b0：非特权</li><li>0b1：特权</li></ul><p>某些主机支持多个特权级别，请参阅所选处理器的文档以确定与AXI特权级别的映射。
AXI提供的唯一区分是特权和非特权访问之间的区分。</p><p><strong>非安全与安全</strong></p><p>如果AXI主机支持不同的安全操作状态，它可以将其扩展到内存访问中，使用安全属性。
具有不同安全属性的请求可以被视为占用不同的地址空间，因此同一地址可以根据安全属性解码到不同的位置。</p><p><strong>AxPROT[1]</strong>和<strong>AxNSE</strong>信号用于定义安全属性，如 <em><a href="#表 a5.8">表 A5.8</a></em> 所示。</p><p><a id="表 a5.8">表 A5.8</a> 安全属性</p><table><thead><tr><th><strong>AxNSE</strong></th><th><strong>AxPROT[1]</strong></th><th>安全属性</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Secure</td></tr><tr><td>0</td><td>1</td><td>Non-secure</td></tr><tr><td>1</td><td>0</td><td>Root</td></tr><tr><td>1</td><td>1</td><td>Realm</td></tr></tbody></table><p><strong>数据与指令</strong></p><p><strong>AxPROT[2]</strong>表示事务是指令访问或数据访问：</p><ul><li>0b0: 数据访问</li><li>0b1: 指令访问</li></ul><p>AXI协议将此指示定义为提示。在所有情况下它并不一定准确。
例如，当一个事务包含指令和数据项的混合时。建议在访问被确定为指令访问之前，主机将AxPROT[2]设置为LOW以指示数据访问。</p><h4 id=a-ida56-内存加密上下文a56-内存加密上下文a><a id="a5.6 内存加密上下文">A5.6 内存加密上下文</a></h4><p>内存加密上下文（MEC）是对Arm域管理扩展（RME）的扩展，允许每个域拥有其独特的加密上下文。</p><p>MEC扩展将内存加密上下文分配给域物理地址空间内的所有内存访问。
所有内存事务都与一个MECID相关，该ID由安全状态、转换方案、转换表和MEC系统寄存器决定。
MECID被内存加密引擎用作加密上下文表（无论是密钥还是变更）的索引，这些上下文有助于外部内存加密。</p><p>使用MEC可以通过使每组域数据采用不同的加密方式来帮助保护内存中的域数据。
这意味着，能够访问物理内存设备并能够解密一组域数据的恶意主机，无法使用相同的解密方法来访问其他组域数据。
在加密点（PoE）之前，在组件之间移动的数据是明文形式。</p><p>R-EL2上的域管理软件控制MECID的策略和分配给域的信息。</p><p>有关MEC的更多信息，请参见 <em><a href=#[3]>[3]</a></em> 和 <em><a href=#[4]>[4]</a></em> 。</p><p>请注意，MEC架构规范 <em><a href=#[3]>[3]</a></em> 详细说明了MECID值不匹配时的几种实现选项。
此MEC实现假设主机和缓存不执行任何MECID检查。</p><p>例如，如果与一个MECID相关的读取访问目标位置在缓存中有一个副本并且与不同的MECID相关，那么读取访问就会成功，好像MECID值没有不匹配一样。
这里不需要额外的保护，因为R-EL2上的域管理软件确保一个上下文无法访问属于不同上下文的位置，从而确保不会发生明文泄漏。</p><h5 id=a-ida561-mec信号a561-mec信号a><a id="a5.6.1 mec信号">A5.6.1 mec信号</a></h5><p>MEC_Support属性确定接口是否支持内存加密上下文MEC。</p><p><a id="表 a5.9">表 A5.9</a> MEC_Support属性</p><table><thead><tr><th>MEC_Support</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>MEC支持。<br><strong>AxMECID</strong>信号存在。</td></tr><tr><td>False</td><td>Y</td><td>MEC不支持。<br><strong>AxMECID</strong>信号不存在。</td></tr></tbody></table><p>MEC是RME的扩展，因此如果RME_Support属性为False，则MEC_Support必须为False。<br><em><a href="#表 a5.10">表 A5.10</a></em> 中信号是支持MEC所必需的。</p><p><a id="表 a5.10">表 A5.10</a> MECID信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWMECID</strong><br><strong>ARMECID</strong></td><td>MECID_WIDTH</td><td>全0</td><td>RME内存加密上下文ID</td></tr></tbody></table><p>参数MECID_WIDTH定义了宽度。</p><p><a id="表 a4.11">表 A4.11</a> MECID_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>MECID_WIDTH</td><td>0&mldr;16</td><td>0</td><td><strong>AxMECID</strong>的位宽。</td></tr></tbody></table><p>以下规则适用于MECID_WIDTH属性：</p><ul><li>如果MECID_WIDTH为0，则<strong>AWMECID</strong>和<strong>ARMECID</strong>不在接口上。</li><li>如果MEC_Support为False，则<strong>MECID_WIDTH</strong>必须为0。</li><li>如果MEC_Support为True，则<strong>MECID_WIDTH</strong>必须不为0。</li></ul><blockquote><p>Note：</br>注意MECID的宽度并不表示组件使用了多少不同的值。通过使用更窄的内部宽度，可能可以减少MECID的存储需求。</p></blockquote><p>如果两个组件之间的MECID位宽不同，可以进行零扩展或截去高位，具体取决于情况。
此调整仅在将公共MECID宽度设置为系统中任何MEC兼容组件支持的最小MECID宽度时，才能产生正确的MEC操作。</p><p>根据MEC_Support属性的值，主机和从机之间的兼容性如 <em><a href="#表 a5.12">表 A5.12</a></em> 所示。</p><p><a id="表 a5.12">表 A5.12</a> MEC_Support兼容性</p><table><thead><tr><th>MEC_Support</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容。<br><strong>AxMECID</strong>输入连接为LOW</td></tr><tr><td>从机：True</td><td>兼容。<br>下游内存使用MEC未加密。</td><td>兼容</td></tr></tbody></table><h5 id=a-ida562-mecid使用a562-mecid使用a><a id="a5.6.2 mecid使用">A5.6.2 MECID使用</a></h5><p>MECID值范围是有界的，依赖于被访问的物理地址空间。</p><p><a id="表 a5.13">表 A5.13</a> 在每个物理地址空间可能的MECID</p><table><thead><tr><th><strong>AxNSE</strong></th><th><strong>AxPROT[1]</strong></th><th>物理地址空间</th><th>MECID</th></tr></thead><tbody><tr><td>0b0</td><td>0b0</td><td>Secure</td><td>必须为0</td></tr><tr><td>0b0</td><td>0b1</td><td>Non-secure</td><td>必须为0</td></tr><tr><td>0b1</td><td>0b0</td><td>Root</td><td>必须为0</td></tr><tr><td>0b1</td><td>0b1</td><td>Realm</td><td>任何值</td></tr></tbody></table><p>MECID 不适用，并且对于以下请求操作码可以取任何值：</p><ul><li>CMO</li><li>CleanInvalid</li><li>MakeInvalid</li><li>CleanShared</li><li>CleanSharedPersist</li><li>InvalidateHint</li><li>StashTranslation</li><li>UnstashTranslation</li></ul><p>MECID 不适用，且对于以下请求操作码必须为 0：</p><ul><li>DVM Complete</li></ul><p>传播事务并在其从机和主机上支持 MECID 的组件必须在适用请求中保留 MECID。
执行地址转换的组件可能会更改 MECID。</p><p>存储与 MECID 关联数据的高速缓存必须也存储 MECID，并在写回时与数据一同提供。</p><p>可以使用 CleanInvalidPoPA 操作来确保从加密点上游的所有缓存中清理并使缓存行失效。
有关 CleanInvalidPoPA 的更多信息，请参见 <em>&lt;a href="#a10.9 缓存维护和rme>A10.9 缓存维护和RME</a></em> 。</p><h4 id=a-ida57-多区域接口a57-多区域接口a><a id="a5.7 多区域接口">A5.7 多区域接口</a></h4><p>本节描述了在请求中使用区域ID的方式，以支持单个接口中具有多个地址区域的接口。</p><h5 id=a-ida571-区域id信号a571-区域id信号a><a id="a5.7.1 区域id信号">A5.7.1 区域ID信号</a></h5><p>属性 REGION_Present 决定接口是否支持区域ID信号。</p><p><a id="表 a5.14">表 A5.14</a> REGION_Present属性</p><table><thead><tr><th>REGION_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWREGION</strong>和<strong>ARREGION</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWREGION</strong>和<strong>AWREGION</strong>不存在</td></tr></tbody></table><p>指示区域的信号如 <em><a href="#表 a5.15">表 A5.15</a></em> 所示。</p><p><a id="表 a5.15">表 A5.15</a> Region信号</p><table><thead><tr><th>名字</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWREGION</strong><br><strong>ARREGION</strong></td><td>4</td><td>0x0</td><td>一个可以用于识别不同地址区域的4位区域ID</td></tr></tbody></table><h5 id=a-ida572-区域id的使用a572-区域id的使用a><a id="a5.7.2 区域ID的使用">A5.7.2 区域ID的使用</a></h5><p>4位区域ID可用于唯一标识最多16个不同的区域。
区域标识符可以提供更高位地址位的解码。
区域标识符在任何4K字节的地址空间内必须保持不变。</p><p>使用区域标识符意味着从机上的单个物理接口可以提供多个逻辑接口，每个接口在系统地址映射中具有不同的位置。
使用区域标识符意味着从机不必支持不同逻辑接口之间的地址解码。</p><p>本规范期望互连在对具有多个逻辑接口的单个从机执行地址解码功能时产生<strong>AxREGION</strong>信号。
如果从机在系统地址映射中只有一个物理接口，则互连必须使用默认的<strong>AxREGION</strong>值。</p><p>区域ID有几种使用模型，包括但不限于以下内容：</p><ul><li>外设可以在地址映射中的不同位置具有其主要数据路径和控制寄存器，并通过单个接口访问，无需从机执行地址解码。</li><li>从机可以在不同的内存区域表现出不同的行为。例如，从机可能在一个区域提供读写访问，但在另一个区域只提供只读访问。</li></ul><p>从机必须确保正确的协议信号和事务的正确顺序得到维护。
从机必须确保对两个请求不同区域的相同事务ID的响应按正确顺序提供。</p><p>从机还必须确保<strong>AxREGION</strong>任何值的正确协议信号。
如果从机实现的区域少于十六个，则从机必须确保对任何对不支持区域的访问提供正确的协议信号。</p><p>如何实现这一点是实现定义的。例如，从机可能通过以下方式确保此点：</p><ul><li>对于任何访问不支持区域的事务提供错误响应。</li><li>在所有不支持区域之间对受支持区域进行别名，以确保对所有访问给出合规的协议响应。</li></ul><p><strong>AxREGION</strong>信号仅提供现有地址空间的地址解码，可以被从机用来消除地址解码功能的需要。信号不创建新的独立地址空间。</p><p><strong>AxREGION</strong>必须仅出现在地址解码功能下游的接口上。</p><h4 id=a-ida58-qos信号a58-qos信号a><a id="a5.8 qos信号">A5.8 Qos信号</a></h4><p>AXI支持服务质量（Quality of Service）QoS方案通过以下特性：</p><ul><li><em><a href="#a5.8.1 qos 标识">A5.8.1 QoS 标识</a></em></li><li><em><a href="#a5.8.2 qos 接受标识">A5.8.2 QoS 接受标识</a></em></li></ul><h5 id=a-ida581-qos-标识a581-qos-标识a><a id="a5.8.1 qos 标识">A5.8.1 QoS 标识</a></h5><p>AXI请求有一个可选的标识符，可以用来区分不同的流量流，如 <em><a href="#表 a5.16">表 A5.16</a></em> 所示。</p><p><a id="表 a5.16">表 A5.16</a> QoS信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWQOS</strong><br><strong>ARQOS</strong></td><td>4</td><td>0x0</td><td>QoS用于区分不同的流量流</td></tr></tbody></table><p>QOS_Present属性用于定义接口是否包含<strong>AxQOS</strong>信号。</p><p><a id="表 a5.17">表 A5.17</a> QOS_Support属性</p><table><thead><tr><th>QOS_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td><strong>AWQOS</strong>和<strong>ARQOS</strong>存在</td></tr><tr><td>False</td><td></td><td><strong>AWQOS</strong>和<strong>ARQOS</strong>不存在</td></tr></tbody></table><p>该协议未指定QoS标识的具体使用方式。
建议将<strong>AxQOS</strong>用作关联写或读请求的优先级指示符，其中较高的值表示更高优先级的请求。</p><p><strong>使用QoS标识符</strong></p><p>主机可以生成自己的<strong>AxQOS</strong>值，如果它可以生成多个流量流，可以为不同的流选择不同的QoS值。</p><p>支持QoS需要对正在使用的QoS方案有系统级的理解，以及所有参与组件之间的协作。
因此，建议主机组件包括一些可编程性，以可用于控制任何给定场景下使用的确切QoS值。</p><p>如果主机组件不支持可编程QoS方案，则可以使用表示其生成的事务相对优先级的QoS值。
这些值随后可以映射到适当的替代系统级QoS值。</p><p>该规范预期许多互连组件实现将支持可编程寄存器，这些寄存器可用于将QoS值分配给连接的主机。
这些值替代主机提供的编程或默认QoS值。</p><p>QoS的默认系统级实现是任何具有选择多个要处理的事务的组件首先选择具有更高QoS值的请求进行处理。
当没有其他AXI约束要求按特定顺序处理请求时，才会进行此选择。
这意味着AXI排序规则优先于QoS目的的排序。</p><h5 id=a-ida582-qos接受标识a582-qos接受标识a><a id="a5.8.2 qos接受标识">A5.8.2 qos接受标识</a></h5><p><em><a href="#表 a5.18">表 A5.18</a></em> 中显示的QoS接受指标是来自从机的输出信号，指示它接受的最低QoS值而不会产生延迟。
这些信号与<strong>ACLK</strong>同步，但与其他AXI通道无关。</p><p><a id="表 a5.18">表 A5.18</a> QoS接受信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>VAWQOSACCEPT</strong></td><td>4</td><td>0x0</td><td>来自从机的输出，指示其接受来自AW通道请求的QoS值。</td></tr><tr><td><strong>VARQOSACCEPT</strong></td><td>4</td><td>0x0</td><td>来自从机的输出，指示其接受来自AR通道请求的QoS值。</td></tr></tbody></table><p>QoS接受信号旨在用于具有不同资源的从机组件，以满足不同的QoS值，这通常适用于内存控制器。
当较低QoS值所需的资源正在使用时，从机可以表明它仅接受特定QoS值或更高的请求。</p><p>QoS接受信号可以作为主机的输入，该接口可能有多个不同的请求可供选择。
这允许主机仅发出有可能被接受的请求，从而避免接口的不必要阻塞。</p><p>通过防止可能停滞一段时间的请求被发出，接口仍然可用于发出可能在稍后时间抵达的更高优先级请求。</p><p>在本规范中，术语<strong>VAxQOSACCEPT</strong>统称为<strong>VAWQOSACCEPT</strong>和<strong>VARQOSACCEPT</strong>信号。
<strong>VAxQOSACCEPT</strong>信号的规则和建议如下：</p><ul><li>任何QoS级别等于或高于<strong>VAxQOSACCEPT</strong>的请求将被从机接受。</li><li>任何QoS级别低于<strong>VAxQOSACCEPT</strong>的请求可能会被显著延迟。</br>本规范未定义从机必须在何种时间段内接受等于或高于所指QoS级别的请求。
然而，预计对于给定的从机，接受事务所需的时钟周期数是确定性的最大值，这在考虑到实现方面（如时钟域交叉比率）后得出。</li><li>允许从机接受低于<strong>VAxQOSACCEPT</strong>信号所指示的QoS级别的请求，但预计该请求可能会遭受显著延迟。
虽然从机延迟优先级低于QoS接受级别的请求是可以接受的，但建议该事务不应无限期延迟。</li></ul><p>优先级低的事务在接口发出的原因有几个，例如：</p><ul><li>QoS接受值的变化与组件适应该变化之间的延迟。</li><li>需要对此事务进行以避免阻塞较高优先级请求的头部。</li><li>由于饥饿预防的原因，要求对此事务进行。</li></ul><p><em><a href="#表 a5.19">表 A5.19</a></em> 中显示的QoS_Accept属性用于定义接口是否包含QoS接受指示信号。</p><p><a id="表 a5.19">表 A5.19</a> QoS_Accept属性</p><table><thead><tr><th>Qos_Accept</th><th>默认</th><th>描述\</th></tr></thead><tbody><tr><td>True</td><td></td><td>接口包含<strong>VAWQOSACCEPT</strong>和<strong>VARQOSACCEPT</strong>信号。</td></tr><tr><td>False</td><td>Y</td><td>接口不包含<strong>VAWQOSACCEPT</strong>和<strong>VARQOSACCEPT</strong>信号</td></tr></tbody></table><h3 id=a-ida第6章-事务标识和顺序a第6章-事务标识和顺序a><a id="a第6章 事务标识和顺序">A第6章 事务标识和顺序</a></h3><p>本章描述了事务标识符及其如何用于控制事务的顺序。
它包含以下部分：</p><ul><li><em><a href="#a6.1 事务id">A6.1 事务id</a></em></li><li><em><a href="#a6.2 唯一id">A6.2 唯一id</a></em></li><li><em><a href="#a6.3 请求顺序">A6.3 请求顺序</a></em></li><li><em><a href="#a6.4 互联使用事务id">A6.4 互联使用事务id</a></em></li><li><em><a href="#a6.5 写数据和响应顺序">A6.5 写数据和响应顺序</a></em></li><li><em><a href="#a6.6 读数据顺序">A6.6 读数据顺序</a></em></li></ul><h4 id=a-ida61-事务ida61-事务ida><a id="a6.1 事务id">A6.1 事务id</a></h4><p>AXI协议包含一个事务标识符（AXI ID）。
主机可以使用AXI ID来识别必须按顺序返回的实物。</p><p>所有具有给定AXI ID值的事务必须保持有序，但对于不同ID值的事务没有排序限制。</p><p>单个物理端口可以通过作为多个逻辑端口来支持乱序事务，每个端口按顺序处理其事务。</p><p>通过使用AXI ID，主机可以发出事务而无需等待早期事务完成这可以提高系统性能，
因为它使事务的并行处理成为可能。</p><h5 id=a-ida611-事务标识信号a611-事务标识信号a><a id="a6.1.1 事务标识信号">A6.1.1 事务标识信号</a></h5><p>读写请求、读取数据和写入响应通道包括一个事务ID信号。</p><p><a id="表 a6.1">表 A6.1</a> ID信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWID</strong><br><strong>BID</strong></td><td>ID_W_WIDTH</td><td>全0</td><td>用于写请求和响应排序的事务标识符</td></tr><tr><td><strong>ARID</strong><br><strong>RID</strong></td><td>ID_R_WIDTH</td><td>全0</td><td>用于读请求、响应和读数据排序的事务标识符</td></tr></tbody></table><p><em><a href="#表 a6.2">表 A6.2</a></em> 中描述了ID宽度属性。</p><p><a id="表 a6.2">表 A6.2</a> ID位宽属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>ID_W_WIDTH</td><td>0&mldr;32</td><td>−</td><td>写通道<strong>AWID</strong>、<strong>BID</strong>的位宽</td></tr><tr><td>ID_R_WIDTH</td><td>0&mldr;32</td><td>−</td><td>读通道</strong>ARID</strong>、<strong>RID</strong>的位宽</td></tr></tbody></table><p>如果宽度属性为零，则相关信号不存在。</p><p>一个不支持请求和响应重排序的主机，或者只有一个未完成事务的主机，可以从其接口中省略 ID 信号。
相应的从机必须将其 AxID 输入固定为低电平。</p><p>一个不重排序请求或响应的从机不需要使用 ID 值。
如果一个从机不包含 ID 信号，则不能连接到具有 ID 信号的主机。
因为主机要求从<strong>AWID</strong>和<strong>ARID</strong>对应<strong>BID</strong>和<strong>RID</strong>。</p><h4 id=a-ida62-唯一ida62-唯一ida><a id="a6.2 唯一id">A6.2 唯一id</a></h4><p>唯一ID指示器是一个可选标志，指示在读或写地址通道上的请求是否使用了对于在途事务唯一的AXI标识符。
在读和写响应通道上也有一个相应的信号，用于指示某个事务使用了唯一ID。</p><p>唯一ID指示器可以在AXI主机下游使用，以确定何时请求需要相对于该主机的其他请求进行排序。
那些不需要排序的请求可能在下游组件中不需要跟踪。</p><p>Unique_ID_Support属性用于指示接口是否支持唯一ID指示。</p><p><a id="表 a6.3">表 A6.3</a> Unique_ID_Support 属性</p><table><thead><tr><th>Unique_ID_Support</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>唯一ID信号存在</td></tr><tr><td>False</td><td>Y</td><td>唯一ID信号不存在</td></tr></tbody></table><p>当Unique_ID_Support为真时，以下信号包含在读取请求、读取数据、写入请求和写入响应通道中。</p><p><a id="表 a6.4">表 A6.4</a> 唯一ID信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWIDUNQ</strong><br><strong>BIDUNQ</strong><br><strong>ARIDUNQ</strong><br><strong>RIDUNQ</strong></td><td>1</td><td>0b0</td><td>如果断言为高。则本次传输ID是唯一的</td></tr></tbody></table><p>以下规则适用于唯一 ID 指示符：</p><ul><li>当<strong>AWIDUNQ</strong>被断言时，该主机不得有同一<strong>AWID</strong>值的未完成写入事务。</li><li>当<strong>AWIDUNQ</strong>被断言时，该主机不得发出与未完成写入事务具有相同<strong>AWID</strong>的写入请求。</li><li>如果请求的<strong>AWIDUNQ</strong>断言被解除，
则对应的<strong>BIDUNQ</strong>信号必须在单个传输响应中或在多传输响应的完成部分中被去分断言。</li><li>如果请求的<strong>AWIDUNQ</strong>被断言，
则对应的<strong>BIDUNQ</strong>信号必须在单个传输响应中或在多传输响应的完成部分中被断言。</li><li>当<strong>ARIDUNQ</strong>被断言时，该主机不得有同一<strong>ARID</strong>值的未完成读取事务。</li><li>当<strong>ARIDUNQ</strong>被断言时，该主机不得发出与未完成读取事务具有相同<strong>ARID</strong>的读取请求。</li><li>如果请求的<strong>ARIDUNQ</strong>被去分断言，则必须为该事务的所有响应传输解除相应的<strong>RIDUNQ</strong>信号断言。</li><li>如果请求的<strong>ARIDUNQ</strong>被断言，则必须为该事务的所有响应传输断言相应的<strong>RIDUNQ</strong>信号。</li><li>对于包含读取和写入响应的原子事务，还适用附加规则：<ul><li>如果原子请求的<strong>AWIDUNQ</strong>被取消断言，则必须为该事务的所有响应传输解除相应的<strong>RIDUNQ</strong>信号断言。</li><li>如果原子请求的<strong>AWIDUNQ</strong>被断言，则必须为该事务的所有响应传输断言相应的<strong>RIDUNQ</strong>信号。</li></ul></li></ul><p>一个事务从<strong>AxVALID</strong>被断言的周期开始，直到最终响应传输被主机接受的周期结束。
如果接口包含<strong>BCOMP</strong>，则该事务在收到断言<strong>BCOMP</strong>的响应之前被视为未完成。</p><p>一个原子事务在写入和读取响应都被主机接受之前是未完成的，参见 <em><a href=#a7.4原子事务>A7.4原子事务</a></em> 。</p><p>某些事务类型规定如果存在，则需要断言<strong>AxIDUNQ</strong>。
如果没有指定，即使没有使用相同 ID 的未完成事务，断言<strong>AxIDUNQ</strong>是可选的。</p><h4 id=a-ida63-请求顺序a63-请求顺序a><a id="a6.3 请求顺序">A6.3 请求顺序</a></h4><p>AXI请求排序模型是基于事务标识符的使用，该标识符在<strong>ARID</strong>或<strong>AWID</strong>上发出信号。</p><p>具有相同ID和目标的同一通道上的事务请求保证保持顺序。<br>具有相同ID的事务响应将以与请求发出相同的顺序返回。</p><p>排序模型不对以下情况提供任何排序保证：</p><ul><li>来自不同主机的事务。</li><li>读和写事务。</li><li>具有不同ID的事务。</li><li>发送到不同外设区域的事务。</li><li>发送到不同内存位置的事务。</li></ul><p>如果主机要求在没有排序保证的事务之间进行排序，则主机必须等到收到第一个事务的响应后再发出第二个事务。</p><h5 id=a-ida631-内存位置和外设区域a631-内存位置和外设区域a><a id="a6.3.1 内存位置和外设区域">A6.3.1 内存位置和外设区域</a></h5><p>AMBA中的地址映射由内存位置和外设区域组成。<br>内存位置具有以下所有属性:</p><ul><li>从内存位置读取一个字节返回该字节位置最后写入的值。</li><li>向内存位置的一个字节写入更新该位置的值为后续读取该位置获得的新值。</li><li>对内存位置的读取或写入对任何其他内存位置没有副作用。</li><li>每个位置都有内存观察保证。</li><li>内存位置的大小等于该组件的单拷贝原子性大小。</li></ul><p>外设区域具有以下所有属性：</p><ul><li>从外设区域中的一个地址读取并不一定返回最后写入该地址的值.</li><li>向外设区域中的一个字节地址写入并不一定将该地址的值更新为后续读取获得的新值.</li><li>访问外设区域内的一个地址可能对该区域内的其他地址产生副作用。</li><li>每个区域都有外设观察保证</li><li>外设区域的大小由实现定义，但必须包含在一个从机内。</li><li>一个事务可以针对一个或多个地址位置，这些位置由<strong>AxADDR</strong>和任何相关限定符如地址空间确定。</li><li>仅对同一内存位置或外设区域的访问之间提供排序保证。</li><li>针对外设区域的事务必须完全包含在该区域内。</li><li>跨越多个内存位置的事务具有多个排序保证。</li></ul><h5 id=a-ida362-设备和正常请求a362-设备和正常请求a><a id="a3.6.2 设备和正常请求">A3.6.2 设备和正常请求</a></h5><p>事务可以是设备类型或普通类型。</p><p><strong>设备事务</strong></p><p>一个读取或写入请求，其中<strong>AxCACHE[1]</strong>失效。</p><p>设备事务可用于访问外设区域或内存位置。</p><p><strong>普通事务</strong></p><p>一个读取或写入请求，其中<strong>AxCACHE[1]</strong>有效。</p><p>普通事务用于访问内存位置，且不应预期用于访问外围区域。</p><p>对外设区域的普通访问必须以符合协议的方式完成，但结果是IMPLEMENTATION DEFINED。</p><h5 id=a-ida363-观察和完成定义a363-观察和完成定义a><a id="a3.6.3 观察和完成定义">A3.6.3 观察和完成定义</a></h5><p>对于对外设区域的访问，当设备读取或写入访问DRW1在DRW2到达从机之前时，设备读取或写入访问DRW2会观察到DRW1。</p><p>对于对内存位置的访问，以下所有条件均适用：</p><ul><li>如果W2在W1之后生效，则写入W1会被写入W2观察到。</li><li>如果R1从写入W3返回数据，而W2在W3之后，则读取R1会被写入W2观察到。</li><li>如果R2从W1或写入W3返回数据，而W3在W1之后，则写入W1会被读取R2观察到。</li></ul><p>读取R1或写入W1可以是设备类型或普通类型。</p><p>写入和读取完成的定义如下：</p><p><strong>写入完成响应</strong></p><p>在关联的<strong>BRESP</strong>握手被发出时的周期，
当<strong>BVALID</strong>，<strong>BREADY</strong>和<strong>BCOMP</strong>（如果存在）被断言。</p><p><strong>读取完成响应</strong></p><p>在最后一个关联的<strong>RDATA</strong>握手被发出时的周期，当<strong>RVALID</strong>，<strong>RLAST</strong>和<strong>RREADY</strong>被断言。</p><h5 id=a-ida634-主机顺序保证a634-主机顺序保证a><a id="a6.3.4 主机顺序保证">A6.3.4 主机顺序保证</a></h5><p>有三种类型的排序模型保证：</p><ul><li>在收到<strong>完成响应之前</strong>的可观察性保证。</li><li><strong>完成响应中</strong>的可观察性保证。</li><li><strong>响应</strong>排序保证。</li></ul><p><strong>在收到完成响应之前的可观察性保证</strong></p><p>以下所有保证适用于使用相同 ID 的同一主机的事务：</p><ul><li>设备写入 DW1 保证在目的地到达之前先于设备写入 DW2 到达，其中 DW2 在 DW1 之后发布，且针对相同的外设区域。</li><li>设备读取 DR1 保证在目的地到达之前先于设备读取 DR2 到达，其中 DR2 在 DR1 之后发布，且针对相同的外设区域。</li><li>写入 W1 保证被写入 W2 观察到，其中 W2 在 W1 之后发布，且针对相同的内存位置。</li><li>一个被读取 R2 观察到的写入 W1 保证被读取 R3 观察到，其中 R3 在 R2 之后发布，且针对相同的内存位置。</li></ul><p><strong>从完成响应中的可观察性保证</strong></p><p>完成响应的保证如下：</p><ul><li>对于读取请求，完成响应保证它对来自任何主机的后续读取或写入请求是可观察的。</li><li>对于不可缓冲的写入请求，完成响应保证它对来自任何主机的后续读取或写入请求是可观察的。</li><li>对于可缓冲的写入请求，完成响应可以从一个中间点发送。它并不保证写入在端点完成，但保证可观察性，这取决于请求的域：<ul><li>不可共享：仅对发布主机可观察。</li><li>可共享：对共享域中的所有其他主机可观察。</li><li>系统：对所有其他主机可观察。</li></ul></li></ul><p>有关域的更多信息，请参阅 <em><a href="#a9.3 缓存一致性和域">A9.3 缓存一致性和域</a></em> 。</p><p><strong>响应排序保证</strong></p><p>事务响应具备以下所有排序保证：</p><ul><li>读取 R1 保证在读取 R2 的响应之前收到响应，其中 R2 是在 R1 之后从同一主机发布且具有相同 ID 的请求。</li><li>写入 W1 保证在写入 W2 的响应之前收到响应，其中 W2 是在 W1 之后从同一主机发布且具有相同 ID 的请求。</li></ul><h5 id=a-ida635-从机顺序需求a635-从机顺序需求a><a id="a6.3.5 从机顺序需求">A6.3.5 从机顺序需求</a></h5><p>为了满足主机顺序的保障，从机也必须满足以下要求。</p><p><strong>外设位置</strong></p><ul><li>对于外设位置，对外设位置事务的执行顺序是实现定义的。该执行顺序通常预期与到达顺序相匹配，但这并不是要求。</li></ul><p><strong>内存位置</strong></p><ul><li>写入 W1 必须在写入 W2 之前，W1 和 W2 是同一内存位置相同 ID 的访问，W2 的接收时间晚于 W1 的接收时间。</li><li>写入 W1 必须在写入 W2 之前，W1 和 W2 是同一内存位置的访问，W2 的接收时间晚于 W1 的完成响应。</li><li>写入 W1 必须在读取 R2 之前，W1 和 R2 是同一内存位置的访问，R2 的接收时间晚于 W1 的完成响应。</li><li>读取 R1 必须在写入 W2 之前，W1 和 W2 是同一内存位置的访问，W2 的接收时间晚于 R1 的完成响应。</li></ul><p><strong>响应排序要求</strong></p><ul><li>对读取 R1 的响应必须在对读取 R2 的响应之前返回，R2 是在 R1 之后接收的，相同 ID。</li><li>对写入 W1 的响应必须在对写入 W2 的响应之前返回，W2 是在 W1 之后接收的，相同 ID。</li></ul><h5 id=a-ida366-互联顺序需求a366-互联顺序需求a><a id="a3.6.6 互联顺序需求">A3.6.6 互联顺序需求</a></h5><p>互连组件具有以下属性：</p><ul><li>在一个端口接收到请求，并在另一个端口发出或响应。</li><li>在一个端口接收到响应，并在另一个端口发出或处理。</li></ul><p>当互连发出请求或响应时，必须遵循以下要求：</p><ul><li>在发出读取 R2 请求之前，必须发出读取 R1 请求，其中 R2 是在 R1 之后接收的，具有相同的 ID，并且指向相同或重叠的位置。</li><li>在发出写入 W2 请求之前，必须发出写入 W1 请求，其中 W2 是在 W1 之后接收的，具有相同的 ID，并且指向相同或重叠的位置。</li><li>在发出设备读取 DR2 请求之前，必须发出设备读取 DR1 请求，其中 DR2 是在 DR1 之后接收的，具有相同的 ID，并且指向相同的外设区域。</li><li>在发出设备写入 DW2 请求之前，必须发出设备写入 DW1 请求，其中 DW2 是在 DW1 之后接收的，具有相同的 ID，并且指向相同的外设区域。</li><li>在发出读取 R2 响应之前，必须发出读取 R1 响应，其中 R2 是在 R1 之后接收的，具有相同的 ID。</li><li>在发出写入 W2 响应之前，必须发出写入 W1 响应，其中 W2 是在 W1 之后接收的，具有相同的 ID。</li></ul><p>当互连作为从机工作时，也必须遵循从机要求。</p><p>与事务相关 AXI ID 值的任何操作必须确保原始 ID 值的顺序要求得以保持。</p><h5 id=a-ida367-终点之前响应a367-终点之前响应a><a id="a3.6.7 终点之前响应">A3.6.7 终点之前响应</a></h5><p>为了提高系统性能，中间组件可以对某些事务发出响应。这一操作被称为提前响应。
发出提前响应的中间组件必须确保满足可见性和排序保证。</p><p><strong>提前读取响应</strong></p><p>对于普通读取事务，如果中间组件的本地内存与对相同或重叠地址的所有早期写入保持同步，则可以用读取数据进行响应。
在这种情况下，请求不需要传播到中间组件之外。</p><p>中间组件必须遵守 ID 排序规则，这意味着只有在所有早期的相同 ID 读取已经有响应的情况下，才能发送读取响应。</p><p><strong>提前写入响应</strong></p><p>对于可缓冲写入事务（<strong>AWCACHE[0]</strong> 被置为有效），中间组件可以为没有下游观察者的事务发送提前写入响应。
如果中间组件发送提前写入响应，则可以存储数据的本地副本，但必须在丢弃该数据之前将事务向下游传播。</p><p>中间组件必须遵守 ID 排序规则，这意味着只有在所有早期的相同 ID 写入已经有响应的情况下，才能发送写入响应。</p><p>在发送提前写入响应后，该组件必须负责该事务的排序和可观察性，直到写入被传播到下游并收到写入响应。
在发送提前写入响应和收到下游响应的期间，该组件必须确保：</p><ul><li>如果对普通事务给予了提前写入响应，则所有后续事务对相同或重叠内存位置的写入都是在已经给予提前响应的写入之后排序。</li><li>如果对设备事务给予了提前写入响应，则所有后续事务对相同外设区域的写入都是在已经给予提前响应的写入之后排序。</li></ul><p>在对设备可缓冲事务给予提前写入响应时，预计中间组件将独立于其他事务传播写入事务。
中间组件无法等待另一个读取或写入到达，然后再传播之前的设备写入。</p><h5 id=a-ida368-不同内存类型之间的请求顺序a368-不同内存类型之间的请求顺序a><a id="a3.6.8 不同内存类型之间的请求顺序">A3.6.8 不同内存类型之间的请求顺序</a></h5><p>在可缓存请求与设备请求或非缓存普通请求之间没有排序要求。
设备请求与非缓存普通请求之间的排序要求取决于Device_Normal_Independence属性。</p><p><a id="表 a6.5">表 A6.5</a> Device_Normal_Independence属性</p><table><thead><tr><th>Device_Normal_Independence</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>设备请求被允许超越或被具有相同ID并指向相同位置的正常非缓存请求超越</td></tr><tr><td>False</td><td>Y</td><td>设备和正常的非缓存请求具有相同的 ID，必须按发布顺序在同一位置被观察。</td></tr></tbody></table><p>连接具有不同Device_Normal_Independence值的主机和从机接口的指导如 <em><a href="#表 a6.6">表 A6.6</a></em> 所示。</p><p><a id="表 a6.6">表 A6.6</a> Device_Normal_Independence互联指导</p><table><thead><tr><th>Device_Normal_Independence</th><th>从机: False</th><th>从机: True</th></tr></thead><tbody><tr><td>主机: False</td><td>兼容</td><td>不兼容 从机可能无法满足主机的顺序要求。</td></tr><tr><td>主机: True</td><td>兼容<br>从机可能会执行比主机更严格的顺序</td><td>兼容</td></tr></tbody></table><h5 id=a-ida369-写入可观察顺序a369-写入可观察顺序a><a id="a3.6.9 写入可观察顺序">A3.6.9 写入可观察顺序</a></h5><p>为了提高与支持不同排序模型的接口协议兼容性，
从机可以为写事务提供更强的排序保证，这被称为有序写观察。</p><p>Ordered_Write_Observation 属性用于定义一个接口是否具有有序写观察。</p><p><a id="表 a6.7">表 A6.7</a> Ordered_Write_Observation 属性</p><table><thead><tr><th>Ordered_Write_Observation</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>接口表现出有序可观察性。</td></tr><tr><td>False</td><td>Y</td><td>接口不表现出有序可观察性。</td></tr></tbody></table><p>一个展示有序写观察的接口为写事务提供了保证，这些保证与目的地或地址无关：</p><ul><li>写操作W1保证会被写操作W2观察到，其中W2是在W1之后由同一主机发出的，且具有相同的ID。</li></ul><p>使用有序写观察时，主机可以在不等待写响应的情况下发出多个写请求，并且它们会按照发出顺序被观察。
这在使用Producer-Consumer排序模式时可以提高性能。</p><h4 id=a-ida64-互联使用事务ida64-互联使用事务ida><a id="a6.4 互联使用事务id">A6.4 互联使用事务id</a></h4><p>当一个主机连接到互连时，互连会将附加bit附加到<strong>AWID</strong>和<strong>ARID</strong>标识符，
这些位对于该主机端口是唯一的。这有两个效果：</p><ul><li>主机不必知道其他主机使用的ID值，因为互连通过将主机编号附加到原始标识符使每个主机使用的ID值唯一。</li><li>从机接口处的ID标识符比主机接口处的ID标识符更宽。</li></ul><p>对于写响应，互连使用<strong>BID</strong>标识符的附加bit来确定写响应的目标主机器端口。
互连在将<strong>BID</strong>值传递给正确的主机端口之前会去掉这些<strong>BID</strong>标识符的位。</p><p>对于读数据，互连使用<strong>RID</strong>标识符的附加bit来确定读数据的目标主机端口。
互连在将<strong>RID</strong>值传递给正确的主机端口之前会去掉这些<strong>RID</strong>标识符的位。</p><h4 id=a-ida65-写数据和响应顺序a65-写数据和响应顺序a><a id="a6.5 写数据和响应顺序">A6.5 写数据和响应顺序</a></h4><p>从机必须确保写响应的<strong>BID</strong>值与其响应请求的<strong>AWID</strong>值匹配。</p><p>主机必须按照发出事务请求的顺序发出写数据。</p><p>一个将不同主机的写事务结合在一起的互连必须确保以请求顺序转发写数据。</p><p>不同事务的写数据传输不允许交错。</p><p>互连必须确保来自具有相同<strong>AWID</strong>值的事务序列的写响应在请求顺序中被主机接收。</p><h4 id=a-ida66-读数据顺序a66-读数据顺序a><a id="a6.6 读数据顺序">A6.6 读数据顺序</a></h4><p>从机必须确保任何返回数据的<strong>RID</strong>值与其响应请求的<strong>ARID</strong>值匹配。</p><p>互连接口必须确保来自同一<strong>ARID</strong>值的不同从机的一系列事务的读取数据按请求顺序被主机接收。</p><p>读取数据重排序深度是从机可能发送读取数据的最大接受请求数量。
按接收请求的顺序发送读取数据的从机具有一级读取数据重排深度。</p><p>读取数据重排序深度是一个静态值，可以由从机的设计者指定。</p><p>主机没有机制动态地确定从机的读取数据重排序深度。</p><h5 id=a-ida661-读数据交错a661-读数据交错a><a id="a6.6.1 读数据交错">A6.6.1 读数据交错</a></h5><p>对于读取数据传输允许使用不同的ID值交织进行，这包括所有可以有多个读取数据传输的事务，包括原子事务。</p><p>如果确定附加的从机将交织不同事务的读取数据，一些AXI主机和互联组件可以更有效地设计。</p><p>Read_Interleaving_Disabled属性用于指示接口是否支持来自不同事务的读取数据传输交织。</p><p><a id="表 a6.8">表 A6.8</a> Read_Interleaving_Disabled</p><table><thead><tr><th>Read_Interleaving_Disabled</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>主机无法接收交织的读取数据。<br>从机保证不会交织读取数据。</td></tr><tr><td>False</td><td>Y</td><td>主机能够接收交织的读取数据。<br>从机可能会将具有不同<strong>ARID</strong>值读取事务的数据交织。</td></tr></tbody></table><p>对于某些接口，此属性可用作配置控制。对于其他接口，它是一个功能指示器。
所有发出具有不同ID的事务的主机必须被设计为接受交织数据。
作为一种优化，当附加的从机支持禁用交错时，主机可能使用配置选项来禁用交错。</p><h5 id=a-ida662读取数据分块a662读取数据分块a><a id=a6.6.2读取数据分块>A6.6.2读取数据分块</a></h5><p>读取数据分块选项使从机能够使用128bit粒度重新排序事务中的读取数据。
起始地址可能用作决定首先发送哪个块的提示，但从机允许以任何顺序返回数据块。</p><p>属性Read_Data_Chunking用于指示接口是否支持以可重新排序的块形式返回读取数据。</p><p><a id="表 a6.9">表 A6.9</a> Read_Data_Chunking 属性</p><table><thead><tr><th>Read_Data_Chunking</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持读取数据分块。</td></tr><tr><td>False</td><td>Y</td><td>不支持读取数据分块，相关的分块信号也不存在。</td></tr></tbody></table><h6 id=a-ida6621-读取数据分块信号a6621-读取数据分块信号a><a id="a6.6.2.1 读取数据分块信号">A6.6.2.1 读取数据分块信号</a></h6><p><a id="表 a6.10">表 A6.10</a> 读取数据分块信号</p><p>当支持读取数据分块时，在读取请求和数据通道中会添加如 <em><a href="#表 a6.10">表 A6.10</a></em> 所示的信号。</p><p><a id="表 a6.10">表 A6.10</a> 读取数据分块信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>ARCHUNKEN</strong></td><td>1</td><td>0b0</td><td>如果在读取请求中断言，从机可以以128bit块发送读取数据。</td></tr><tr><td><strong>RCHUNKV</strong></td><td>1</td><td>0b0</td><td>断言为高表示<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>是有效的。每个事务响应必须相同。</td></tr><tr><td><strong>RCHUNKNUM</strong></td><td>RCHUNKNUM_WIDTH</td><td>全0</td><td>指示正在传输的块的编号。<br>块的编号根据事务的数据宽度和基地址从零开始递增。</td></tr><tr><td><strong>RCHUNKSTRB</strong></td><td>RCHUNKSTRB_WIDTH</td><td>全1</td><td>指示了有效的读取数据块。<br>对于每次传输每个位对应128 bit数据，<strong>RCHUNKSTRB</strong>最低位对应<strong>RDATA</strong>最低128位。</td></tr></tbody></table><p>属性RCHUNKNUM_WIDTH定义了<strong>RCHUNKNUM</strong>信号的宽度。</p><p><a id="表 a6.11">表 A6.11</a> RCHUNKNUM_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>RCHUNKNUM_WIDTH</td><td>0,1,5,6,7,8</td><td>0</td><td>RCHUNKNUM的位宽。<br>0：Read_Data_Chunking = False<br>0/1：DATA_WIDTH &lt; 128<br>8:DATA_WIDTH = 128<br>7:DATA_WIDTH = 256<br>6:DATA_WIDTH = 512<br>5DATA_WIDTH=1024</td></tr></tbody></table><p>RCHUNKSTRB_WIDTH属性定义RCHUNKSTRB信号的宽度.</p><p><a id="表 a6.12">表 A6.12</a> RCHUNKSTRB_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>RCHUNKSTRB_WIDTH</td><td>0,1,2,4,8</td><td>0</td><td>RCHUNKSTRB的位宽。<br>0：Read_Data_Chunking = False<br>0/1：DATA_WIDTH &lt; 256<br>2:DATA_WIDTH = 256<br>4:DATA_WIDTH512256<br>8:DATA_WIDTH = 1024</td></tr></tbody></table><p>具有较小DATA_WIDTH的接口可以包含<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>信号，
宽度为1位，也可以从接口中省略它们。
当使用接口保护时，<strong>RCHUNKCHK</strong>信号涵盖这两个信号，
因此连接组件的<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>必须具有相同的宽度。</p><p>建议在接口不需要时省略<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>。</p><h6 id=a-ida622-读数据分块协议规则a622-读数据分块协议规则a><a id="a6.2.2 读数据分块协议规则">A6.2.2 读数据分块协议规则</a></h6><p>在读取数据分块协议中，所有以下规则都适用：</p><ul><li><strong>ARCHUNKEN</strong> 仅针对具有以下属性的事务：<ul><li>大小等于数据通道宽度，或长度为一次传输。</li><li>大小为 128 位或更大。</li><li>Addr 对齐到 16 字节。</li><li>Burst 为 INCR 或 WRAP。</li><li>操作码为 ReadNoSnoop、ReadOnce、ReadOnceCleanInvalid 或 ReadOnceMakeInvalid。</li></ul></li><li>ID 值必须在飞行中是唯一的，这意味着：<ul><li>只有在没有使用相同<strong>ARID</strong>值的未完成读取事务的情况下，才能断言<strong>ARCHUNKEN</strong>。</li><li>主机不得在读取通道上发出与具有断言<strong>ARCHUNKEN</strong>的未完成请求具有相同<strong>ARID</strong>的请求。</li><li>如果在接口上存在，则如果断言<strong>ARCHUNKEN</strong>，则必须断言<strong>ARIDUNQ</strong>。</li></ul></li><li>如果去分断言<strong>ARCHUNKEN</strong>，则必须为事务的所有响应传输去分断言<strong>RCHUNKV</strong>。</li><li>如果断言<strong>ARCHUNKEN</strong>，则可以为事务的响应传输断言<strong>RCHUNKV</strong>。</li><li><strong>RCHUNKV</strong> 必须对事务的每个响应传输相同。</li><li>当断言<strong>RVALID</strong>和<strong>RCHUNKV</strong>时，<strong>RCHUNKNUM</strong>必须介于零和<strong>ARLEN</strong>之间。</li><li>当断言<strong>RVALID</strong>和<strong>RCHUNKV</strong>时，<strong>RCHUNKSTRB</strong>必须不为零。</li><li>当断言<strong>RVALID</strong>和<strong>RCHUNKV</strong>时，<strong>RLAST</strong>仅针对事务的最终响应传输断言，
与<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>无关。</li><li>当断言<strong>RVALID</strong>且去分断言<strong>RCHUNKV</strong>时，<strong>RCHUNKNUM</strong>和<strong>RCHUNKSTRB</strong>可以取任何值。</li></ul><p>传输的数据块数量必须与<strong>ARLEN</strong>和<strong>ARSIZE</strong>一致，
因此事务中传输的字节数无论是否启用分块都相同。</p><p>请注意，当使用读取数据分块时，事务可能比 ARLEN 指示的具有更多读取数据传输。</p><p>对于未对齐的事务，地址低于<strong>ARADDR</strong>的块不会传输，并且必须去分断言<strong>RCHUNKSTRB</strong>。</p><h6 id=a-ida6623-互操作性a6623-互操作性a><a id="a6.6.2.3 互操作性">A6.6.2.3 互操作性</a></h6><p>如果主机支持读数据分块，从机也支持分块，那么下游互联和从机可以减少其缓冲。
一种连接到具有混合分块支持组件的互联可以根据所附组件的能力驱动<strong>ARCHUNKEN</strong>和<strong>RCHUNKV</strong>。</p><p>当连接具有不同Read_Data_Chunking属性值的接口时，适用以下规则，如 <em><a href="#表 a6.13">表 A6.13</a></em> 所示。</p><p><a id="表 a6.13">表 A6.13</a> Read_Data_Chunking互操作性</p><table><thead><tr><th>Read_Data_Chunking</th><th>从机: False</th><th>从机: True</th></tr></thead><tbody><tr><td>主机: False</td><td><strong>ARCHUNKEN</strong>不存在。<br><strong>RCHUNKV</strong> 不存在。<br><strong>RCHUNKNUM</strong> 不存在。<br><strong>RCHUNKSTRB</strong>不存在。<br>读取数据以全数据的形式自然排序。</td><td>从机<strong>ARCHUNKEN</strong> 输入连接为LOW。<br>从机<strong>RCHUNKV</strong>输出不连接。<br>从机<strong>RCHUNKNUM</strong>输出不连接。<br>从机<strong>RCHUNKSTRB</strong>输出不连接。<br>读取数据以全数据的形式自然排序。</td></tr><tr><td>主机: True</td><td>主机<strong>ARCHUNKEN</strong>输出不连接。<br>主机<strong>RCHUNKV</strong> 输入连接为LOW。<br>主机<strong>RCHUNKNUM</strong> 输入连接为任意值。<br>主机<strong>RCHUNKSTRB</strong>输入连接为任意值。</td><td>分块信号对应连接<br>读取数据被分块排序。</td></tr></tbody></table><h6 id=a-ida6624-分块实例a6624-分块实例a><a id="a6.6.2.4 分块实例">A6.6.2.4 分块实例</a></h6><p>在这些示例中，图中的每一行表示一次传输，阴影单元格表示未传输的字节。</p><p><em><a href="#图 a6.1">图 A6.1</a></em> 显示了在256位宽的读数据通道上的一次事务，其中：</p><ul><li>地址为0x00</li><li>长度为2次传输</li><li>尺寸为256位</li><li>突发为INCR</li></ul><p><a id="图 a6.1">图 A6.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A6.1_Example_of_read_data_returned_in_128-bit_chunks.png alt></a></p><p><em><a href="#图 a6.2">图 A6.2</a></em> 在256位宽读数据通道上的一次事务，其中：</p><ul><li>地址是0x10</li><li>长度是2次传输</li><li>尺寸是256位</li><li>突发是INCR</li></ul><p><a id="图 a6.2">图 A6.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A6.2_Example_with_an_unaligned_address_and_a_mixture_of_128-bit_and_256-bit_chunks.png alt></a></p><p>在一个128位宽的读数据通道上的事务，其中：</p><ul><li>地址是0x10。</li><li>长度是4个传输。</li><li>尺寸是128位。</li><li>突发是WRAP。</li><li>RCHUNKSTRB不存在。</li></ul><p>从机使用起始地址作为提示，并首先发送0x10处的块。</p><p><a id="图 a6.3">图 A6.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A6.3_Example_of_a_wrapping_transaction.png alt></a></p><h3 id=a-ida第7章-原子访问a第7章-原子访问a><a id="a第7章 原子访问">A第7章 原子访问</a></h3><p>本章描述了单副本和多副本的原子性以及如何执行独占访问和原子事务。<br>它包含以下部分：</p><ul><li><em><a href="#a7.1 单副本原子大小">A7.1 单副本原子大小</a></em></li><li><em><a href="#a7.2 多副本原子大小">A7.2 多副本原子大小</a></em></li><li><em><a href="#a7.3 独占访问">A7.3 独占访问</a></em></li><li><em><a href="#a7.4 原子事务">A7.4 原子事务</a></em></li></ul><h4 id=a-ida71-单副本原子大小a71-单副本原子大小a><a id="a7.1 单副本原子大小">A7.1 单副本原子大小</a></h4><p>单副本原子性大小是一个事务原子更新的最小字节数。
AXI协议要求大小超过单副本原子性大小的事务以至少单副本原子性大小的块更新内存。</p><p>原子性并不定义数据更新的确切时刻。必须确保没有主机能够观察到原子数据的部分更新形式。
例如，在许多系统中，数据结构如链表由32位原子元素组成。
对这些元素之一的原子更新需要在同一时间更新整个32位值。
任何主机都不能观察到一次仅更新16位，然后再更新另外16位的情况。</p><p>更复杂的系统需要对更大原子元素的支持，特别是64位原子元素，以便主机能够使用基于这些更大原子元素的数据结构进行通信。</p><p>系统中支持的单副本原子性大小很重要，因为涉及某一通信的所有组件必须支持所需的原子元素大小。
如果两个主机通过互连和一个从机进行通信，则所有相关组件必须确保所需大小的事务被视为原子。</p><p>AXI协议不要求特定的单副本原子性大小，系统可以设计为支持不同的单副本原子性大小。</p><p>在AXI中，单副本原子组一词描述了一组可以在特定原子性下进行通信的组件。例如，<em><a href="#图 a7.1">图 A7.1</a></em> 显示了这样一个系统，其中：</p><ul><li>CPU、DSP、DRAM控制器、DMA控制器、外设、SRAM内存和相关互连处于32位单副本原子组中。</li><li>CPU、DSP、DRAM控制器和相关互连也处于64位单副本原子组中。</li></ul><p><a id="图 a7.1">图 A7.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A7.1_Example_system_with_different_single-copy_atomic_groups.png alt></a></p><p>一个事务的原子性保证从来没有超过其起始地址的对齐程度。
例如，在一个64位单副本原子组中的事务，如果没有与8字节边界对齐，则没有任何64位单副本原子保证。</p><p>与事务相关的字节strobes不会影响单副本原子性大小。</p><h4 id=a-ida72-多副本原子写a72-多副本原子写a><a id="a7.2 多副本原子写">A7.2 多副本原子写</a></h4><p>如果满足下列情况，则一个系统被定义为多副本原子性：</p><ul><li>所有代理观察到对同一位置的写入是按照相同的顺序进行的。</li><li>对一个代理可观察位置的写入，对于所有代理都是可观察的。</li></ul><p>为了说明一个系统提供多副本原子性，定义了一个Multi_Copy_Atomicity属性。</p><p><a id="表 a7.1">表 A7.1</a> Multi_Copy_Atomicity 属性</p><table><thead><tr><th>Multi_Copy_Atomicity</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持多副本原子性</td></tr><tr><td>False</td><td>Y</td><td>不支持多副本原子性</td></tr></tbody></table><p>多副本原子性可以通过以下方式确保：</p><ul><li>对于给定地址使用单一的序列化点（Point of Serialization - PoS），以便对同一位置的所有访问都被排序。
这必须确保在新值对任何代理可见之前，位置的所有一致缓存副本都失效。</li><li>避免使用在任何代理上游的转发缓冲区。这防止了某些代理在所有代理可见之前看到位置的缓冲写入。</li></ul><p>要求该多副本原子性属性在本规范的第G期及之后为真。</p><h4 id=a-ida73--独占访问a73--独占访问a><a id="a7.3  独占访问">A7.3 独占访问</a></h4><p>独占访问机制可以提供信号量类型的操作，而无需在操作期间将连接专门分配给特定的主机。</p><p><strong>AxLOCK</strong>信号用于指示独占访问，
而<strong>BRESP</strong>和<strong>RRESP</strong>信号分别指示独占访问写入或读取的成功或失败。</p><p><a id="表 a7.2">表 A7.2</a> AxLOCK 信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWLOCK</strong><br><strong>ARLOCK</strong></td><td>1</td><td>0b0</td><td>断言为高表明需要进行独占访问。</td></tr></tbody></table><p>Exclusive_Accesses属性用于定义主机是否能够发放独占访问权限或从机是否支持这些权限。</p><p><a id="表 a7.3">表 A7.3</a> Exclusive_Accesses 属性</p><table><thead><tr><th>Exclusive_Accesses</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td>支持独占访问，<strong>AWLOCK</strong>和<strong>ARLOCK</strong>出现在接口上。</td></tr><tr><td>False</td><td></td><td>不支持独占访问，<strong>AWLOCK</strong>和<strong>ARLOCK</strong>不出现在接口上。</td></tr></tbody></table><p><em><a href="#表 a7.4">表 A7.4</a></em> 提供了在连接具有不同属性值的主机和从机组件时适用的指导。</p><p><a id="表 a7.4">表 A7.4</a> 独占访问的互操作性</p><table><thead><tr><th>Exclusive_Accesses</th><th>从机：False</th><th>从机：False</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容。<br><strong>AWLOCK</strong>和<strong>ARLOCK</strong>接LOW。</td></tr><tr><td>主机：True</td><td>不兼容。<br>独占访问只会失败，但是接口不会产生死锁。</td><td>兼容。</td></tr></tbody></table><h5 id=a-ida731-独占访问序列a731-独占访问序列a><a id="a7.3.1 独占访问序列">A7.3.1 独占访问序列</a></h5><p>独占访问序列的机制是：</p><ol><li>主机从一个地址发出独占读取请求。</li><li>在稍后的时间，主机尝试通过向同一地址发出独占写入请求来完成独占操作，
并且<strong>AWID</strong>与用于独占读取的<strong>ARID</strong>相匹配。</li><li>该独占写入访问被标记为：<ul><li>成功，如果自独占读取访问以来没有其他主机写入该位置。在这种情况下，独占写入更新内存。</li><li>失败，如果自独占读取访问以来其他主机已向该位置写入。在这种情况下，内存位置不更新。</li></ul></li></ol><p>主机可能没有完成独占操作的写入部分。独占访问监控硬件仅监控每个事务ID的一个地址。
如果主机没有完成独占操作的写入部分，则该主机使用相同的事务ID进行的后续独占读取将改变监控的独占访问地址。</p><h5 id=a-ida732-从主机的角度进行独占访问a732-从主机的角度进行独占访问a><a id="a7.3.2 从主机的角度进行独占访问">A7.3.2 从主机的角度进行独占访问</a></h5><p>一个主机通过执行独占读取开始独占操作。
如果事务成功，从机返回EXOKAY响应，表示从机记录了需要监控的独占访问地址。</p><p>如果主机尝试对不支持独占访问的从机进行独占读取，从机返回OKAY响应，而不是EXOKAY响应。
在这种情况下，读取的数据是有效的，但位置并没有被独占性监控。</p><p>主机可以将OKAY响应视为错误条件，表示不支持独占访问。
建议主机不要执行此独占操作的写入部分。</p><p>在独占读取后，主机尝试对同一位置执行独占写入。
如果所寻址位置的内容自独占读取以来没有被更新，则独占写入操作成功。
从机返回EXOKAY响应，并更新内存位置。</p><p>如果所寻址位置的内容自独占读取以来已被更新，则独占写入尝试失败，从机返回OKAY响应，而不是EXOKAY响应。独占写入尝试不会更新内存位置。</p><p>主机可能无法完成独占操作的写入部分。
如果发生这种情况，从机继续监控该地址的独占访问，直到另一个独占读取开始新的独占访问序列。
主机在读取部分完成之前，不得开始独占访问序列的写入部分。</p><h5 id=a-ida733-独占访问限制a733-独占访问限制a><a id="a7.3.3 独占访问限制">A7.3.3 独占访问限制</a></h5><p>以下限制适用于独占访问：</p><ul><li>独占访问的地址必须与事务中的字节总数对齐，即 Size 和 Length 的乘积。</li><li>在独占访问事务中传输的字节数必须是 2 的幂，即 1、2、4、8、16、32、64 或 128 字节。</li><li>独占事务中可以传输的最大字节数为 128。</li><li>独占访问的长度不得超过 16 次传输。</li><li>域不得是可共享的，请参见 <em><a href="#a9.3.3 可共享域">A9.3.3 可共享域</a></em> 。</li><li>操作码必须是 ReadNoSnoop 或 WriteNoSnoop。请参见 <em><a href="#a第8章 请求操作码">A第8章 请求操作码</a></em> 。</li><li><strong>AWTAGOP</strong> 必须不匹配，请参见 <em><a href=#a1.3.2内存标记扩展>A1.3.2内存标记扩展</a></em> 。</li></ul><p>未遵守这些限制会导致UNPREDICTABLE的行为。</p><p>为了使独占序列成功，<strong>AxCACHE</strong>值必须适当，以确保读写请求到达独占访问监控器。</p><p>在独占操作期间需要监控的最小字节数是 Size 和 Length 的乘积。</p><p>从机可以监控更多的字节，最多可达 128，这是独占访问中的最大字节数。
然而，这可能导致成功的独占访问被指示为失败，因为相邻的字节被更新。
如果在独占序列中的读请求和写请求之间显示的任何信号在表 A7.5 中不同，则即使该位置未被其他代理更新，独占写入也可能失败。</p><p><a id="表 a7.5">表 A7.5</a> 独占序列中应该保持不变的信号</p><table><thead><tr><th><strong>AxID     </strong></th><th><strong>AxADDR    </strong></th><th><strong>AxREGION</strong></th><th><strong>AxSUBSYSID</strong></th><th><strong>AxDOMAIN   </strong></th></tr></thead><tbody><tr><td><strong>AxLEN</strong></td><td><strong>AxSIZE</strong></td><td><strong>AxBURST</strong></td><td><strong>AxLOCK</strong></td><td><strong>AxCACHE[1:0]</strong></td></tr><tr><td><strong>AxPROT</strong></td><td><strong>AxNSE</strong></td><td><strong>AxSNOOP</strong></td><td><strong>AxMMUATST</strong></td><td><strong>AxMMUFLOW</strong></td></tr><tr><td><strong>AxMMUVALID</strong></td><td><strong>AxMMUSECSID</strong></td><td><strong>AxMMUSID</strong></td><td><strong>AxMMUSSID</strong></td><td><strong>AxMMUSSIDV</strong></td></tr></tbody></table><h5 id=a-ida734-从从机的角度进行独占访问a734-从从机的角度进行独占访问a><a id="a7.3.4 从从机的角度进行独占访问">A7.3.4 从从机的角度进行独占访问</a></h5><p>一个支持独占访问的从机必须具有监视硬件。
建议每个支持独占功能的主机ID都配有一个监视单元，
可以访问该从机。</p><p>当从机接收到独占读取请求时，它会记录任何独占读取操作的地址和<strong>ARID</strong>值。
然后它监视该位置，直到该位置发生写入，或直到另一个具有相同<strong>ARID</strong>值的独占读取将监视器重置为另一个地址。</p><p>如果从机能够成功处理独占读取，它会对每个读取数据传输回应EXOKAY。</p><p>如果从机无法处理独占读取，它会以不是EXOKAY的响应作出回应。
一个独占读取可以有多个响应传输。对于单个事务不允许同时出现OKAY和EXOKAY响应。</p><p>当从机接收到具有给定<strong>AWID</strong>值的独占写入时，监视器会检查该地址是否正在监视该<strong>AWID</strong>的独占访问。
如果是，这表明自独占读取访问以来，该位置没有发生写入，独占写入继续进行，并完成独占访问。
从机向主机返回EXOKAY响应，并更新指定的存储位置。</p><p>如果在独占写入时，该地址未使用相同的<strong>AWID</strong>值进行，这表示以下情况之一：</p><ul><li>该位置自独占读取访问以来已被更新。</li><li>监视器已重置到另一个位置。</li><li>主机没有以与独占写入相同的属性发出独占读取。</li></ul><p>在所有独占写入都不得更新指定位置的情况下，从机必须返回OKAY响应，而不是EXOKAY响应。</p><p>如果一个不支持独占访问的从机接收到独占写入，它会以OKAY响应作出回应，并更新该位置。</p><h4 id=a-ida74-原子事务a74-原子事务a><a id="a7.4 原子事务">A7.4 原子事务</a></h4><p>原子事务不仅仅执行单一访问，还有与事务相关联的操作。
原子事务允许将操作发送到数据上，从而使操作能够在更靠近数据位置的地方执行。
原子事务适用于数据与必须执行操作的代理相距较远的情况。</p><p>与使用独占访问相比，该方法减少了在系统中必须使数据对其他代理不可访问的时间。</p><h5 id=a-ida741-概述a741-概述a><a id="a7.4.1 概述">A7.4.1 概述</a></h5><p>在原子事务中，主机发送一个地址、控制信息和出站数据。从机发送入站数据（原子存储除外）和响应。
该规格支持四种形式的原子事务：</p><p><strong>原子存储 - AtomicStore</strong></p><ul><li>主机发送一个带地址的单一数据值和要执行的原子操作。</li><li>从机使用发送的数据和位于地址位置的值作为操作数执行操作。
•-结果存储在地址位置。</li><li>提供一个没有数据的单一响应。</li><li>出站数据大小为1、2、4或8字节。</li></ul><p><strong>原子加载 - AtomicLoad</strong></p><ul><li>主机发送一个带地址的单一数据值和要执行的原子操作。</li><li>从机返回位于地址位置的原始数据值。</li><li>从机使用发送的数据和位于地址位置的值作为操作数执行操作。</li><li>结果存储在地址位置。</li><li>出站数据大小为1、2、4或8字节。</li><li>入站数据大小与出站数据大小相同。</li></ul><p><strong>原子交换 - AtomicSwap</strong></p><ul><li>主机发送一个带地址的单一数据值。</li><li>从机使用事务中提供的数据值交换地址位置的值。</li><li>从机返回位于地址位置的原始数据值。</li><li>出站数据大小为1、2、4或8字节。</li><li>入站数据大小与出站数据大小相同。</li></ul><p><strong>原子比较 - AtomicCompare</strong></p><ul><li>主机发送两个数据值，即比较值和交换值，至地址位置。比较值和交换值大小相等。</li><li>从机将地址位置的数据值与比较值进行检查：<ul><li>如果值匹配，则将交换值写入地址位置。</li><li>如果值不匹配，则不将交换值写入地址位置。</li></ul></li><li>从机返回位于地址位置的原始数据值。</li><li>出站数据大小为2、4、8、16或32字节。</li><li>入站数据大小为出站数据大小的一半，因为出站数据包含比较值和交换值，而入站数据仅具有原始数据值。</li></ul><h5 id=a-ida742-原子事务操作a742-原子事务操作a><a id="a7.4.2 原子事务操作">A7.4.2 原子事务操作</a></h5><p>该规范支持八种不同的操作，可将 <em><a href=#a7.6>A7.6</a></em> 所示的与AtomicStore和AtomicLoad事务一起使用。</p><p><a id=a7.4.2>A7.4.2</a> 原子事务操作</p><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>ADD</td><td>内存中的值与发送的数据相加，结果存储在内存中。</td></tr><tr><td>CLR</td><td>发送数据中的每个已设置位用于清除内存中对应的位。</td></tr><tr><td>EOR</td><td>发送数据与内存中值的按位异或。</td></tr><tr><td>SET</td><td>发送数据中的每个已设置位用于设置内存中对应的位。</td></tr><tr><td>SMAX</td><td>存储在内存中的值是现有值和发送数据中的最大值。<br>该操作假定数据为带符号数。</td></tr><tr><td>SMIN</td><td>存储在内存中的值是现有值和发送数据中的最小值。<br>该操作假定数据为带符号数。</td></tr><tr><td>UMAX</td><td>存储在内存中的值是现有值和发送数据中的最大值。<br>该操作假定数据为无符号数。</td></tr><tr><td>UMIN</td><td>存储在内存中的值是现有值和发送数据中的最小值。<br>该操作假定数据为无符号数。</td></tr></tbody></table><h5 id=a-ida743-原子事务属性a743-原子事务属性a><a id="a7.4.3 原子事务属性">A7.4.3 原子事务属性</a></h5><p>原子事务的规则如下：</p><ul><li><strong>AWLEN</strong> 和 <strong>AWSIZE</strong> 指定事务中写数据的字节数。
对于 AtomicCompare，字节数必须包括比较值和交换值。</li><li>如果 <strong>AWLEN</strong> 指示的事务长度大于 1，则 <strong>AWSIZE</strong> 必须是完整的数据通道宽度。</li><li>在 <strong>AWADDR</strong> 和 <strong>AWSIZE</strong> 指定的数据窗口之外的写 strobe必须被禁止。</li><li>数据窗口内的写 strobes必须被使能。</li></ul><p><strong>对于 AtomicStore、AtomicLoad 和 AtomicSwap</strong></p><ul><li>写数据为 1、2、4 或 8 字节，读数据分别为 1、2、4 或 8 字节。</li><li><strong>AWADDR</strong> 必须与总写数据大小对齐。</li><li><strong>AWBURST</strong> 必须为 INCR。</li></ul><p><em>对于 AtomicCompare</em></p><ul><li>写数据为 2、4、8、16 或 32 字节，读数据为 1、2、4、8 或 16 字节。</li><li><strong>AWADDR</strong> 必须与总写数据大小的一半对齐。</li><li>如果 <strong>AWADDR</strong> 指向事务的下半部分：<ul><li>首先发送比较值。比较值位于单次传输事务的低字节中，或位于多次传输事务的第一次传输中。</li><li><strong>AWBURST</strong> 必须为 INCR。</li></ul></li><li>如果 <strong>AWADDR</strong> 指向事务的上半部分：<ul><li>首先发送交换值。交换值位于单次传输事务的低字节中，或位于多次传输事务的第一次传输中。</li><li><strong>AWBURST</strong> 必须为 WRAP。</li></ul></li><li>对于 WRAP 类型的事务，通常规则有所放宽：<ul><li>允许长度为 1。</li><li><strong>AWADDR</strong> 不需要与传输大小对齐。</li></ul></li></ul><p>具有 64 位数据通道的 AtomicCompare 事务示例如 <em><a href="#图 a7.2">图 A7.2</a></em> 所示。</p><p><a id="图 a7.2">图 A7.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A7.2_Examples_showing_the_location_of_the_Compare_and_Swap_values_for_an_AtomicCompare.png alt></a></p><h5 id=a-ida744-原子事务使用ida744-原子事务使用ida><a id="a7.4.4 原子事务使用id">A7.4.4 原子事务使用ID</a></h5><p>一个单一的AXI ID用于原子事务。
相同的AXI ID用于请求、写响应和读数据。
这个要求意味着主机只能使用可以在<strong>AWID</strong>和<strong>RID</strong>信号上进行信号传递的ID值。</p><p>原子事务不能使用与同时存在的非原子事务所使用的AXI ID值。
这条规则适用于<strong>AR</strong>或<strong>AW</strong>通道上的事务。
这条规则确保了原子事务和非原子事务之间没有排序约束。</p><p>如果一个事务在另一个事务发出之前已完全完成，原子事务和非原子事务可以使用相同的AXI ID值。</p><p>同时存在的多个原子事务不能使用相同的AXI ID值。</p><p>对于使用读数据通道的原子事务，如果接口包括唯一ID信号，则如果<strong>AWIDUNQ</strong>被确认，则必须确认<strong>RIDUNQ</strong>。
有关更多细节，请参见 <em><a href="#a6.2 唯一id">A6.2 唯一id</a></em> 。</p><h5 id=a-ida745-原子事务的请求属性限制a745-原子事务的请求属性限制a><a id="a7.4.5 原子事务的请求属性限制">A7.4.5 原子事务的请求属性限制</a></h5><p>对于原子事务，请求属性适用以下限制：</p><ul><li><strong>AWCACHE</strong> 和 <strong>AWDOMAIN</strong> 可以是接口类型有效的任何组合。请参见 <em><a href="#表 a9.1">表 A9.1</a></em> 。</li><li><strong>AWSNOOP</strong> 必须设置为全零。如果 <strong>AWSNOOP</strong> 有其他值，则 <strong>AWATOP</strong> 必须全为零。</li><li><strong>AWLOCK</strong> 必须不被声明为独占访问。</li></ul><h5 id=a-ida746-原子事务信号a746-原子事务信号a><a id="a7.4.6 原子事务信号">A7.4.6 原子事务信号</a></h5><p>为了支持原子事务，<strong>AWATOP</strong> 应该被添加到一个接口中。</p><p><a id="表 a7.7">表 A7.7</a> id信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWATOP</strong></td><td>6</td><td>0x00</td><td>指示原子事务的类型和字节顺序。</td></tr></tbody></table><p>AWATOP的编码如 <em><a href="#表 a7.8">表 A7.8</a></em> 和 <em><a href="#表 a7.9">表 A7.9</a></em> 所示</p><p><em><a href="#表 a7.8">表 A7.8</a></em> <strong>AWATOP</strong>编码</p><table><thead><tr><th><strong>AWATOP[5:0]</strong></th><th>描述</th></tr></thead><tbody><tr><td>0b000000</td><td>非原子操作</td></tr><tr><td>0b01exxx</td><td>原子存储 （AtomicStore）</td></tr><tr><td>0b10exxx</td><td>原子加载 （AtomicLoad）</td></tr><tr><td>0b110000</td><td>原子交换 （AtomicSwap）</td></tr><tr><td>0b110001</td><td>原子比较 （AtomicCompare）</td></tr></tbody></table><p>对于原子存储（AtomicStore）和原子加载（AtomicLoad）事务，<strong>AWATOP[3]</strong>表示原子操作所需的字节序：</p><ul><li>当未断言时，此位表示操作为小端。</li><li>当断言时，此位表示操作为大端。</li></ul><p><strong>AWATOP[3]</strong>的值仅适用于算术操作，对于按位逻辑操作则被忽略。</p><p>对于原子存储（AtomicStore）和原子加载（AtomicLoad）事务，
<em><a href="#表 a7.9">表 A7.9</a></em> 显示了低位<strong>AWATOP[2:0]</strong>信号上的操作编码。</p><p><a id="表 a7.9">表 A7.9</a> 低位<strong>AWATOP[2:0]</strong>编码</p><table><thead><tr><th><strong>AWATOP[2:0]</strong></th><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>0b000</td><td>ADD</td><td>加法</td></tr><tr><td>0b001</td><td>CLR</td><td>位清零</td></tr><tr><td>0b010</td><td>EOR</td><td>异或</td></tr><tr><td>0b011</td><td>SET</td><td>位设定</td></tr><tr><td>0b100</td><td>SMAX</td><td>有符号最大值</td></tr><tr><td>0b101</td><td>SMIN</td><td>有符号最小值</td></tr><tr><td>0b110</td><td>UMAX</td><td>无符号最大值</td></tr><tr><td>0b111</td><td>UMIN</td><td>无符号最小值</td></tr></tbody></table><h5 id=a-ida747-事务结构a747-事务结构a><a id="a7.4.7 事务结构">A7.4.7 事务结构</a></h5><p>对于AtomicLoad、AtomicSwap和AtomicCompare事务，事务结构如下：</p><ul><li>请求在AW通道上发出。</li><li>相关的事务数据在W通道上发送。</li><li>W通道上所需的写数据传输数量由AWLEN信号决定。</li><li>原子事务请求与原子事务写数据的相对时序未指定。</li><li>从机通过R通道返回原始数据值。</li><li>读取数据传输的数量由<strong>AWLEN</strong>和<strong>AWATOP</strong>信号决定。
对于AtomicCompare操作，如果<strong>AWLEN</strong>指示事务长度大于1，则读取数据传输的数量为<strong>AWLEN</strong>指定数量的一半。</li><li>允许从机在发送读取数据之前等待所有写数据。主机必须能够在未接收任何读取数据的情况下发送所有写数据。</li><li>允许从机在接受任何写数据之前发送所有读取数据。主机必须能够在未接受任何写数据的情况下接受所有读取数据。</li><li>在B通道上返回单个写响应。写响应必须由从机在接收到所有写数据传输并且原子事务的结果可观察后给出。</li></ul><p>AtomicLoad、AtomicSwap和AtomicCompare事务涉及的传输如 <em><a href="#图 a7.3">图 A7.3</a></em> 所示。</p><p><a id="图 a7.3">图 A7.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A7.3_AtomicLoad,_AtomicSwap,_or_AtomicCompare_transaction.png alt></a></p><p>对于AtomicStore事务，事务结构如下：</p><ul><li>请求在AW通道上发出。</li><li>相关的事务数据在W通道上发送。</li><li>W通道上所需的写数据传输次数由<strong>AWLEN</strong>信号决定。</li><li>Atomic事务请求和Atomic事务写数据的相对时序未指定。</li><li>在B通道上返回单个写响应。写响应必须由从机在收到所有写数据传输并且观察到原子事务的结果之后给出。</li></ul><p>涉及AtomicStore事务的传输如 <em><a href="#图 a7.4">图 A7.4</a></em> 所示。</p><p><a id="图 a7.4">图 A7.4
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A7.4_AtomicStore_transaction.png alt></a></p><h5 id=a-ida748-响应信号a748-响应信号a><a id="a7.4.8 响应信号">A7.4.8 响应信号</a></h5><p>写响应指示原子事务对所有必需的观察者可见。</p><p>包含读取响应的原子事务在接收到第一项读取数据时对所有必需的观察者可见。</p><p>主机被允许使用读取或写入响应作为事务对所有必需的观察者可见的指示。</p><p>与操作相关的错误概念是不存在的，例如溢出。一个操作对所有输入组合是完全指定的。</p><p>对于如原子比较等事务，当事务有多个结果时，不会提供事务结果的指示。
为了确定比较和交换指令是否已更新内存位置，必须检查作为事务一部分返回的原始数据值。</p><p>当事务达到不支持原子事务的组件时，可以对原子事务给出错误响应。</p><p>对于原子加载（AtomicLoad）、原子交换（AtomicSwap）和原子比较（AtomicCompare）事务：</p><ul><li>从机必须发送正确数量的读取数据传输，即使写响应是DECERR或SLVERR。</li><li>主机可能会忽略写响应，仅使用随读取数据一起返回的响应。</li></ul><h5 id=a-ida749-原子事务的依赖a749-原子事务的依赖a><a id="a7.4.9 原子事务的依赖">A7.4.9 原子事务的依赖</a></h5><p>对于AtomicLoad，AtomicSwap和AtomicCompare事务，<em><a href="#图 a7.5">图 A7.5</a></em> 显示以下原子事务握手信号依赖关系：</p><ul><li>主机在断言<strong>AWVALID</strong>或<strong>WVALID</strong>之前不应等待从机断言<strong>AWREADY</strong>或<strong>WREADY</strong>。</li><li>从机可以在断言<strong>AWREADY</strong>之前等待<strong>AWVALID</strong>或<strong>WVALID</strong>，或两者。</li><li>从机可以在<strong>AWVALID</strong>或<strong>WVALID</strong>，或者两者被断言之前断言<strong>AWREADY</strong>。</li><li>从机可以在断言<strong>WREADY</strong>之前等待<strong>AWVALID</strong>或<strong>WVALID</strong>，或两者。</li><li>从机可以在<strong>AWVALID</strong>或<strong>WVALID</strong>，或者两者被断言之前断言<strong>WREADY</strong>。</li><li>从机在断言<strong>BVALID</strong>之前必须等待<strong>AWVALID</strong>、<strong>AWREADY</strong>、<strong>WVALID</strong>和<strong>WREADY</strong>被断言。</li><li>从机还必须在断言<strong>BVALID</strong>之前等待<strong>WLAST</strong>被断言，因为写响应<strong>BRESP</strong>必须在写事务的最后一次数据传输后才发出信号。</li><li>从机在断言<strong>BVALID</strong>之前不应等待主机断言<strong>BREADY</strong>。</li><li>主机可以在断言<strong>BREADY</strong>之前等待<strong>BVALID</strong>。</li><li>主机可以在<strong>BVALID</strong>被断言之前断言<strong>BREADY</strong>。</li><li>从机必须在<strong>AWVALID</strong>和<strong>AWREADY</strong>都被断言之后才能断言<strong>RVALID</strong>，以指示有效数据可用。</li><li>从机在断言<strong>RVALID</strong>之前不应等待主机断言<strong>RREADY</strong>。</li><li>主机可以在断言<strong>RREADY</strong>之前等待<strong>RVALID</strong>被断言。</li><li>主机可以在<strong>RVALID</strong>被断言之前断言<strong>RREADY</strong>。</li><li>主机在断言<strong>WVALID</strong>之前不应等待从机断言<strong>RVALID</strong>。</li><li>从机可以在所有写数据传输之前等待<strong>WVALID</strong>被断言，然后再断言<strong>RVALID</strong>。</li><li>主机可以在<strong>RVALID</strong>被断言之前断言<strong>WVALID</strong>。</li></ul><p>在 <em><a href="#图 a7.5">图 A7.5</a></em> 所示的依赖性图中：</p><ul><li>单头箭头指向可以在箭头起始信号之前或之后被断言的信号。</li><li>双头箭头指向必须在箭头起始信号被断言之后才能被断言的信号。</li></ul><p><a id="图 a7.5">图 A7.5
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A7.5_Atomic_transaction_handshake_dependencies.png alt></a></p><h5 id=a-ida7410-原子事务的支持a7410-原子事务的支持a><a id="a7.4.10 原子事务的支持">A7.4.10 原子事务的支持</a></h5><p>Atomic_Transactions属性用于指示一个组件是否支持原子事务。</p><p><a id="表 a7.10">表 A7.10</a> Atomic_Transactions属性</p><table><thead><tr><th>Atomic_Transactions</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持原子事务。</td></tr><tr><td>False</td><td>Y</td><td>不支持原子事务。</td></tr></tbody></table><p>在某些实现中，这将是一个固定的接口属性，而其他实现可能支持在设计时设置该属性。</p><p>如果一个从机或互连组件声明它支持原子事务，那么它必须支持所有操作类型、大小和字节顺序。</p><p><strong>主机支持</strong></p><p>一个支持原子事务的主机组件还可以包括一个机制来抑制原子事务的生成，以确保在不支持原子事务的系统中的兼容性。<br>指定了一个可选的BROADCASTATOMIC引脚。当该存在并未被断言时，主机不会发出原子事务。</p><p><a id="表 a7.11">表 A7.11</a> BROADCASTATOMIC 绑定输入</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>BROADCASTATOMIC</td><td>1</td><td>0b1</td><td>主机绑定输入，用于控制从接口发出的原子事务。</td></tr></tbody></table><p><strong>从机支持</strong></p><p>从机支持原子事务是可选的。<br>如果从机仅支持特定内存类型或特定地址区域的原子事务，则从机必须对其不支持的原子事务给出适当的错误响应。</p><p><strong>互连支持</strong></p><p>互连支持原子事务是可选的。</p><p>如果互连不支持原子事务，则所有连接的主机必须配置为不生成原子事务。</p><p>在支持原子事务的互连中的任何点都可以支持原子事务，包括将原子事务向下传递到从机。</p><p>并非每个地址位置都要求支持原子事务。如果给定地址位置不支持原子事务，则可以对此事务给出适当的错误响应。详见 <em><a href="#a4.3 事务响应">A4.3 事务响应</a></em> 。</p><p>对于设备事务，原子事务必须传递给端点从机。如果从机被配置为指示其不支持原子事务，则互连必须对此事务给出错误响应。
不得将原子事务传递给不支持原子事务的组件。</p><p>对于可缓存事务，互连可以选择：</p><ul><li>在互连内执行原子操作。此方法要求互连执行适当的读取、写入和侦听事务以完成操作。</li><li>如果适当的端点从机被配置为指示其支持原子操作，则互连可以将原子操作传递给从属。</li></ul><h3 id=a-ida第8章-请求操作码a第8章-请求操作码a><a id="a第8章 请求操作码">A第8章 请求操作码</a></h3><p>请求操作码指示请求的功能以及从机如何处理该请求。
本章总结了所有可用的操作码，并在表中提供了链接，以详细描述它们的工作原理。它包含以下部分：</p><ul><li><em><a href="#a8.1 操作码信号">A8.1 操作码信号</a></em></li><li><em><a href="#a8.2 awsnoop编码">A8.2 AWSNOOP编码</a></em></li><li><em><a href="#a8.3 arsnoop编码">A8.3 ARSNOOP编码</a></em></li></ul><h4 id=a-ida81-操作码信号a81-操作码信号a><a id="a8.1 操作码信号">A8.1 操作码信号</a></h4><p>请求操作码通过<strong>AWSNOOP</strong>和<strong>ARSNOOP</strong>信号进行传达。</p><p><a id="表 a8.1">表 A8.1</a> <strong>AxSNOOP</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWSNOOP</strong></td><td>AWSNOOP_WIDTH</td><td>0x00<br>WriteNoSnoop/WriteUniquePtl/Atomic<br></td><td>写通道的请求操作码</td></tr><tr><td><strong>ARSNOOP</strong></td><td>ARSNOOP_WIDTH</td><td>0x0<br>ReadNoSnoop/ReadOnce<br></td><td>读通道的请求操作码</td></tr></tbody></table><p>WriteNoSnoop、WriteUniquePtl、ReadNoSnoop 和 ReadOnce 是默认的操作码，用于通用请求<strong>AxSNOOP</strong>。</p><p>宽度属性在 <em><a href="#表 a8.2">表 A8.2</a></em> 被定义。</p><p><a id="表 a8.2">表 A8.2</a> <strong>AxSNOOP</strong>位宽属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>AWSNOOP_WIDTH</td><td>0,4,5</td><td>4</td><td><strong>AWSNOOP</strong>位宽</td></tr><tr><td>ARSNOOP_WIDTH</td><td>0,4</td><td>4</td><td><strong>ARSNOOP</strong>位宽</td></tr></tbody></table><p>如果以下任何属性不为 False，则 AWSNOOP_WIDTH 必须为 5：</p><ul><li>WriteDeferrable_Transaction</li><li>UnstashTranslation_Transaction</li><li>InvalidateHint_Transaction</li></ul><p>如果以下任何属性不为 False，则 AWSNOOP_WIDTH 必须为 4 或 5：</p><ul><li>Shareable_Cache_Support</li><li>WriteNoSnoopFull_Transaction</li><li>CMO_On_Write</li><li>WriteZero_Transaction</li><li>Cache_Stash_Transactions</li><li>Untranslated_Transactions</li><li>Prefetch_Transaction</li></ul><p>如果以下任何属性不为 False，则 ARSNOOP_WIDTH 必须为 4：</p><ul><li>Shareable_Cache_Support</li><li>DeAllocation_Transactions</li><li>CMO_On_Read</li><li>DVM_Message_Support</li></ul><p>任何未由接口驱动的 <strong>AxSNOOP</strong> 位都假定为 LOW。</p><p>仅发出 WriteNoSnoop/WriteUniquePtl/Atomic 请求的主机可以将 <strong>AWSNOOP_WIDTH</strong> 设置为 0，
从而从其接口中省略 <strong>AWSNOOP</strong> 输出。连接的从机必须将其 <strong>AWSNOOP</strong> 输入连接为 LOW。</p><p>仅发出 ReadNoSnoop/ReadOnce 请求的主机器可以将 ARSNOOP_WIDTH 设置为 0，从而从其接口中省略 <strong>ARSNOOP</strong> 输出。
连接的从机必须将其 <strong>ARSNOOP</strong> 输入连接为 LOW。</p><h4 id=a-ida82-awsnoop-编码a82-awsnoop-编码a><a id="a8.2 awsnoop 编码">A8.2 AWSNOOP 编码</a></h4><p><strong>AWSNOOP</strong>的编码如 <em><a href="#表 a8.3">表 A8.3</a></em> 所示。
一些操作码取决于请求的域。Enable列列出了决定主机是否被允许使用操作码以及从机是否支持的属性表达式。</p><p>未列出的<strong>AWSNOOP</strong>和<strong>AWDOMAIN</strong>组合是非法的。</p><p><a id="表 a8.3">表 A8.3</a> AWSNOOP编码</p><table><thead><tr><th><strong>AWSNOOP</strong></th><th>AWDOMAIN <sup><em><a href=#a[8-1]>A[8-1]</a></em></sup></th><th>Opcode</th><th>Enable</th><th>Description</th></tr></thead><tbody><tr><td>0b00000</td><td>NSH, SYS</td><td>WriteNoSnoop</td><td>-</td><td>写入不可共享或系统位置。</td></tr><tr><td>0b00000</td><td>SH</td><td>WriteUniquePtl</td><td>Shareable_Transactions</td><td>写入共享位置。</td></tr><tr><td>0b00000</td><td>NSH, SH, SYS</td><td>Atomic</td><td>Atomic_Transactions</td><td>非0的<strong>AWATOP</strong>信号指示的原子事务.</td></tr><tr><td>0b00001</td><td>NSH</td><td>WriteNoSnoopFull</td><td>WriteNoSnoopFull_Transaction<br>或 Shareable_Cache_Support</td><td>缓存行大小且常规的。<br>写入到不可共享位置。</td></tr><tr><td>0b00001</td><td>SH</td><td>WriteUniqueFull</td><td>Shareable_Transactions</td><td><br>写入到可共享位置。</td></tr><tr><td>0b00010</td><td>-</td><td>RESERVED</td><td>-</td><td>-</td></tr><tr><td>0b00011</td><td>SH</td><td>WriteBackFull</td><td>Shareable_Transactions<br>和 Shareable_Cache_Support</td><td>缓存行大小且常规的。<br>写入到可共享位置。<br>该行被保存在一致的缓存中并且是Dirty的。</td></tr><tr><td>0b00100</td><td>-</td><td>RESERVED</td><td>-</td><td>-</td></tr><tr><td>0b00101</td><td>SH</td><td>WriteEvictFull</td><td>Shareable_Transactions</br>和 Shareable_Cache_Support</td><td>缓存行大小且常规的。<br>写入到可共享位置。<br>该行被保存在一致的缓存中并且是Clean的。</td></tr><tr><td>0b00110</td><td>NSH, SH</td><td>CMO</td><td>CMO_On_Write</td><td>一个无数据请求表示必须执行缓存维护操作。<br>具体操作编码在<strong>AWCMO</strong>信号上。<br>缓存行大小且常规的。</td></tr><tr><td>0b00111</td><td>NSH, SH, SYS</td><td>WriteZero</td><td>WriteZero_Transaction</td><td>缓存行大小且常规的。<br>每个字节的值都是0.</td></tr><tr><td>0b01000</td><td>SH</td><td>WriteUniquePtlStash</td><td>Shareable_Transactions<br>和Cache_Stash_Transactions</td><td>缓存行大小或者更小的。<br>写入共享位置表明数据可被分配到缓存。</td></tr><tr><td>0b01001</td><td>SH</td><td>WriteUniqueFullStash</td><td>Shareable_Transactions<br>和Cache_Stash_Transactions</td><td>缓存行大小且常规的。<br>写入共享位置表明数据可被分配到缓存。</td></tr><tr><td>0b01010</td><td>NSH, SH</td><td>WritePtlCMO</td><td>Write_Plus_CMO</td><td>缓存行大小或者更小。<br>写入任何缓存副本的位置根据<strong>AWCMO</strong>信号必须是clean和/或使其失效。</td></tr><tr><td>0b01011</td><td>NSH, SH</td><td>WriteFullCMO</td><td>Write_Plus_CMO</td><td>缓存行大小且常规的。<br>写入任何缓存副本的位置根据<strong>AWCMO</strong>信号必须是clean和/或使其失效。</td></tr><tr><td>0b01100</td><td>NSH, SH</td><td>StashOnceShared</td><td>Cache_Stash_Transactions</td><td>缓存行大小且常规的。<br>一个无数据的请求，表示应该将一个缓存行获取到缓存中。其他副本的行不需要被失效。</td></tr><tr><td>0b01101</td><td>NSH, SH</td><td>StashOnceUnique</td><td>Cache_Stash_Transactions</td><td>缓存行大小且常规的。<br>一个无数据的请求，表示应该将一个缓存行获取到缓存中。其他副本的行需要被失效。</td></tr><tr><td>0b01110</td><td>NSH, SH, SYS</td><td>StashTranslation</td><td>Untranslated_Transactions<br>和 Cache_Stash_Transactions</td><td>一个无数据的请求，表示转换应该被缓存到MMU。</td></tr><tr><td>0b01111</td><td>NSH, SH</td><td>Prefetch</td><td>Prefetch_Transaction</td><td>缓存行大小且常规的。<br>无数据请求，这表明主机可能在稍后的时间读取指定的缓存行。</td></tr><tr><td>0b10000</td><td>SYS</td><td>WriteDeferrable</td><td>WriteDeferrable_Transaction</td><td>一个64字节的原子写，其中从机可以给出DEFER或UNSUPPORTED响应。</td></tr><tr><td>0b10001</td><td>NSH, SH, SYS</td><td>UnstashTranslation</td><td>UnstashTranslation_Transaction</td><td>一个无数据的请求，表示着一个转换不太可能再被使用。</td></tr><tr><td>0b10010</td><td>NSH, SH</td><td>InvalidateHint</td><td>InvalidateHint_Transaction</td><td>缓存行大小且常规的。<br>一个无数据的请求，它表明缓存行不再需要，可以使其失效。<br>允许进行回写，但不是必须的。</td></tr><tr><td>0b10011 to 0b11111</td><td>-</td><td>RESERVED</td><td>-</td><td>-</td></tr></tbody></table><p><a id=a[8-1]>A[8-1]</a> ： NSH是不可共享的（0b00），SH是可共享的（0b01或0b10），SYS是系统（0b11）。</p><h4 id=a-ida83-arsnoop编码a83-arsnoop编码a><a id="a8.3 arsnoop编码">A8.3 ARSNOOP编码</a></h4><p>ARSNOOP的编码如 <em><a href="#表 a8.4">表 A8.4</a></em> 所示。
一些操作码取决于请求的域。Enable列列出了决定主机是否被允许使用该操作码，以及从机是否支持它的属性表达式。</p><p>未列出的<strong>ARSNOOP</strong>和<strong>ARDOMAIN</strong>组合是非法的。</p><p><a id="表 a8.4">表 A8.4</a> <strong>ARSNOOP</strong>编码</p><table><thead><tr><th><strong>ARSNOOP</strong></th><th><strong>ARDOMAIN</strong> <sup><em><a href=#a[8-2]>A[8-2]</a></em></sup></th><th>Opcode</th><th>Enable</th><th>Description</th></tr></thead><tbody><tr><td>0b0000</td><td>NSH, SYS</td><td>ReadNoSnoop</td><td>-</td><td>从不可共享或系统位置读取。</td></tr><tr><td>0b0000</td><td>SH</td><td>ReadOnce</td><td>Shareable_Transactions</td><td>从可共享位置读取并且主机不会缓存。</td></tr><tr><td>0b0001</td><td>SH</td><td>ReadShared</td><td>Shareable_Transactions and Shareable_Cache_Support</td><td>缓存行大小且常规的。<br>来自可共享位置的读取结果可能被保存在缓存中并且可以是Dirty的。</td></tr><tr><td>0b0010</td><td>SH</td><td>ReadClean</td><td>Shareable_Transactions and Shareable_Cache_Support</td><td>缓存行大小且常规的。<br>来自可共享位置的读取结果可能被保存在缓存中并且是Clean的。</td></tr><tr><td>0b0011</td><td>-</td><td>RESERVED</td><td>-</td><td>-</td></tr><tr><td>0b0100</td><td>SH</td><td>ReadOnceCleanInvalid</td><td>Shareable_Transactions and DeAllocation_Transactions</td><td>缓存行大小或更小的。<br>来自可共享位置的读取结果不会被保存在缓存中。<br>建议将缓存副本Clean且失效。</td></tr><tr><td>0b0101</td><td>SH</td><td>ReadOnceMakeInvalid</td><td>Shareable_Transactions and DeAllocation_Transactions</td><td>缓存行大小或更小的。<br>来自可共享位置的读取结果不会被保存在缓存中。<br>缓存副本建议是无写回的失效。</td></tr><tr><td>0b0110</td><td>-</td><td>RESERVED</td><td>-</td><td>-</td></tr><tr><td>0b0111</td><td>-</td><td>RESERVED</td><td>-</td><td>-</td></tr><tr><td>0b1000</td><td>NSH, SH</td><td>CleanShared</td><td>CMO_On_Read</td><td>缓存行大小且常规的。<br>请求清除所有缓存行的副本。</td></tr><tr><td>0b1001</td><td>NSH, SH</td><td>CleanInvalid</td><td>CMO_On_Read</td><td>缓存行大小且常规的。<br>请求清除并失效所有缓存行的副本。</td></tr><tr><td>0b1010</td><td>NSH, SH</td><td>CleanSharedPersist</td><td>CMO_On_Read and Persist_CMO</td><td>缓存行大小且常规的。<br>请求清除所有缓存行的副本 清理后的数据必须经过持久性点或深度持久性点。</td></tr><tr><td>0b1011</td><td>-</td><td>RESERVED</td><td>-</td><td>-</td></tr><tr><td>0b1100</td><td>-</td><td>RESERVED</td><td>-</td><td>-</td></tr><tr><td>0b1101</td><td>NSH, SH</td><td>MakeInvalid</td><td>CMO_On_Read</td><td>缓存行大小且常规的。<br>请求清除并失效所有缓存行的副本。Dirty数据不需要写入内存。</td></tr><tr><td>0b1110</td><td>SH</td><td>DVM Complete</td><td>DVM_Message_Support</td><td>表示DVM同步消息已完成。</td></tr><tr><td>0b1111</td><td>-</td><td>RESERVED</td><td>-</td><td>-</td></tr></tbody></table><p><a id=a[8-2]>A[8-2]</a> ： NSH是不可共享的（0b00），SH是可共享的（0b01或0b10），SYS是系统（0b11）。</p><h3 id=a-ida第9章-缓存a第9章-缓存a><a id="a第9章 缓存">A第9章 缓存</a></h3><p>本章节描述了AXI协议中的缓存。
它包含以下部分：</p><ul><li><em><a href="#a9.1 缓存">A9.1 缓存</a></em></li><li><em><a href="#a9.2 缓存行大小">A缓存行大小</a></em></li><li><em><a href="#a9.3 缓存一致性和域">A缓存一致性和域</a></em></li><li><em><a href="#a9.4 io一致性">A9.4 io一致性</a></em></li><li><em><a href="#a9.5 可共享缓存行">A9.5 可共享缓存行</a></em></li><li><em><a href="#a9.6 预取事务">A9.6 预取事务</a></em></li><li><em><a href="#a9.7 缓存存储">A9.7 缓存存储</a></em></li><li><em><a href="#a9.8 撤销分配和事务">A9.8 撤销分配和事务</a></em></li><li><em><a href="#a9.9 无效表示">A9.9 无效表示</a></em></li></ul><h4 id=a-ida91-缓存a91-缓存a><a id="a9.1 缓存">A9.1 缓存</a></h4><p>在本规范中，术语缓存用于任何存储结构，包括缓存、缓冲区或其他中间存储元素。 数据可以在系统的各个点进行缓存。
示例拓扑如 <em><a href="#图 a9.1">图 A9.1</a></em> 所示。
在这个例子中，有一个系统缓存，所有代理都可以看到，本地可共享缓存所有一致代理都可以看到，以及本地不可共享缓存仅对单个代理可见。</p><p>完全一致的代理使用硬件一致性和数据监听来保持其缓存的一致性。
这些通常使用AMBA CHI接口 <sup><em><a href=#a[5]>A[5]</a></em> </sup>。</p><p>I/O一致的代理可以与完全一致的代理共享数据，但任何在它们本地缓存的数据必须手动维护以确保一致性。</p><p>非一致性代理必须手动维护与其他代理共享并在本地缓存的任何数据。</p><p><a id="图 a9.1">图 A9.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A9.1_Example_system_topology_showing_possible_cache_locations_and_type.png alt></a></p><h4 id=a-ida92-缓存行大小a92-缓存行大小a><a id="a9.2 缓存行大小">A9.2 缓存行大小</a></h4><p>缓存行被定义为顺序字节地址内存位置的缓存副本，第一个地址与缓存行的总大小对齐。
采用缓存共享的系统必须具有相同的缓存行大小。
一些事务仅在整个缓存行上操作，必须是缓存行大小。</p><p>缓存行大小在设计时是固定的，并使用Cache_Line_Size属性定义。</p><p><a id="表 a9.1">表 A9.1</a> Cache_Line_Size属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>Cache_Line_Size</td><td>16，32，64，128，256，512，1024，2048</td><td>64</td><td>缓存行大小以字节为单位。</td></tr></tbody></table><p>对于任何传输缓存行大小化事务的接口，数据宽度必须足够宽，以便使用16次传输或更少来传送一个缓存行。</p><p>为了与AMBA CHI兼容，缓存行大小必须为64字节。</p><p>事务必须为缓存行大小化和常规的操作码见 <em><a href="#表 a9.2">表 A9.2</a></em> 。
有关常规事务的更多信息，请参见 <em><a href="#a4.1.8 常规事务">A4.1.8 常规事务</a></em> 。</p><p><a id="表 a9.2">表 A9.2</a> 缓存必须大小化和常规的操作码</p><table><thead><tr><th>读通道事务</th><th>写通道事务</th></tr></thead><tbody><tr><td>ReadShared</td><td>WriteNoSnoopFull</td></tr><tr><td>ReadClean</td><td>WriteUniqueFull</td></tr><tr><td>CleanShared</td><td>WriteBackFull</td></tr><tr><td>CleanInvalid</td><td>WriteEvictFull</td></tr><tr><td>MakeInvalid</td><td>CMO</td></tr><tr><td>CleanSharedPersist</td><td>WriteZero</td></tr><tr><td></td><td>WriteUniqueFullStash</td></tr><tr><td></td><td>WriteFullCMO</td></tr><tr><td></td><td>StashOnceShared</td></tr><tr><td></td><td>StashOnceUnique</td></tr><tr><td></td><td>Prefetch</td></tr><tr><td></td><td>InvalidateHint</td></tr></tbody></table><p>缓存行大小化，常规事务具有以下约束：</p><ul><li>Size x Length必须等于缓存行大小。</li><li>Length可以是1、2、4、8或16。</li><li>如果Length大于1，Size必须等于数据通道宽度。</li><li>突发不得为FIXED。</li><li>如果突发为INCR，地址必须与缓存行大小对齐。</li><li>如果突发为WRAP，地址必须与Size对齐。</li><li>请求必须可修改，即<strong>AxCACHE[1]</strong>被断言。</li><li>请求不得为独占访问，即<strong>AxLOCK</strong>被取消断言。</li><li>具有写数据的事务必须在缓存行容器内断言所有字节strobes。</li></ul><h4 id=a-ida93-缓存一致性和域a93-缓存一致性和域a><a id="a9.3 缓存一致性和域">A9.3 缓存一致性和域</a></h4><p>当多个主机共享数据时，这些主机的写入操作必须是一致的。
这意味着两个主机对同一地址位置的写入操作在所有参与主机中是可观察到的，并且顺序相同。</p><p>如果系统包含缓存，则必须采取措施确保缓存值不会过时。</p><p>在AMBA中，可以通过三种方式实现这一点：</p><ul><li>使用非缓存事务。</li><li>通过手动缓存维护进行软件一致性。</li><li>通过侦听和自动缓存维护实现硬件一致性。</li></ul><p>AXI通过为每个地址位置分配一个域来支持这些功能，这可以是系统（System）、不可共享（Non-shareable）或可共享（Shareable）。
必须对以下内容有一致的定义：</p><ul><li>哪些地址位置属于每个域。</li><li>一个地址位置归属于哪个域。</li></ul><h5 id=a-ida931-系统域a931-系统域a><a id="a9.3.1 系统域">A9.3.1 系统域</a></h5><p>系统域中的地址位置必须对所有能够访问它们的主机者可见。
这是通过确保所有系统域请求都是不可缓存的，因此不会存储在任何本地缓存中来实现的。
使用系统域使一致性变得简单，但通常性能并不高。</p><p>对设备类型内存的请求需要使用系统域。</p><h5 id=a-ida932-非共享域a932-非共享域a><a id="a9.3.2 非共享域">A9.3.2 非共享域</a></h5><p>非共享域中的地址位置不需要对其他主机可见。
对非共享位置的事务无需触发硬件一致性机制以确保可见性。</p><p>如果非共享数据在主机之间共享，则必须发出称为缓存维护操作（CMO）的事务，以在读取数据之前清除和使数据在任何本地缓存中无效。
有关更多详细信息，请参见 <em><a href="#a第10章 缓存维护">A第10章 缓存维护</a></em> 。</p><p>使用CMO进行数据共享称为软件一致性，如果主机之间的共享行为已知，这可以是一种有效的方法。
例如，如果有可预测的数据集由一个代理写入，然后由另一个代理读取。
这种方法的主要缺点是它依赖于软件的正确性。
软件中的一致性错误很容易出现，且难以调试。</p><p>为了避免一致性的丧失，在缓存非共享行时有一些规则：</p><ul><li>不允许clean非共享数据的逐出和写回。这是为了避免clean行覆盖了由其他主机写入的下游缓存中的dirty行。</li><li>不允许在从一个缓存读取非共享行时将dirty数据传递到另一个缓存。该行必须作为clean行传递，写回该行的责任仍由下游缓存承担。
这避免了后续的写回操作覆盖来自其他主机的最新更新。</li></ul><h5 id=a-ida933-可共享域a933-可共享域a><a id="a9.3.3 可共享域">A9.3.3 可共享域</a></h5><p>地址位于可共享域的位置必须对所有其他也将这些位置标记为可共享的主机可见。
具有可共享属性的请求必须侦听本地缓存并查询可能包含来自其他主机的可共享数据的缓存。</p><p>一个 AXI 组件可能需要支持可共享域的两个原因是：</p><ul><li>实现 I/O 一致性。</li><li>支持可共享缓存行在上游和下游缓存之间的移动。</li></ul><p>这些情况在 <em><a href="#a9.4 io一致性">A9.4 io一致性</a></em> 和 <em><a href="#a9.5 缓存可共享行">A9.5 缓存可共享行</a></em> 中进行了说明。</p><p>可共享域中的请求可以使用 INCR 或 WRAP 的突发类型，而不是 FIXED。</p><h5 id=a-ida934-域信号a934-域信号a><a id="a9.3.4 域信号">A9.3.4 域信号</a></h5><p>域信号是可选的，如果接口没有域信号，则非缓存请求被认为在系统域内，而缓存请求被认为在非共享域内。</p><p>如果一个组件需要支持共享域，则必须包含域信号。</p><p>Shareable_Transactions 属性用于描述一个接口是否支持共享域，从而决定是否具有域信号。</p><p><a id="表 a9.3">表 A9.3</a> Shareable_Transactions属性</p><table><thead><tr><th>Shareable_Transactions</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>可共享域支持。<br><strong>AxDOMAIN</strong> 信号在接口上。</td></tr><tr><td>False</td><td>Y</td><td>可共享域支持。<br><strong>AxDOMAIN</strong> 信号不在接口上。</td></tr></tbody></table><p>当Shareable_Transactions为真时，以下信号会包含在接口中。</p><p><a id="表 a9.5">表 A9.5</a> <strong>AxDOMAIN</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWDOMAIN</strong><br><strong>ARDOMAIN</strong></td><td>2</td><td>0b00：缓存请求<br>0b11：非缓存请求</td><td>请求的共享域特性。</td></tr></tbody></table><p>Shareable_Transactions编码在AxDOMAIN信号中，如下所示</p><p><a id="表 a9.5">表 A9.5</a> <strong>AxDOMAIN</strong>编码</p><table><thead><tr><th><strong>AxDOMAIN</strong></th><th>Label</th><th>Meaning</th></tr></thead><tbody><tr><td>0b00</td><td>Non-shareable</td><td>Non-shareable domain</td></tr><tr><td>0b01</td><td>Shareable</td><td>Shareable domain</td></tr><tr><td>0b10</td><td>Shareable</td><td>Shareable domain</td></tr><tr><td>0b11</td><td>System</td><td>System domain</td></tr></tbody></table><p>在该规范的早期版本中，<strong>AxDOMAIN</strong> 值 0b01 和 0b10 分别表示内共享和外共享。
在本版本中，建议使用 0b10 来表示共享域。</p><p>连接具有不同 Shareable_Transactions 值的主机和从属接口的指导见表 <em><a href="#表 a9.6">表 A9.6</a></em> 。</p><table><thead><tr><th>Shareable_Transactions</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>如果添加逻辑以从<strong>AxCACHE</strong>生成默认的<strong>AxDOMAIN</strong>值则兼容。</td></tr><tr><td>主机：True</td><td>兼容<br><strong>AxDOMAIN输出不连接。</td><td>兼容</td></tr></tbody></table><h5 id=a-ida935-域一致性a935-域一致性a><a id="a9.3.5 域一致性">A9.3.5 域一致性</a></h5><p>地址位置可以标记为某一代理可共享而对另一代理不可共享。
为了避免一致性丧失，作为不可共享缓存的数据必须在被标记为可共享的代理访问之前通过CMO使其可见。</p><h5 id=a-ida936-域和内存类型a936-域和内存类型a><a id="a9.3.6 域和内存类型">A9.3.6 域和内存类型</a></h5><p>域和内存类型的组合决定了完成事务必须访问哪些缓存。</p><p>合法的内存类型和域的组合如 <em><a href="#表 a9.7">表 A9.7</a></em> 所示。该表还指明了在处理请求时必须访问哪些缓存。</p><ul><li>（Peer）对等缓存是通过侦听请求访问的缓存，这需要像AMBA CHI这样的连贯协议。</li><li>（Inline）内联缓存是请求在向内存进行时经过的缓存。</li></ul><p><a id="表 a9.7">表 A9.7</a> 内存类型和域的合法组合</p><table><thead><tr><th>Memory type</th><th>Domain</th><th>Caches accessed</th></tr></thead><tbody><tr><td>Device<br>(AxCACHE[3:1] == 0b000)</td><td>System</td><td>None</td></tr><tr><td>Normal Non-cacheable</br>(AxCACHE[3:1] == 0b001)</td><td>Non-shareable</td><td>None</td></tr><tr><td>Normal Non-cacheable</br>(AxCACHE[3:1] == 0b001)</td><td>Shareable Peer</td><td>caches</td></tr><tr><td>Normal Non-cacheable</br>(AxCACHE[3:1] == 0b001)</td><td>System (recommended)</td><td>None</td></tr><tr><td>Normal Cacheable</br>(AxCACHE[3:2] != 0b00)</td><td>Non-shareable</td><td>Inline caches</td></tr><tr><td>Normal Cacheable</br>(AxCACHE[3:2] != 0b00)</td><td>Shareable</td><td>Inline and peer cache</td></tr></tbody></table><blockquote><p>Note：</br>正常的非缓存共享是被允许但不被期望的。一些实现可能不会在对非缓存访问时查看对等缓存。</p></blockquote><h4 id=a-ida94-io一致性a94-io一致性a><a id="a9.4 io一致性">A9.4 io一致性</a></h4><p>一个I/O一致性主机可以通过一致性互连在可共享域中读取和写入数据，但它不能被侦听，因此不能缓存可共享数据。
AXI不支持数据侦听，因此一致性互连通常基于AMBA CHI协议 <sup><em><a href=#a[5]>A[5]</a></em> </sup>，并使用AXI接口连接I/O一致性主机。</p><p><a id="图 a9.2">图 A9.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A9.2_Example_use_of_IO_coherency.png alt></a></p><p>当 I/O 一致性主机发出可共享读请求时，一致性互连会通过观察适当的一致性缓存并检查其缓存中的可共享行来尝试找到数据。
如果找不到数据，则向内存发送请求。当数据返回时，不能由 I/O 一致性主机缓存，因为数据可能会变得过时。</p><p>当 I/O 一致性主机发出可共享写请求（WriteUniquePtl 或 WriteUniqueFull）时，一致性互连会向一致性缓存发出清除和失效请求，以确保没有本地副本。
然后将数据写入缓存或内存。对于部分缓存行写入，在一致性缓存中找到的任何dirty数据都可以与写入合并。
对于 I/O 一致性接口，Shareable_Cache_Support 属性必须为 False。</p><h4 id=a-ida95-可共享缓存行a95-可共享缓存行a><a id="a9.5 可共享缓存行">A9.5 可共享缓存行</a></h4><p>一个基于AXI的缓存，可以在一个一致性的互连下游，选择存储可共享行以及不可共享缓存行。这具有以下优点：</p><ul><li>可共享行的clean evictions可以被缓存，但必须不写回内存。</li><li>可共享行中的dirty数据可以被传递到上游的可共享缓存。</li></ul><p>为此，需要额外的操作码和响应。如果缓存还存储不可共享域中的行，则缓存还必须跟踪哪些行是可共享的。
在这种情况下，一个有效的缓存行可以有四种状态：</p><ul><li>Clean</li><li>Dirty</li><li>Shareable-Clean</li><li>Shareable-Dirty</li></ul><p>关于哪些操作码可以命中哪些缓存行的规则如 <em><a href="#表 a9.8">表 A9.8</a></em> 下所示。</p><table><thead><tr><th>Opcode</th><th>Domain</th><th>Clean</th><th>Dirty</th><th>Shareable-Clean</th><th>Shareable-Dirty</th></tr></thead><tbody><tr><td>Read*</td><td>Non-shareable</td><td>Permitted to hit</td><td>Permitted to hit</td><td>Must not hit</td><td>Permitted to hit <sup><em><a href=#a[9-1]>A[9-1]</a></em></sup></td></tr><tr><td>Read*</td><td>Shareable</td><td>Permitted to hit</td><td>Must hit</td><td>Permitted to hit</td><td>Must hit <sup><em><a href=#a[9-2]>A[9-2]</a></em></sup></td></tr><tr><td>Write*</td><td>Non-shareable</td><td>Must hit</td><td>Must hit</td><td>Must not hit</td><td>Permitted to hit <sup><em><a href=#a[9-1]>A[9-1]</a></em></sup></td></tr><tr><td>Write*</td><td>Shareable</td><td>Must hit</td><td>Must hit</td><td>Must hit</td><td>Must hit</td></tr><tr><td>CleanShared*</sup></td><td>Non-shareable</td><td>Permitted to hit</td><td>Must hit</td><td>Permitted to hit</td><td>Permitted to hit</td></tr><tr><td>CleanShared*</sup></td><td>Shareable</td><td>Permitted to hit</td><td>Must hit</td><td>Permitted to hit</td><td>Must hit</td></tr><tr><td>CleanInvalid* </sup>/ MakeInvalid</td><td>Non-shareable</td><td>Must hit</td><td>Must hit</td><td>Permitted to hit <sup><em><a href=#a[9-3]>A[9-3]</a></em></sup></td><td>Permitted to hit <sup><em><a href=#a[9-3]>A[9-3]</a></em></sup></td></tr><tr><td>CleanInvalid* / MakeInvalid</td><td>Shareable</td><td>Must hit</td><td>Must hit</td><td>Must hit</td><td>Must hit</td></tr><tr><td>InvalidateHint / Prefetch</td><td>Non-shareable</td><td>Permitted to hit</td><td>Permitted to hit</td><td>Permitted to hit</td><td>Permitted to hit</td></tr><tr><td>InvalidateHint / Prefetch</td><td>Shareable</td><td>Permitted to hit</td><td>Permitted to hit</td><td>Permitted to hit</td><td>Permitted to hit</td></tr><tr><td>StashOnce*</td><td>Non-shareable</td><td>Permitted to hit</td><td>Permitted to hit</td><td>Must not hit</td><td>Permitted to hit</td></tr><tr><td>StashOnce*</td><td>Shareable</td><td>Permitted to hit</td><td>Permitted to hit</td><td>Permitted to hit</td><td>Permitted to hit</td></tr></tbody></table><p>星号（*）表示操作码的所有变体。</p><p><a id=a[9-1]>A[9-1]</a> ：该行不再标记为可共享。<br><a id=a[9-2]>A[9-2]</a> ：如果请求是 ReadShared，则可以在上游提供dirty数据。<br><a id=a[9-3]>A[9-3]</a> ：如果 RME_Support 为 True，则必须命中。</p><h5 id=a-ida951-支持完整缓存行读写的操作码a951-支持完整缓存行读写的操作码a><a id="a9.5.1 支持完整缓存行读写的操作码">A9.5.1 支持完整缓存行读写的操作码</a></h5><p>以下操作码可以用于读取和写入完整的缓存行数据。使用这些操作码的事务必须是缓存行大小且为常规类型。对于写入事务，所有写入strobes信号必须被激活。</p><p><strong>ReadClean</strong></p><p>从可共享位置读取完整的缓存行，其中数据很可能分配在上游缓存中，读取的数据必须是clean的。</p><p>如果Shareable_Cache_Support和Shareable_Transactions 两个属性都为真，则可以使用此操作码。</p><p><strong>ReadShared</strong></p><p>从可共享位置读取完整的缓存行，其中数据很可能分配在上游缓存中 读取的数据可以是clean的或dirty。如果数据是dirty的，该行必须在上游分配，
并且所有读取数据的传输响应必须是OKAYDIRTY而不是OKAY。</p><p>如果Shareable_Cache_Support和Shareable_Transactions两个属性都为真，则可以使用此操作码。</p><p><strong>WriteNoSnoopFull</strong></p><p>对完整缓存行的非共享写入，其中数据为dirty并且未在上游分配。</p><p>当上游缓存驱逐一个非共享dirty缓存行或流式写入缓存行大小的数据时，可以发出WriteNoSnoopFull事务。
如果下游缓存收到WriteNoSnoopFull请求，它可以分配该行，知道该行未在上游分配。</p><p>如果WriteNoSnoopFull事务或Shareable_Cache_Support属性为真，则可以使用此操作码。</p><p><a id="表 a9.9">表 A9.9</a> WriteNoSnoopFull_Transaction 属性</p><table><thead><tr><th>WriteNoSnoopFull_Transaction</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>WriteNoSnoopFull 支持</td></tr><tr><td>False</td><td>Y</td><td>除非Shareable_Cache_Support为True，否则WriteNoSnoopFull不支持。</td></tr></tbody></table><p><strong>WriteUniqueFull</strong></p><p>一个可共享的完全缓存行的写入，其中数据是dirty的但未在上游分配。</p><p>该事务由I/O一致主机使用，以写入可能存储在一致性域内缓存中的缓存行。系统缓存可以将该行分配为可共享的dirty数据。</p><p>如果Shareable_Transactions属性为真，则可以使用此操作码。</p><p><strong>WriteBackFull</strong></p><p>当可共享的dirty缓存行从一致性缓存中驱逐时，可以使用WriteBackFull事务。
该事务使系统缓存能够将该行分配为可共享的dirty数据。</p><p>如果Shareable_Cache_Support和Shareable_Transactions属性均为真，则可以使用此操作码。</p><p><strong>WriteEvictFull</strong></p><p>当可共享的clean缓存行从一致性缓存中驱逐时，可以使用WriteEvictFull事务。该事务使系统缓存能够将该行分配为可共享的clean数据。</p><p>可共享的clean缓存行不得暴露给可共享域外的任何代理，因为该行可能在可共享域内的缓存中变得过时。
出于同样的原因，WriteEvictFull的数据显示不得更新内存。</p><p>如果Shareable_Cache_Support和Shareable_Transactions属性均为真，则可以使用此操作码。</p><h5 id=a-ida952-可共享内存支持的配置a952-可共享内存支持的配置a><a id="a9.5.2 可共享内存支持的配置">A9.5.2 可共享内存支持的配置</a></h5><p>Shareable_Cache_Support属性用于指示一个接口是否支持存储一致性缓存行所需的附加事务操作码。</p><p><a id="表 a9.10">表 A9.10</a> Shareable_Cache_Support 属性</p><table><thead><tr><th>Shareable_Cache_Support</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持对可缓存行的附加操作码。</td></tr><tr><td>False</td><td>Y</td><td>不支持对可缓存行的附加操作码。</td></tr></tbody></table><p>根据Shareable_Cache_Support属性的值，显示了主机和从机之间的兼容性。</p><p><a id="表 a9.11">表 A9.11</a> Shareable_Cache_Support 兼容性</p><table><thead><tr><th>Shareable_Cache_Support</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容</td></tr><tr><td>主机：True</td><td>不兼容。<br>必须使用替代操作码。</td><td>兼容</td></tr></tbody></table><p>可共享请求也可以在重置时通过可选的主机输入信号<strong>BROADCASTSHAREABLE</strong>进行控制。</p><p><a id="表 a9.13">表 A9.13</a><strong> BROADCASTSHAREABLE</strong> 信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>BROADCASTSHAREABLE</strong></td><td>1</td><td>0b1</td><td>主机绑定输入，用于控制从机发出的可共享事务。</td></tr></tbody></table><p>当BROADCASTSHAREABLE存在且未激活时，所有事务在发送之前都转换为非共享等效项，如图所示</p><p><a id="表 a9.13">表 A9.13</a> 替代操作码</p><table><thead><tr><th>Opcode</th><th>BROADCASTSHAREABLE is LOW</th></tr></thead><tbody><tr><td>WriteUniquePtl</td><td>WriteNoSnoop</td></tr><tr><td>WriteUniqueFull</td><td>WriteNoSnoop or WriteNoSnoopFull</td></tr><tr><td>WriteBackFull</td><td>WriteNoSnoop or WriteNoSnoopFull</td></tr><tr><td>WriteEvictFull</td><td>- (request must be dropped)</td></tr><tr><td>CMO (Shareable)</td><td>CMO (Non-shareable)</td></tr><tr><td>WriteUniquePtlStash</td><td>WriteNoSnoop</td></tr><tr><td>WriteUniqueFullStash</td><td>WriteNoSnoop or WriteNoSnoopFull</td></tr><tr><td>WritePtlCMO (Shareable)</td><td>WritePtlCMO (Non-shareable)</td></tr><tr><td>StashOnceShared (Shareable)</td><td>StashOnceShared (Non-shareable)</td></tr><tr><td>StashOnceUnique (Shareable)</td><td>StashOnceUnique (Non-shareable)</td></tr><tr><td>Prefetch (Shareable)</td><td>Prefetch (Non-shareable)</td></tr><tr><td>ReadOnce</td><td>ReadNoSnoop</td></tr><tr><td>ReadShared</td><td>ReadNoSnoop</td></tr><tr><td>ReadClean</td><td>ReadNoSnoop</td></tr><tr><td>ReadOnceCleanInvalid</td><td>ReadNoSnoop</td></tr><tr><td>ReadOnceMakeInvalid</td><td>ReadNoSnoop</td></tr></tbody></table><h4 id=a-ida96-预取事务a96-预取事务a><a id="a9.6 预取事务">A9.6 预取事务</a></h4><p>当一个主机有迹象表明可能需要某个地址的数据，但还不想承诺立即读取时，它可以向系统发送预取请求，以提前准备该位置进行读取。
这个请求可以导致数据分配到下游缓存或从片外内存中提取，随后主机才会发出实际的读取请求。</p><p>预取请求不需要与其他请求（如CMO）有顺序关系，因此不应使用预取来指示某一行可以被提取到受管或可见缓存中。</p><p>对读取请求的预取响应表明该事务命中了预取的数据。
主机可以将此作为启发式的一部分，以决定是否继续发出预取请求。</p><p>在AMBA CHI <sup><em><a href=#a[5]>A[5]</a></em> </sup>中，预取请求的等价物是PrefetchTgt，可以与同一地址的连贯请求同时发出。
PrefetchTgt可以绕过任何连贯性检查，并使内存控制器预取数据，以防连贯请求在任何共享缓存中找不到该数据。
如果内存控制器使用AXI接口，则CHI PrefetchTgt请求可以转换为AXI预取请求。</p><h5 id=a-ida961-预取事务的规则a961-预取事务的规则a><a id="a9.6.1 预取事务的规则">A9.6.1 预取事务的规则</a></h5><p>预取是一个无数据事务，其规则如下：</p><ul><li>预取事务由AW通道上的请求和B通道上的单个响应传输组成，没有数据传输。</li><li>预取请求通过0b01111的<strong>AWSNOOP</strong>操作码进行信号传递。</li><li>预取请求必须是缓存行大小，并具有以下约束：<ul><li>该事务是常规的，详见 <em><a href="#a4.1.8 常规事务">A4.1.8 常规事务</a></em> 。</li><li><strong>AWCACHE[1]</strong>被断言，即为正常事务。
– <strong>AWDOMAIN</strong>为Non-shareable或Shareable。</li><li><strong>AWLOCK</strong>未被断言，不为独占访问。</li></ul></li><li>ID值必须在事务中唯一，这意味着：<ul><li>仅当没有使用相同<strong>AWID</strong>的未决写入事务时，才能发出预取请求。</li><li>主机不得对与未决的预取请求具有相同<strong>AWID</strong>的写通道发出请求。</li><li>如果接口上存在，预取事务必须确认<strong>AWIDUNQ</strong>。</li></ul></li><li>主机可以选择是否在预取请求之后对同一地址发出非预取请求。</li><li>任一级的下级接口可以选择传播或响应预取请求。</li><li>允许以OKAY、DECERR、SLVERR或TRANSFAULT响应预取请求。无论下级是否对预取请求采取行动，均可发送OKAY响应。</li></ul><p>Prefetch_Transaction 属性用于指示组件是否支持预取操作码，如 <em><a href="#表 a9.14">表 A9.14</a></em> 所示。</p><p><a id="表 a9.14">表 A9.14</a> Prefetch_Transaction属性</p><table><thead><tr><th>Prefetch_Transaction</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持预取</td></tr><tr><td>False</td><td>Y</td><td>不支持预取</td></tr></tbody></table><h5 id=a-ida962-预取数据的响应a962-预取数据的响应a><a id="a9.6.2 预取数据的响应">A9.6.2 预取数据的响应</a></h5><p>如果读取请求命中由于之前的预取请求而准备好的数据，从机可以返回预取响应。
这个响应可以被主机用来确定其预取请求的成功率。</p><p>预取响应有以下规则和建议：</p><ul><li>预取响应使用<strong>RRESP</strong>编码0b100进行信号传递。</li><li>当Prefetch_Transaction为真时，RRESP_WIDTH必须为3，以便启用预取响应的信号传递。</li><li>预取表示读取的数据是有效的，并且来自于预取源。</li><li>预取可用于以下交易类型的响应：<ul><li>ReadNoSnoop</li><li>ReadOnce</li><li>ReadClean</li><li>ReadShared</li><li>ReadOnceCleanInvalid</li><li>ReadOnceMakeInvalid</li></ul></li><li>不能为独占读取发送预取响应。</li><li>建议在一个缓存行内使用预取响应进行所有数据传输或不进行数据传输。如果一个事务跨越多个缓存行，则每个访问的缓存行可以混合使用预取和其他响应。</li><li>只有在接口的Prefetch_Transaction属性为真时，才能发送预取响应。</li><li>即使主机没有向该位置发送预取请求，也可以向主机发送预取响应。例如，如果主机恰好读取了被另一个主机预取的数据。</li></ul><h4 id=a-ida97-缓存存储a97-缓存存储a><a id="a9.7 缓存存储">A9.7 缓存存储</a></h4><p>缓存存储使一个组件能够指示数据应放置在系统中的另一个缓存中。
这种技术可以确保数据靠近其使用点，从而潜在地提高整体系统的性能。
AXI协议支持带或不带存储目标标识符的缓存存储请求。</p><p>缓存存储是一个提示。缓存或系统组件可以选择忽略请求的存储部分。</p><p>I/O一致的AXI主机可以请求数据存储在具有AMBA CHI接口 <sup><em><a href=#a[5]>A[5]</a></em> </sup>的完全一致的主机中。</p><h5 id=a-ida971-暂存事务操作码a971-暂存事务操作码a><a id="a9.7.1 暂存事务操作码">A9.7.1 暂存事务操作码</a></h5><p>有四个 Opcodes 可用于暂存。</p><p><strong>WriteUniquePtlStash</strong></p><p>写入可共享位置，指示数据应分配到缓存中。可以写入缓存行中的任意数量的字节，包括所有字节或零字节。</p><p><strong>WriteUniqueFullStash</strong></p><p>将完整的缓存行数据写入可共享位置，指示数据应分配到缓存中。事务必须是缓存行大小且为常规事务。所有写入信号必须被断言。</p><p><strong>StashOnceShared</strong></p><p>一种无数据事务，指示应将缓存行提取到特定缓存中。其他行的副本不需要失效。</p><p><strong>StashOnceUnique</strong></p><p>一种无数据事务，指示应将缓存行提取到特定缓存中。建议失效所有其他副本。</p><p>StashOnceUnique 事务可能导致缓存行的缓存副本失效，必须注意确保此类事务不会干扰独占访问序列。</p><p>对于支持未转换事务特性的接口，还支持额外的存储事务。
StashTranslation 事务用于向系统内存管理单元（SMMU）指示应为随 StashTranslation 事务提供的地址获取转换。
请参见 <em><a href="#a14.7 暂存转换操作码">A14.7 暂存转换操作码</a></em></p><h5 id=a-ida972-暂存信号a972-暂存信号a><a id="a9.7.2 暂存信号">A9.7.2 暂存信号</a></h5><p>暂存请求在写请求通道上发送，并在写响应通道上有单一的响应传输。
与暂存事务一起写入的内容也包括写入数据。</p><p>暂存请求在域、大小和长度上有约束，如 <em><a href="#表 a9.15">表 A9.15</a></em> 所示。缓存暂存事务不允许跨越缓存行边界。</p><p><a id="表 a9.15">表 A9.15</a> 暂存请求的域、大小、长度约束</p><table><thead><tr><th>操作码</th><th><strong>AWSNOOP</strong></th><th>域</th><th>大小和长度</th></tr></thead><tbody><tr><td>WriteUniquePtlStash</td><td>0b1000</td><td>可缓存</td><td>缓存大小或者更小</td></tr><tr><td>WriteUniqueFullStash</td><td>0b1001</td><td>可缓存</td><td>缓存行大小以及常规</td></tr><tr><td>StashOnceShared</td><td>0b1100</td><td>不可缓冲和可缓存</td><td>缓存行大小以及常规</td></tr><tr><td>StashOnceUnique</td><td>0b1101</td><td>不可缓冲和可缓存</td><td>缓存行大小以及常规</td></tr></tbody></table><p>以下约束也适用于所有暂存请求操作码：</p><ul><li><strong>AWCACHE[1]</strong> 为0b1：可修改</li><li><strong>AWLOCK</strong>为0b0：非独占访问</li><li><strong>AWTAGOP</strong>为0b00：无效的</li><li><strong>AWATOP</strong>0b00000：非原子操作</li></ul><h5 id=a-ida973-暂存请求域a973-暂存请求域a><a id="a9.7.3 暂存请求域">A9.7.3 暂存请求域</a></h5><p>暂存请求的域决定了将检查哪些缓存以获取缓存行以及如何获取和存储该行。</p><p>对可共享位置的暂存请求意味着该行可以存储在对等缓存或内联缓存中。
如果暂存请求导致缓存发出下游请求，则如果可能的话应该是可共享的。对存储的写入必须始终指向可共享位置。</p><p>对非共享位置的暂存请求意味着该行可以存储在内联缓存中。
如果暂存请求导致缓存发出下游请求，则必须是非共享的。
StashOnceShared 和 StashOnceUnique 操作码可以是可共享或非共享位置。</p><h5 id=a-ida974-暂存目标标识a974-暂存目标标识a><a id="a9.7.4 暂存目标标识">A9.7.4 暂存目标标识</a></h5><p>一个暂存请求可以选择性地包含目标标识符，以指示首选用于暂存数据的特定缓存。
该规格未定义该识别机制的具体细节。预计执行暂存操作的任何代理都知道用于特定暂存事务的标识符。
该规格定义了两个识别级别：</p><ul><li>节点 ID 用于识别缓存存储应发送到的物理接口。</li><li>逻辑处理器 ID 用于识别与该物理接口相关的功能单元。</li></ul><p>例如，暂存事务可以指定一个处理器集群接口和该集群内的具体缓存。</p><p>用于指示存储目标的信号如 <em><a href="#表 a9.16">表 A9.16</a></em> 所示。</p><p><a id="表 a9.16">表 A9.16</a> 表明暂存目标的信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWSTASHNID</strong></td><td>11</td><td>全0</td><td>暂存操作目标的节点id。</td></tr><tr><td><strong>AWSTASHNIDEN</strong></td><td>1</td><td>0b0</td><td>暂存操作目标节点id的使能。</td></tr><tr><td><strong>AWSTASHLPID</strong></td><td>5</td><td>0x00</td><td>暂存操作目标的逻辑处理器id。</td></tr><tr><td><strong>AWSTASHLPIDEN</strong></td><td>1</td><td>0b0</td><td>暂存操作目标的逻辑处理器id的使能。</td></tr></tbody></table><p>节点ID和逻辑处理器ID信号在接口上是可选的，分别通过STASHNID_Present和STASHLPID_Present属性进行控制。</p><p><a id="表 a9.17">表 A9.17</a> STASHNID_Present 属性</p><table><thead><tr><th>STASHNID_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td><strong>AWSTASHNID</strong>和<strong>AWSTASHNIDEN</strong>存在。</td></tr><tr><td>False</td><td>Y</td><td><strong>AWSTASHNID</strong>和<strong>AWSTASHNIDEN</strong>不存在。</td></tr></tbody></table><p><a id="表 a9.18">表 A9.18</a></p><table><thead><tr><th>STASHLPID_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td><strong>AWSTASHLPID</strong>和<strong>AWSTASHLPIDEN</strong>存在。</td></tr><tr><td>False</td><td>Y</td><td><strong>AWSTASHLPID</strong>和<strong>AWSTASHLPIDEN</strong>不存在。</td></tr></tbody></table><p>每个暂存目标标识符都有一个使能信号，因此 NID 和 LPID 可以独立控制：</p><ul><li>对于暂存事务，允许任何目标使能的组合。</li><li>对于非暂存事务，<strong>AWSTASHLPIDEN</strong> 和 <strong>AWSTASHNIDEN</strong> 必须为低。</li><li>当 <strong>AWSTASHNIDEN</strong> 为低时，<strong>AWSTASHNID</strong> 为无效且必须为零。</li><li>当 <strong>AWSTASHLPIDEN</strong> 为低时，<strong>AWSTASHLPID</strong> 为无效且必须为零。</li><li>发送一个指示不支持缓存暂存的暂存目标的暂存事务是被允许的，但不推荐。</li></ul><p>对于无目标的 WriteUniquePtlStash 和 WriteUniqueFullStash 请求，建议如下：</p><ul><li>如果互连可以确定在写入发生之前该行被单个缓存持有，则将缓存行暂存到该缓存。</li><li>如果在写入发生之前，该缓存行不被任何缓存持有，则将在共享系统缓存中暂存该缓存行。</li></ul><p>对于无目标的 StashOnceShared 和 StashOnceUnique 请求：</p><ul><li>如果互连可以确定缓存行不在任何缓存中，则建议在共享系统缓存中暂存该缓存行。</li><li>组件可以使用此功能将缓存行预取到下游缓存以供其自己使用。</li></ul><h5 id=a-ida975-暂存事务的ida975-暂存事务的ida><a id="a9.7.5 暂存事务的id">A9.7.5 暂存事务的id</a></h5><p>对于WriteUniquePtlStash和WriteUniqueFullStash事务，不存在对AXI ID值的使用限制。</p><p>StashOnceShared和StashOnceUnique可以称为StashOnce事务。
StashOnce事务不得使用与同时存在的非StashOnce事务相同的AXI ID值。
这条规则确保了StashOnce事务与其他事务之间不存在排序约束。
因此，丢弃StashOnce请求的组件可以在不检查ID排序要求的情况下立即响应。</p><p>允许StashOnce事务和非StashOnce事务使用相同的AXI ID值，前提是同一个ID值不能同时被StashOnce事务和非StashOnce事务使用。</p><p>可以有多个具有相同ID的未完成StashOnce事务。</p><p>可以有多个具有相同ID的未完成非StashOnce事务。</p><p>为StashOnce事务使用唯一的ID值确保在不支持这些事务时可以给出立即响应。</p><h5 id=a-ida976-暂存事务的支持a976-暂存事务的支持a><a id="a9.7.6 暂存事务的支持">A9.7.6 暂存事务的支持</a></h5><p>Cache_Stash_Transactions 属性用于指示接口是否支持缓存暂存，如 <em><a href="#表 a9.19">表 A9.19</a></em> 所示。</p><p><a id="表 a9.19">表 A9.19</a> Cache_Stash_Transactions 属性</p><table><thead><tr><th>Cache_Stash_Transactions</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>所有缓暂存的操作码都被支持。<br>可能有或者没有暂存目标。</td></tr><tr><td>Basic</td><td></td><td>仅支持 StashOnceShared 操作码。<br>不允许使用暂存目标。<br>STASHLPID_Present 和 STASHNID_Present 必须为False</td></tr><tr><td>False</td><td>Y</td><td>缓存暂存不支持且相关信号被省略。</td></tr></tbody></table><p><a id="表 a9.20">表 A9.20</a> Cache_Stash_Transactions 兼容性</p><table><thead><tr><th>Cache_Stash_Transactions</th><th>从机：False</th><th>从机：Basic</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>主机：Basic</td><td>不兼容。<br>参考 <em><a href="#表 a9.21">表 A9.21</a></em></td><td>兼容</td><td>兼容</td></tr><tr><td>主机：True</td><td>不兼容。<br>参考 <em><a href="#表 a9.21">表 A9.21</a></em></td><td>不兼容</td><td>兼容</td></tr></tbody></table><p>如果主机向不支持的目标发出暂存请求，则可以在主机或互联上采取行动，如图 <em><a href="#表 a9.21">表 A9.21</a></em> 所示。</p><p><a id="表 a9.21">表 A9.21</a></p><table><thead><tr><th>Stash transaction</th><th>Action</th></tr></thead><tbody><tr><td>WriteUniquePtlStash</td><td>转换为 WriteUniquePtl.</td></tr><tr><td>WriteUniqueFullStash</td><td>转换为 to WriteUniqueFull.</td></tr><tr><td>StashOnceShared</td><td>不传输并且立刻给出响应.</td></tr><tr><td>StashOnceUnique</td><td>不传输并且立刻给出响应</td></tr></tbody></table><h4 id=a-ida98-读取事务去分配a98-读取事务去分配a><a id="a9.8 读取事务去分配">A9.8 读取事务去分配</a></h4><p>读取事务去分配可以用于当某个主机需要的数据不太可能被其他主机再次使用时。
缓存可以将此作为提示以驱逐该行并为其他数据提供资源。</p><p>DeAllocation_Transactions属性用于指示组成部分是否支持事务去分配，如 <em><a href="#表 a9.22">表 A9.22</a></em> 所示。</p><p>发出事务去分配的组件与不支持它们的组件之间的互操作性可以通过将操作码转换为ReadOnce来实现。</p><p><a id="表 a9.22">表 A9.22</a> DeAllocation_Transactions属性</p><table><thead><tr><th>DeAllocation_Transactions</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持事务去分配分配。</td></tr><tr><td>False</td><td>Y</td><td>不支持事务去分配分配。</td></tr></tbody></table><h5 id=a-ida981-读取事务去分配操作码a981-读取事务去分配操作码a><a id="a9.8.1 读取事务去分配操作码">A9.8.1 读取事务去分配操作码</a></h5><p>本规范定义了读取请求通道上的两种接触事务分配操作码：</p><p><strong>ReadOnceCleanInvalid (ROCI)</strong></p><p>该请求读取缓存行当前值的快照。建议，但不要求，任何缓存的缓存行副本被去分配。
如果存在缓存行的dirty拷贝，并且缓存行被接触分配，则该dirty拷贝必须写回主内存。</p><p>ReadOnceCleanInvalid 的信号使用 <strong>ARSNOOP</strong> 值为 0b0100。</p><p><strong>ReadOnceMakeInvalid (ROMI)</strong></p><p>该请求读取缓存行当前值的快照。建议，但不要求，任何缓存的缓存行副本被接触分配。
允许，但不要求，丢弃缓存行的dirty拷贝。缓存行的dirty拷贝不需要写回主内存。</p><p>ReadOnceMakeInvalid 的信号使用 <strong>ARSNOOP</strong> 值为 0b0101。</p><h5 id=a-ida982-读取事务去分配的规则和建议a982-读取事务去分配的规则和建议a><a id="a9.8.2 读取事务去分配的规则和建议">A9.8.2 读取事务去分配的规则和建议</a></h5><p>去分配事务只能同时访问一个缓存行，并且不允许跨越缓存行边界。
大小必须是缓存行大小或更小。</p><p>对缓存行某部分的ROMI请求可能导致整个缓存行失效。
一些实现可能不支持小于缓存行的事务去分配行为，而是将此类事务转换为ReadOnce。</p><p>ROCI和ROMI仅支持共享域，因此如果DeAllocation_Transactions为True，则Shareable_Transactions属性必须为True。</p><p>对于ROMI事务，要求在返回事务的第一个读取数据项之前，必须确认缓存行的失效。
在这一点上，不要求缓存行的失效已完成。
然而，必须确保从此时开始的任何后续写事务不会被此事务使其失效。</p><p>以下考虑适用于去分配事务的使用：</p><ul><li>在去分配事务被发往其他代理正用于独占访问的同一缓存行时需要谨慎。这是因为去分配可能导致独占序列失败。</li><li>除了与独占访问的交互，ROCI事务仅提供去分配缓存行的提示，对系统的正确性没有其他影响。</li><li>使用ROMI事务可能会导致dirty缓存行的丢失。此事务的使用必须严格限制在已知安全的情况下。</li><li>去分配事务不保证缓存行将被清除或失效，因此不能用于确保数据对所有观察者可见。</li></ul><h4 id=a-ida99-无效提示a99-无效提示a><a id="a9.9 无效提示">A9.9 无效提示</a></h4><p>InvalidateHint事务是一种无数据的去分配提示。
当一个主机完成对一个数据集的处理，并且该数据可能在下游缓存中分配时，可以使用InvalidateHint请求。
InvalidateHint请求通知缓存，该行不再需要，可以被作废。允许但不要求对该行进行写回。</p><p>对于功能正确性，InvalidateHint并不是必需的。因此可以在系统中的任何时刻通过响应BRESP的OKAY来终止。</p><p>使用InvalidateHint事务时需要小心，以避免暴露先前被覆盖的值。这可以通过以下方式实现：</p><ul><li>确保在擦洗写入后执行的干净操作可以确保写入已经传播到足够远的地方，以至于不会被Invalidate Hint事务删除。</li><li>确保InvalidateHint事务的使用限制在不包含敏感信息的地址范围内。</li></ul><h5 id=a-ida991-无效提示信号a991-无效提示信号a><a id="a9.9.1 无效提示信号">A9.9.1 无效提示信号</a></h5><p>InvalidateHint是一种使用AW和B通道的数据无关事务。<br>以下约束适用于InvalidateHint请求：</p><ul><li><strong>AWSNOOP</strong>为0b10010。<ul><li>如果InvalidateHint_Transaction属性为True，则<strong>AWSNOOP</strong>必须为5b宽。</li></ul></li><li><strong>AWDOMAIN</strong>可以是非共享的或共享的。</li><li><strong>AWBURST</strong>为INCR。</li><li><strong>AWSIZE</strong>和<strong>AWLEN</strong>必须是缓存行大小且为常规。</li><li><strong>AWCACHE</strong>为普通可缓存。</li><li><strong>AWID</strong>是传输中唯一的，这意味着：<ul><li>仅在写通道上没有使用相同ID值的未完成事务时，才能发出InvalidateHint请求。</li><li>主机不得在写通道上发出与未完成的InvalidateHint事务相同ID的请求。</li></ul></li><li>如果存在，<strong>AWIDUNQ</strong>必须在InvalidateHint请求中被断言。</li><li><strong>AWLOCK</strong>被去断言，这不是独占访问。</li><li><strong>AWTAGOP</strong>为无效。</li><li><strong>AWATOP</strong>为非原子操作。</li></ul><h5 id=a-ida992-无效提示支持a992-无效提示支持a><a id="a9.9.2 无效提示支持">A9.9.2 无效提示支持</a></h5><p>InvalidateHint_Transaction 属性用于指示接口是否支持 InvalidateHint 事务，如 <em><a href="#表 a9.23">表 A9.23</a></em> 所示。</p><p><a id="表 a9.23">表 A9.23</a> InvalidateHint_Transaction属性</p><table><thead><tr><th>InvalidateHint_Transaction</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持InvalidateHint事务。</td></tr><tr><td>False</td><td>Y</td><td>不支持InvalidateHint事务。</td></tr></tbody></table><p>根据InvalidateHint_Transaction属性的值，主机和从机之间的兼容性如 <em><a href="#表 a9.24">表 A9.24</a></em> 所示。</p><p><a id="表 a9.24">表 A9.24</a></p><table><thead><tr><th>InvalidateHint_Transaction</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容</td></tr><tr><td>主机：True</td><td>不兼容。<br>一个对InvalidateHint响应为OKAY的适配器可以用来使其兼容。</td><td>兼容</td></tr></tbody></table><h3 id=a-ida第10章-缓存维护a第10章-缓存维护a><a id="a第10章 缓存维护">A第10章 缓存维护</a></h3><p>本章描述了软件缓存管理辅助下的缓存维护操作（CMOs）。它包含以下几个部分：</p><ul><li><em><a href="#a10.1 cmo">A10.1 CMO</a></em></li><li><em><a href="#a10.2 cmo动作">A10.2 CMO动作</a></em></li><li><em><a href="#a10.3 cmo属性">A10.3 cmo属性</a></em></li><li><em><a href="#a10.4 cmo 传输">A10.4 cmo 传输</a></em></li><li><em><a href="#a10.5 写通道的cmos">A10.5 写通道的CMOs</a></em></li><li><em><a href="#a10.6 cmo写">A10.6 cmo写</a></em></li><li><em><a href="#a10.7 读通道的cmos">A10.7 读通道的CMOs</a></em></li><li><em><a href="#a10.8 cmos持续">A10.8 CMOs持续</a></em></li><li><em><a href="#a10.9 缓存维护和领域管理扩展">A10.9 缓存维护和领域管理扩展</a></em></li><li><em><a href="#a10.10 处理器缓存维护指令">A10.10 处理器缓存维护指令</a></em></li></ul><h4 id=a-ida101-cmoa101-cmoa><a id="a10.1 cmo">A10.1 CMO</a></h4><p>缓存维护操作是指示缓存清理和使缓存行失效的请求。
与分配和去分配提示不同，缓存必须执行针对其缓存行的缓存维护操作。</p><p>缓存维护操作可以通过读取或写入通道传输。</p><p>为了支持遗留组件，本规范将缓存维护操作通过读取通道传输纳入规定。
建议新设计通过写入通道传输缓存维护操作。</p><p>该规范支持以下缓存维护操作：</p><p><strong>CleanShared(CS)</strong></p><p>完成后，所有缓存的目标行副本被清理，并且任何相关的写入都可观察。</p><p><strong>CleanSharedPersist(CSP)</strong></p><p>完成后，所有缓存的目标行副本被清理，并且任何相关的写入都可观察并且已达到持久性点 (PoP)。参见 <em><a href=#a10.8持久性的cmos>A10.8持久性的CMOSs</a></em> 。</p><p><strong>CleanSharedDeepPersist(CSDP)</strong></p><p>完成后，所有缓存的目标行副本被清理，并且任何相关的写入都可观察并且已达到深度持久性点 (PoDP)。参见 <em><a href=#a10.8持久性的cmos>A10.8持久性的CMOSs</a></em> 。</p><p><strong>CleanInvalid (CI)</strong></p><p>完成后，所有缓存的目标行副本被失效，如果它们是dirty的，则已写入内存。任何相关的写入都可观察。</p><p><strong>CleanInvalidPoPA (CIPA)</strong></p><p>完成后，所有缓存的目标行副本被失效，并且任何dirty的缓存副本在物理别名点 (PoPA) 之前被写入。参见 <em><a href="#a10.9 缓存维护和领域管理扩展">A10.9 缓存维护和领域扩展</a></em> 。</p><p><strong>MakeInvalid (MI)</strong></p><p>完成后，所有缓存的目标行副本被失效，并且任何dirty的缓存副本可能已被丢弃。</p><h4 id=a-ida102-cmo动作a102-cmo动作a><a id="a10.2 cmo动作">A10.2 CMO动作</a></h4><p>当一个组件接收到CMO时，它必须执行以下操作：</p><ol><li>如果该组件是一个缓存并且CMO是可缓存的，则必须查找该行。</li><li>如果该组件是一个一致性互连并且CMO是可共享的，则必须向任何可能拥有该行的缓存发送CMO监视：<ul><li>对于无效CMO，Allocated。</li><li>对于清除CMO，Dirty。</br>注意，需要使用像AMBA CHI这样的连贯协议来发送CMO监视请求。</li></ul></li><li>对于清除CMO，写回在缓存或对等缓存中发现的任何dirty数据。</br>建议对将跟随到同一行CMO内存的写入使用写穿透无分配。这确保该行将在任何下游缓存中被查找，但不会被分配。</li><li>等待所有监视和相关写操作收到响应。</li><li>如果CMO不需要传送到下游，组件可以对CMO发出响应。</li><li>如果CMO确实需要传送到下游，则必须发送CMO，并且必须在从下游接收到时传播返回的响应。</li></ol><h4 id=a-ida103-cmo请求属性a103-cmo请求属性a><a id="a10.3 cmo请求属性">A10.3 CMO请求属性</a></h4><p>以下规则适用于CMO事务：</p><ul><li>请求必须是缓存行大小且为常规。有关更多细节，请参见 <em><a href="#a4.1.8 常规事务">A4.1.8 常规事务</a></em></li><li>域可以是不可共享或可共享。<ul><li>不允许使用系统域，这意味着CMO事务必须为正常而不是设备。</li></ul></li></ul><p><strong>AxCACHE</strong>和<strong>AxDOMAIN</strong>属性指示哪些缓存必须对CMO进行操作，如表所示。</p><p><a id=a10.1>A10.1</a> CMO 适用性</p><table><thead><tr><th><strong>AxCACHE</strong></th><th><strong>AxDOMAIN</strong></th><th>CMO applies to</th></tr></thead><tbody><tr><td>Device</td><td>System</td><td>N/A (not legal for CMOs)</td></tr><tr><td>Non-cacheable</td><td>Non-shareable</td><td>No caches</td></tr><tr><td>Non-cacheable</td><td>Shareable</td><td>Peer caches</td></tr><tr><td>Cacheable</td><td>Non-shareable</td><td>In-line caches</td></tr><tr><td>Cacheable</td><td>Shareable</td><td>Peer caches and in-line caches</td></tr></tbody></table><p>为了保持一致性，以下建议适用于CMO和非CMO：</p><ul><li>如果一个位置对于非CMO事务是可缓存的，它应该对于CMO事务也是可缓存的。</li><li>如果一个位置在非CMO事务的可共享域内，它应该在CMO事务的可共享域内。</li><li>如果一个位置在非CMO事务的不可共享域内，它可以在CMO事务的不可共享域或可共享域内。</li><li>主机不应发出允许其分配行的读取请求，同时该行有未解决的CMO。</li><li>分配提示，如<strong>AxCACHE[3:2]</strong>，并不要求在CMO和非CMO事务对同一缓存行时匹配。</li></ul><h4 id=a-ida104-cmo传播a104-cmo传播a><a id="a10.4 cmo传播">A10.4 CMO传播</a></h4><p>CMO在组件下游的传播依赖于系统拓扑。如果CMO是可缓存的，并且下游有一个可能已分配该行的缓存，并且该缓存下游还有一个观察者，则必须将CMO向下传播。
为控制CMO是否从主机接口传播定义了两种机制。</p><ul><li>在设计时，使用属性CMO_On_Write或CMO_On_Read。</li><li>在运行时，使用可选的<strong>BROADCASTCACHEMAINT</strong>和<strong>BROADCASTSHAREABLE</strong>连接输入到主机接口。</li></ul><p><a id="表 a10.2">表 A10.2</a> <strong>BROADCASTCACHEMAINT</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>BROADCASTCACHEMAINT</strong></td><td>1</td><td>0b1</td><td>主机捆绑输入，用于控制从机发放CMO。</td></tr></tbody></table><p>当<strong>BROADCASTCACHEMAINT</strong>和<strong>BROADCASTSHAREABLE</strong>同时存在且未激活时：</p><ul><li>不会发出CleanShared、CleanInvalid和MakeInvalid请求。</li><li>WritePtlCMO被转换为WriteNoSnoop。</li><li>WriteFullCMO被转换为WriteNoSnoop或WriteNoSnoopFul。</li></ul><h4 id=a-ida105-写通道中的cmosa105-写通道中的cmosa><a id="a10.5 写通道中的cmos">A10.5 写通道中的CMOs</a></h4><p>CMO_On_Write 属性用于指示接口是否支持写通道上的 CMO。</p><p><a id="表 a10.3">表 A10.3</a> CMO_On_Write 属性</p><table><thead><tr><th>CMO_On_Write</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>在AW和B通道中支持CMOs</td></tr><tr><td>False</td><td>Y</td><td>在AW和B通道中不支持CMOs。<br>它们要么在读取通道上被信号化，要么不被该接口使用</td></tr></tbody></table><p>在正确的通道上，CMO可以作为独立操作发送，也可以与数据写入结合。
用于在AW通道上信号CMO请求的<strong>AWSNOOP</strong>编码如 <em><a href="#表 a10.4">表 A10.4</a></em> 所示。
有关CMO操作的组合写入的更多信息，请参见 <em><a href="#a10.6 cmo写">A10.6 CMO写</a></em></p><p><a id="表 a10.4">表 A10.4</a> <strong>AWSNOOP</strong>编码</p><table><thead><tr><th><strong>AWSNOOP</strong></th><th>操作</th><th>使能属性</th><th>描述</th></tr></thead><tbody><tr><td>0b0110</td><td>CMO</td><td>CMO_On_Write</td><td>Stand-alone CMO</td></tr><tr><td>0b1010</td><td>WritePtlCMO</td><td>Write_Plus_CMO</td><td>CMO结合一个小于或等于一个缓存行的写操作。</td></tr><tr><td>0b1011</td><td>WriteFullCMO</td><td>Write_Plus_CMO</td><td>CMO结合了一个正好是一个缓存行的写入。</td></tr></tbody></table><p><strong>AWCMO</strong>信号指示请求的CMO类型，当CMO_On_Write为真时，它出现在AW通道上。</p><p><a id="表 a10.5">表 A10.5</a><strong>AWCMO</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWCMO</strong></td><td>AWCMO_WIDTH</td><td>0b000<br>CleanInvalid</td><td>指示包含缓存维护操作写操作码的CMO类型.</td></tr></tbody></table><p><strong>AWCMO</strong>的宽度由属性AWCMO_WIDTH决定。</p><p><a id="表 a10.6">表 A10.6</a></p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>AWCMO_WIDTH</td><td>0,2,3</td><td>0</td><td><strong>AWCMO</strong>的位宽。</td></tr></tbody></table><p>AWCMO_WIDTH的规则如下：</p><ul><li>如果CMO_On_Write为False，则必须为0。这意味着AWCMO不在接口上。</li><li>如果CMO_On_Write为True且RME_Support为False，则必须为2。</li><li>如果CMO_On_Write为True且RME_Support为True，则必须为3。</li></ul><p><strong>AWCMO</strong>的编码如 <em><a href="#表 a10.7">表 A10.7</a></em> 所示。
如果关联的使能属性为False，则无法使用该编码。</p><p><a id="表 a10.7">表 A10.7</a> <strong>AWCMO</strong>编码</p><table><thead><tr><th><strong>AWCMO</strong></th><th>Label</th><th>Enable property</th><th>Meaning</th></tr></thead><tbody><tr><td>0b000</td><td>CleanInvalid</td><td>-</td><td>Clean and invalidate</td></tr><tr><td>0b001</td><td>CleanShared</td><td>-</td><td>Clean only</td></tr><tr><td>0b010</td><td>CleanSharedPersist</td><td>Persist_CMO</td><td>Clean to the Point of Persistence</td></tr><tr><td>0b011</td><td>CleanSharedDeepPersist</td><td>Persist_CMO</td><td>Clean to the Point of Deep Persistence</td></tr><tr><td>0b100</td><td>CleanInvalidPOPA</td><td>RME_Support</td><td>Clean and invalidate to the Point of Physical Aliasing</td></tr><tr><td>0b101 to 0b111</td><td>RESERVED</td><td>-</td><td>-</td></tr></tbody></table><p>请注意，MakeInvalid 不支持写通道。</p><p>当 <strong>AWSNOOP</strong> 不是 CMO、WritePtlCMO 或 WriteFullCMO 时，<strong>AWCMO</strong> 必须为 0b000。</p><p>写通道上的 CMO 事务由 AW 通道上的请求和 B 通道上的响应组成。在 CMO 事务中，W 通道没有传输。</p><p>对 CMOs CleanInvalid 和 CleanShared 的写响应在 B 通道上包含单个响应传输。
这表示在指定域内所有缓存均为 Clean 和/或无效，任何相关写入都是可观察的。</p><p>Persist CMOs 描述在 <em><a href="#a10.8 持久性cmos">A10.8 持久性CMOs</a></em> 中，
POPA CMO 描述在 <em><a href="#a10.9 缓存管理和领域管理扩展">A10.9 缓存管理和领域管理扩展</a></em> 中。</p><h4 id=a-ida106-cmo写a106-cmo写a><a id="a10.6 cmo写">A10.6 CMO写</a></h4><p>缓存维护操作通常与写入内存一起使用。例如：</p><ul><li>从I/O代理的写入，必须对下游缓存的观察者可见。</li><li>写入持久内存，必须确保所有缓存行的副本都被清理到持久性的程度。</li><li>导致dirty数据写回的CMO，必须跟随CMO。</li></ul><p>带有CMO的写入将写入与CMO相结合，以提高此类场景的效率。可以预见一些主机将原生生成带有CMO的写入。
在其他情况下，缓存或互连将在向下游传播之前将CMO与写入结合。</p><p>Write_Plus_CMO属性用于指示组件是否支持写入通道上的写入和CMO组合。</p><p><a id="表 a10.8">表 A10.8</a> Write_Plus_CMO属性</p><table><thead><tr><th>Write_Plus_CMO</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持组合写入和缓存维护操作。</td></tr><tr><td>False</td><td>Y</td><td>不支持组合写入和缓存维护操作。</td></tr></tbody></table><p>如果 Write_Plus_CMO 属性为真，则 CMO_On_Write 属性也必须为真。</p><p>当 Write_Plus_CMO 为真时，可以使用 WritePtlCMO 和 WriteFullCMO 操作码来指示带有 CMO 的写入。</p><p>带有 CMO 的写入可以使用 <strong>AWCMO</strong> 指示的任何 CMO 类型。</p><p>一些带有 CMO 的写入示例用法如 <em><a href="#表 a7.10">表 A7.10</a></em> 所示。</p><p><a id="表 a10.9">表 A10.9</a> CMO写事务的例子</p><table><thead><tr><th>操作</th><th>主要使用</th><th>动作</th></tr></thead><tbody><tr><td>Shareable WritePtlCMO with CleanShared</td><td>I/O代理向可共享区域写入少于缓存行的数据时，该数据必须对缓存下游的观察者可见。</td><td>所有的内联缓存和对等缓存必须查找该行并写回任何dirty数据。<br>来自dirty缓存行的数据可以与部分写入合并，以形成一个带有CleanShared的WriteFullCMO，向下游传送。</td></tr><tr><td>Shareable WriteFullCMO with CleanSharedPersist</td><td>I/O 代理正在写入缓存行到一个可共享区域，其中数据必须到达持久性点。</td><td>一致的互连会向一致的同级缓存发出MakeInvalid 侦听。<br>在行内缓存中查找该行，更新或使任何副本失效。<br>如果下游存在持久性点，则必须传播写操作和CleanSharedPersist。</td></tr><tr><td>Non-shareable WriteFullCMO with CleanInvalid</td><td>由缓存发出当一个CleanInvalid CMO 表示一Dirty线路并导致其写入内存。</td><td>所有行内缓存条目必须被清除和失效。<br>如果下游有观察者，必须传播写入和CleanInvalid。</td></tr></tbody></table><h5 id=a-ida1061-cmo写的属性a1061-cmo写的属性a><a id="a10.6.1 cmo写的属性">A10.6.1 CMO写的属性</a></h5><p>具有CMO的写操作具有以下属性约束：</p><ul><li><strong>AWSNOOP</strong>为0b1010表示WritePtlCMO，0b1011表示WriteFullCMO。</li><li><strong>AWDOMAIN</strong>为非共享或共享。</li><li><strong>AWCACHE[1]</strong>被断言时，事务必须是可修改的。</li><li><strong>AWLOCK</strong>未断言，不是独占访问。</li></ul><p>WriteFullCMO必须是缓存行大小且为常规，见 <em><a href="#a4.1.8 常规事务">A4.1.8 常规事务</a></em></p><p>WritePtlCMO必须是缓存行大小或更小，并且不得跨越缓存行边界。相关的CMO适用于所寻址缓存行的整个内容，<strong>AWBURST</strong>不得为FIXED。</p><p>带有CMO的写操作的缓存维护部分始终被视为可缓存和共享，无论<strong>AWCACHE</strong>和<strong>AWDOMAIN</strong>如何。</p><h5 id=a-ida1062-cmo写的传播a1062-cmo写的传播a><a id="a10.6.2 cmo写的传播">A10.6.2 CMO写的传播</a></h5><p>CMO写的传播遵循与CMO传播相同的规则。可以将带有CMO的写入分成单独的写入和CMO事务以进行下游传播。在这种情况下，或者：</p><ul><li>写入首先发出，随后在与写入相同ID的写请求通道上发出CMO。</li><li>写入首先发出。当收到写入响应时，可以在写入或读取通道上发出CMO。</li></ul><p>在拆分写入和CMO时，如果<strong>AWDOMAIN</strong>是可共享的，那么：</p><ul><li>WritePtlCMO变为WriteUniquePtl。</li><li>WriteFullCMO变为WriteUniqueFull。</li></ul><p>如果<strong>AWDOMAIN</strong>是非共享的，那么写入变为WriteNoSnoop或WriteNoSnoopFull。</p><p>CMO作为可缓存的发送。如果在可共享域中存在下游缓存，则CMO作为可共享的发送。</p><p>如果没有需要通过缓存维护管理的下游缓存，则事务的CMO部分可以被丢弃。
如果丢弃的CMO是CleanSharedPersist或CleanSharedDeepPersist，
则在写入响应上必须设置<strong>BCOMP</strong>和<strong>BPERSIST</strong>信号。
有关更多详细信息，请参见 <em><a href="#a10.8 cmos持久性">A10.8 CMOs持久性</a></em> 。</p><h5 id=a-ida1063-cmos写响应a1063-cmos写响应a><a id="a10.6.3 cmos写响应">A10.6.3 CMOs写响应</a></h5><p>对带有CMO的写入的响应遵循与写通道上的CMO相同的规则。</p><p>带有CI或CS的写入有一个响应传输，表明写入和CMO都是可观察的 。</p><p>带有CSP或CSDP的写入有一个响应，表明写入是可观察的，还有一个响应表明写入已到达PoP / PoDP 。</p><p>与独立的CSP/CSDP一样，从机可以选择将两个响应合并为一个传输。</p><p>带有CMO的写入不允许使用MTE匹配操作码，因此与Persist和Match响应结合的写入响应不是必需的。<br>有关更多详细信息，请参见 <em><a href="#a13.2 内存标记扩展">A13.2 内存标记扩展</a></em></p><h5 id=a-ida1064-cmo加写的实例流程a1064-cmo加写的实力流程a><a id="a10.6.4 cmo加写的实例流程">A10.6.4 cmo加写的实力流程</a></h5><p>作为使用CMO写操作的流程示例，<em><a href="#图 a10.1">图 A10.1</a></em>
展示了一个I/O一致性主机在AW通道上向CHI互连发出一个可共享的CleanShared请求。</p><ul><li>由一致性互连生成的侦听表示一致性缓存中的dirty数据。</li><li>然后，互连发出一个Non-shareable WriteFullCMO和CleanShared。</li><li>系统缓存查找该行，覆盖任何现有的副本，并将写请求转发给内存。内存不需要接收CMO，因为其数据对所有代理都是可观察的。</li><li>当数据可观察时，内存控制器返回一个OKAY响应，该响应被传播回主机。</li></ul><p><a id="图 a10.1">图 A10.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A10.1_Example_write_with_CMO.png alt></a></p><h4 id=a-ida107-读通道上的cmosa107-读通道上的cmosa><a id="a10.7 读通道上的cmos">A10.7 读通道上的CMOs</a></h4><p>CMO_On_Read属性用于指示接口是否支持读取通道上的CMO。</p><p><a id="表 a10.10">表 A10.10</a> CMO_On_Read属性</p><table><thead><tr><th>CMO_On_Read</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td>Y</td><td>CMO在AR和R渠道上获得支持。</td></tr><tr><td>False</td><td></td><td>CMO不支持AR和R通道。它们要么在写入通道上被信号传递，要么不被该接口使用。</td></tr></tbody></table><p>CMO事务在读取通道上由AR通道的请求和R通道的单个传输响应组成。
响应指示CMO被观察到，并且所有缓存行已根据需要被清除和失效。</p><p>用于在AR通道上发出CMO请求的ARSNOOP编码如 <em><a href="#表 a10.11">表 A10.11</a></em> 所示。</p><p><a id="表 a10.11">表 A10.11</a> <strong>ARSNOOP</strong>编码</p><table><thead><tr><th>ARSNOOP</th><th>Operation</th></tr></thead><tbody><tr><td>0b1000</td><td>CleanShared</td></tr><tr><td>0b1001</td><td>CleanInvalid</td></tr><tr><td>0b1010</td><td>CleanSharedPersist</td></tr><tr><td>0b1101</td><td>MakeInvalid</td></tr></tbody></table><h4 id=a-ida108-持久性cmosa108-持久性cmosa><a id="a10.8 持久性cmos">A10.8 持久性CMOs</a></h4><p>缓存维护操作用于持久性，旨在提供清理缓存到持久性点或深度持久性点。
这些操作用于确保存储操作（可能被保持在dirty缓存行中）被向下迁移到持久内存。</p><p>Persist_CMO 属性用于指示一个组件是否支持持久性的缓存维护。</p><p><a id="表 a10.12">表 A10.12</a> Persist_CMO属性</p><table><thead><tr><th>Persist_CMO</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持持久性CMOs</td></tr><tr><td>False</td><td>Y</td><td>不支持持久性CMOs</td></tr></tbody></table><p>持久CMO可以通过读取或写入通道传输，具体取决于CMO_On_Write和CMO_On_Read属性。</p><p>如果CMO_On_Write和CMO_On_Read都为False，则Persist_CMO必须为False。</p><h5 id=a-ida1081-持久性点pop和深度持久性dpa1081-持久性点pop和深度持久性dpa><a id="a10.8.1 持久性点（pop）和深度持久性（dp）">A10.8.1 持久性点（POP）和深度持久性（DP）</a></h5><p>在具有非易失性内存的系统中，每个内存位置都有一个层级点，在该点上可以依赖数据在断电时保持持久性。这个点被称为持久性点（PoP）。</p><p>有些系统需要对数据的持久性提供多个级别的保证。例如，一些数据可能需要在断电和备用电池故障时得到保留的保证。
为了支持这样的要求，本规范还定义了深度持久性点（PoDP）。</p><p>系统可能在持久性点（PoP）和深度持久性点（PoDP）上有不同的点，或者它们可能是相同的。</p><h5 id=a-ida1082-持久性cmopcmoa1082-持久性cmopcmoa><a id="a10.8.2 持久性cmo（pcmo）">A10.8.2 持久性CMO（PCMO）</a></h5><p>该规范支持以下PCMO事务：</p><p><strong>CleanSharedPersist 清洁共享持久化（CSP）</strong></p><p>当此操作完成时，在指定域中针对该行的所有缓存副本都是清洁的，任何相关的写入都是可观察的，并已到达持久性点（PoP）。</p><p><strong>CleanSharedDeepPersist 清洁共享深度持久化（CSDP）</strong></p><p>当此操作完成时，在指定域中针对该行的所有缓存副本都是清洁的，任何相关的写入都是可观察的，并已到达深度持久性点（PoDP）。</p><p>当一个组件接收到PCMO时，它的处理方式与清洁共享事务相同。如果需要侦听，则使用CleanShared 侦听事务。</p><h5 id=a-ida1083-pcmo传输a1083-pcmo传输a><a id="a10.8.3 pcmo传输">A10.8.3 PCMO传输</a></h5><p>PCMOs在组件下游的传播取决于系统拓扑。PCMO必须在以下情况下向下游传播：</p><ol><li>如果PCMO是可缓存的，并且有一个下游缓存可能已经分配了缓存行，并且该缓存下游有观察者。</li><li>如果下游有一个PoP。</li><li>如果PCMO是CleanSharedDeepPersist，并且组件下游有一个PoDP。</li></ol><p>如果适用(1)，但不适用(2)或(3)，则CleanSharedPersist或CleanSharedDeepPersist可以在发送到下游之前更改为CleanShared。</p><p>如果PCMO被更改为CleanShared，则必须由执行转换的组件发送Persist响应。</p><p>PCMOs的传播可以通过在重置时使用可选的主机输入BROADCASTPERSIST来控制。</p><p><a id="表 a10.13">表 A10.13</a> <strong>BROADCASTPERSIST</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>BROADCASTPERSIST</strong></td><td>1</td><td>0b1</td><td>主机的关联系统输入，用于控制 CleanSharedPersist和CleanSharedDeepPersist CMO的发送。</td></tr></tbody></table><p>当<strong>BROADCASTPERSIST</strong>存在且去断言时，CleanSharedPersist和CleanSharedDeepPersist转换为CleanShared。
这适用于独立的CMO和使用CMO进行写操作。</p><blockquote><p>Note：</br>CleanShared的发行由<strong>BROADCASTSHAREABLE</strong>和<strong>BROADCASTCACHEMAINT</strong>信号控制。</p></blockquote><h5 id=a-ida1084-写通道的pcmosa1084-写通道的pcmosa><a id="a10.8.4 写通道的pcmos">A10.8.4 写通道的PCMOs</a></h5><p>在使用写通道传输缓存维护操作时，支持CleanSharedPersist和CleanSharedDeepPersist。</p><p><strong>AW通道上的PCMO请求</strong></p><p>在写通道上，PCMO请求通过将<strong>AWSNOOP</strong>设置为CMO、WritePtlCMO或WriteFullCMO来发出信号。
请参见 <em><a href="#表 a10.4">表 A10.4</a></em> 了解编码。</p><p><strong>AWCMO</strong>信号随后指示CleanSharedPersist或CleanSharedDeepPersist，请参见表 <em><a href="#表 a10.7">表 A10.7</a></em> 。</p><p>当Persist_CMO为False时，<strong>AWCMO</strong>不得指示CleanSharedPersist或CleanSharedDeepPersist。</p><p><strong>B通道上的PCMO响应</strong></p><p>AW通道上的CleanSharedPersist和CleanSharedDeepPersist事务有两个响应：完成响应和持久化响应。</p><p>拥有单独的响应使系统跟踪资源能够提前释放，以防将数据提交到PoP/PoDP需要很长时间。
完成响应和持久化响应可以以任何顺序发生，并且可以被其他事务的响应分开。</p><p>当CMO_On_Write和Persist_CMO都为True时，完成响应和持久化响应通过两个信号在写响应(B)通道中发出信号。</p><p><a id="表 a10.14">表 A10.14</a> PCMO的响应信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>BCOMP</strong></td><td>1</td><td>0b1</td><td>断言为高表示一个完成响应。</td></tr><tr><td><strong>BPERSIST</strong></td><td>1</td><td>0b0</td><td>断言为高表示第一个持久响应。</td></tr></tbody></table><p>完成响应表示所有缓存都是Clean的，任何相关的写入都是可观察的。它具有以下规则：</p><ul><li><strong>BCOMP</strong> 被断言，<strong>BPERSIST</strong> 被去断言。</li><li><strong>BID</strong> 被驱动为与 <strong>AWID</strong> 相同的值。</li><li>如果支持回环信号，则从 <strong>AWLOOP</strong> 驱动 <strong>BLOOP</strong>。</li><li>如果 <strong>AWIDUNQ</strong> 被断言，则在收到此响应时可以重用该 ID。</li><li><strong>BRESP</strong> 可以取任何对 <strong>PCMO</strong> 请求合法的值。</li><li>完成响应必须遵循正常的响应排序规则。</li><li>如果接口上存在 <strong>BCOMP</strong>，它必须在所有写通道的一个响应传输中被断言。</li></ul><p>持久响应表示数据已经到达 PoP 或 PoDP。它具有以下规则：</p><ul><li><strong>BCOMP</strong> 被去断言，<strong>BPERSIST</strong> 被断言。</li><li><strong>BID</strong> 从 <strong>AWID</strong> 驱动。</li><li><strong>BIDUNQ</strong> 可以取任何值，不要求与 <strong>AWIDUNQ</strong> 具有相同的值。</li><li><strong>BLOOP</strong> 可以取任何值，不要求从 <strong>AWLOOP</strong> 驱动。</li><li><strong>BRESP</strong> 可以取任何对 PCMO 请求合法的值。</li><li>持久响应没有排序要求，可以超越或被其他响应传输超越。</li><li>如果接口上存在 <strong>BPERSIST</strong>，它必须在响应到 CSP 或 CSDP 的一次传输中被断言。
它必须对所有其他响应去断言。</li></ul><p>从机可以选择将两个响应合并为一个传输。适用以下规则：</p><ul><li><strong>BCOMP</strong> 和 <strong>BPERSIST</strong> 都被断言。</li><li><strong>BID</strong> 从 <strong>AWID</strong> 驱动。</li><li>如果支持回环信号，则从 <strong>AWLOOP</strong> 驱动 <strong>BLOOP</strong>。</li><li><strong>BRESP</strong> 可以取任何对 PCMO 请求合法的值。</li><li>合并的响应必须遵循正常的响应排序规则。</li><li>如果 <strong>AWIDUNQ</strong> 被断言，则在收到此响应时可以重用该 ID。</li></ul><p>主机可以计算返回的响应数量，其中 <strong>BPERSIST</strong> 被断言，使其能够确定何时没有未完成的持久操作。</p><p><strong>写通道的PCMO示例</strong></p><p><em><a href="#图 a10.2">图 A10.2</a></em> 显示了写通道上的 CleanSharedPersist 事务示例。</p><p>在此示例中，写入对于最后一级缓存中的所有其他代理都是可观察的，因此当请求在该点被危险化时，可以发送完成响应。
非易失性内存发送一个合并的完成和持久响应，因此缓存必须在向上游传播响应时去断言 <strong>BCOMP</strong>。</p><p><a id="图 a10.2">图 A10.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A10.2_Example_PCMO_transaction.png alt></a></p><h5 id=a-ida1085-读通道上的pcmosa1085-读通道上的pcmosa><a id="a10.8.5 读通道上的pcmos">A10.8.5 读通道上的PCMOs</a></h5><p>如果使用读取通道来传输缓存维护操作，只有CleanSharedPersist事务是支持的。</p><p>CleanSharedDeepPersist只能在写通道上使用。通过将<strong>ARSNOOP</strong>设置为0b1010来发出CleanSharedPersist信号。</p><p>当Persist_CMO为False时，<strong>ARSNOOP</strong>不得指示CleanSharedPersist。</p><p>R通道上有一个单一的响应传输，表示请求已被观察，并且所有缓存行已清理到PoP。</p><h6 id=a-ida109-缓存维护和领域管理扩展a109-缓存维护和领域管理扩展a><a id="a10.9 缓存维护和领域管理扩展">A10.9 缓存维护和领域管理扩展</a></h6><p>使用领域管理扩展（RME）时，缓存维护操作必须适用于与CMO具有相同地址和物理地址空间的所有行，而不考虑其他属性。
<em><a href="#表 a10.15">表 A10.15</a></em> 说明了CMO在支持和不支持RME的情况下必须操作哪些缓存行。
有关更多信息，请参见 <em><a href="#a5.5 内存保护和领域管理扩展">A5.5 内存保护和领域管理扩展</a></em> 以及 <em><a href=#a[4]>A[4]</a></em> 。</p><p><a id="表 a10.15">表 A10.15</a> CMO缓存行操作</p><table><thead><tr><th>Attribute</th><th>RME_Support is False</th><th>RME_Support is True</th></tr></thead><tbody><tr><td>Address</td><td>Same cache line</td><td>Same cache line</td></tr><tr><td>Physical Address Space</td><td>Same, using AxPROT[1]</td><td>Same, using {AxNSE,AxPROT[1]}</td></tr><tr><td>Memory attributes</td><td>Any AxCACHE</td><td>Any AxCACHE</td></tr><tr><td>Shareability Domain</td><td>Same Domain</td><td>Any Domain</td></tr></tbody></table><p>当受到 CleanInvalid 或 CleanShared CMO 的作用时 数据必须传播到一个所有使用与 CMO 相同物理地址空间的代理可观察到的点.</p><h5 id=a-ida1091-cmo到popaa1091-cmo到popaa><a id="a10.9.1 cmo到popa">A10.9.1 CMO到POPA</a></h5><p>RME定义了物理别名点（PoPA），这是一个系统中的点，在该点数据对于来自所有代理的访问都是可观察的，无论物理地址空间如何。</p><p>有一个名为CleanInvalidPoPA的CMO，它帮助将一个物理粒子的所有权从一个安全状态转移到另一个安全状态。</p><p>对CleanInvalidPoPA的响应表明所有缓存副本都被作废，任何dirty缓存副本在PoPA之后被写入。</p><p>CleanInvalidPoPA具有与其他CMO相同的规则，涉及操作的行和事务属性的限制。</p><p>当RME_Support为真时，<strong>AWCMO</strong>信号扩展为3b，以启用CleanInvalidPoPA的信号，编码为：</p><ul><li>0b000：CleanInvalid</li><li>0b001：CleanShared</li><li>0b010：CleanSharedPersist</li><li>0b011：CleanSharedDeepPersist</li><li>0b100：CleanInvalidPoPA</li></ul><p>CleanInvalidPoPA可以独立使用，也可以与写事务结合使用，因此可以与以下<strong>AWSNOOP</strong>值一起使用：<br>= 0b0110：CMO<br>= 0b1010：WritePtlCMO<br>= 0b1011：WriteFullCMO</p><p>CMO_On_Write属性必须为真才能使用CleanInvalidPoPA。</p><p>Write_Plus_CMO属性必须为真才能使用与CleanInvalidPoPA的写入。</p><p>使用内存加密上下文时，可以使用CleanInvalidPoPA。
CMO以确保在加密点上游的所有缓存中清理和失效数据。有关更多信息，请参见 <em><a href=#a5.6内存加密上下文>A5.6内存加密上下文</a></em> 。</p><h5 id=a-ida1092-cmo到popa的传播a1092-cmo到popa的传播a><a id="a10.9.2 cmo到popa的传播">A10.9.2 cmo到popa的传播</a></h5><p>一个可选的输入信号 <strong>BROADCASTCMOPOPA</strong> 可用于在复位时控制 CleanInvalidPoPA 的传播。</p><p><a id="表 a10.16">表 A10.16</a> </strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>BROADCASTCMOPOPA</td><td>1</td><td>0b1</td><td>主机绑定输入，用于控制发放CleanInvalidPoPA CMO。</td></tr></tbody></table><p>当<strong>BROADCASTCMOPOPA</strong>存在并且未断言时，CleanInvalidPoPA被转换为CleanInvalid。
这适用于独立的CMO和使用CMO的写入。</p><blockquote><p>Note：</br>CleanInvalid的发出是由<strong>BROADCASTSHAREABLE</strong>和<strong>BROADCASTCACHEMAINT</strong>信号控制的。</p></blockquote><h5 id=a-ida1010-处理器缓存操作指令a1010-处理器缓存操作指令a><a id="a10.10 处理器缓存操作指令">A10.10 处理器缓存操作指令</a></h5><p>缓存维护协议要求缓存维护操作使用<strong>AxCACHE</strong>和<strong>AxDOMAIN</strong>信号来识别需要进行缓存维护操作的缓存。</p><p>对于具有缓存维护指令且要求在与<strong>AxCACHE</strong>和<strong>AxDOMAIN</strong>值定义的数量不同的缓存上操作的处理器，
事务的可缓存性和共享性必须调整以满足处理器的要求。</p><p>例如，如果执行缓存维护操作的处理器指令必须在具有设备内存属性的位置上操作于系统内的所有缓存，
则主机必须将缓存维护事务发布为普通缓存可用、可共享，因为这是缓存维护操作中最普遍的，且适用于所有所需缓存。</p><h5 id=a-ida10101-软件缓存维护的不可预测行为a10101-软件缓存维护的不可预测行为a><a id="a10.10.1 软件缓存维护的不可预测行为">A10.10.1 软件缓存维护的不可预测行为</a></h5><p>缓存维护可以用于可靠地在一致性主机组和非一致性代理之间传递共享内存数据结构。
这个过程必须遵循特定的顺序，以可靠地使数据结构在需要时可见。</p><p>当使用缓存维护使非一致性代理的写操作对一致性主机组可见时，会出现一段时间，
在这段时间内对数据结构的写入和读取会产生不可预测的结果，并可能导致一致性丧失。</p><p>观察正在被非一致性代理更新的缓存行在开始序列的清除事务和完成序列的失效事务之间的期间是不可预测的。
在此期间，允许观察到由非一致性代理更新的缓存行出现多次状态变化。</p><p><a id="图 a10.3">图 A10.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A10.3_Required_sequence_of_communication_between_coherent_and_non-coherent_domains.png alt></a></p><p>在一致域和非一致代理之间有五个通信阶段，如 <em><a href="#图 a10.3">图 A10.3</a></em> 所示。这五个阶段的顺序是：</p><ol><li>一致域被访问。</br>在此阶段，一致域对适当的内存位置具有完全的读写访问权限。当一致域内所有所需的写入完成时，此阶段结束。</li><li>一致域被清理。</br>在此阶段，对于所有正在进行软件缓存维护的地址位置，需要执行缓存清理操作。
一致域清理强制所有先前的写入对非一致代理可见。当所有必需的写入完成并因此可被非一致代理看到时，此阶段结束。</li><li>非一致代理被访问。</br>在此阶段，非一致代理对定义的内存位置具有读写访问权限。当非一致代理的所有所需写入完成时，此阶段结束。</li><li>一致域被失效。</br>在此阶段，对于所有正在进行软件缓存维护的地址位置，需要执行缓存失效操作。这一一致域失效阶段移除了所有定义位置的缓存副本，
确保一致域的任何后续访问可以观察到非一致代理的写入。当所有所需的失效操作完成时，此阶段结束。</li><li>一致域对定义的内存位置具有完全访问权限。</li></ol><p>下表显示了一致域或非一致代理的访问何时被允许。其余访问可能会产生不可预知的结果，并可能导致一致性丧失。</p><p><a id="表 a10.7">表 A10.7</a> 一致域或非一致代理的访问允许</p><table><thead><tr><th>Phase</th><th>Description</th><th>CoherentDomain-Read</th><th>CoherentDomainWrite</th><th>ExternalAgent-Read</th><th>ExternalAgentWrite</th></tr></thead><tbody><tr><td>1</td><td>Coherent domain access</td><td>Permitted</td><td>Permitted</td><td>–</td><td>–</td></tr><tr><td>2</td><td>Coherent domain clean</td><td>–</td><td>–</td><td>–</td><td>–</td></tr><tr><td>3</td><td>External agent access</td><td>–</td><td>–</td><td>Permitted</td><td>Permitted</td></tr><tr><td>4</td><td>Coherent domain invalidate</td><td>–</td><td>–</td><td>–</td><td>–</td></tr><tr><td>5</td><td>Coherent domain access</td><td>Permitted</td><td>Permitted</td><td>–</td><td>–</td></tr></tbody></table><h3 id=a-ida第11章-额外请求限定a第11章-额外请求限定-a><a id="a第11章 额外请求限定">A第11章 额外请求限定</a></h3><p>本章描述了AXI协议的一些附加请求限定符。
它包含以下部分：</p><ul><li><em><a href="#a11.1 非安全访问标识">A11.1 非安全访问标识NSAID</a></em></li><li><em><a href="#a11.2 页面基础硬件属性">A11.2 页面基础硬件属性PBHA</a></em></li><li><em><a href="#a11.3 子系统标识">A11.3 子系统标识</a></em></li></ul><h4 id=a-ida111-非安全访问标识a111-非安全访问标识a><a id="a11.1 非安全访问标识">A11.1 非安全访问标识</a></h4><p>为了支持受保护数据的存储和处理，可以添加一组信号，以便控制对特定非安全内存位置的访问。
这些信号在事务请求中提供非安全访问标识符（NSAID）。可以检查NSAID以允许或拒绝对内存位置的访问。</p><p>NSAccess_Identifiers属性用于指示组件是否支持这些附加信号。</p><p><a id="表 a11.1">表 A11.1</a>NSAccess_Identifiers属性</p><table><thead><tr><th>属性名</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持NSAID信号。</td></tr><tr><td>False</td><td>Y</td><td>不支持NSAID信号。</td></tr></tbody></table><h5 id=a-ida1111-nsaid信号a1111-nsaid信号a><a id="a11.1.1 NSAID信号">A11.1.1 NSAID信号</a></h5><p>如果NSAccess_Identifiers属性为真，则以下信号将被添加到读写请求通道。</p><p><a id="表 a11.2">表 A11.2</a> AxNSAID信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWNSAID</strong><br><strong>ARNSAID</strong></td><td>4</td><td>0x00</td><td>非安全访问标识符，可以被检查以允许或拒绝访问某个内存位置。</td></tr></tbody></table><p>一个4位NSAID值支持最多16个唯一标识符。对于每个NSAID，定义了一组访问权限，确定内存中的位置如何被允许访问。访问权限可以是：</p><ul><li>无访问</li><li>只读访问</li><li>只写访问</li><li>读/写访问</li></ul><p>用于定义每个NSAID访问权限的机制是实现定义的。然而，这种机制通常是通过某种形式的内存保护单元（MPU）实现的。
以下规则和建议适用于NSAID值：</p><ul><li>对安全、根或领域地址空间的请求必须使用NSAID值为零。</li><li>对非安全物理地址空间的请求可以使用任何NSAID值。</li><li>允许具有不同NSAID值的事务访问重叠的内存位置。</li><li>允许具有不同NSAID值的事务对给定内存位置具有任何组合的访问权限。</li><li>建议主机在访问未保护的数据时使用默认的NSAID值零，或者在他们没有分配的NSAID值时使用。</li><li>如果主机需要使用单一NSAID值，则允许NSAID信号绑定到固定值。</li></ul><h5 id=a-ida1112-缓存和非安全访问标识a1112-缓存和非安全访问标识a><a id="a11.1.2 缓存和非安全访问标识">A11.1.2 缓存和非安全访问标识</a></h5><p>在权限检查的上游进行缓存和系统一致性时，通过不同 NSAID 值之间传递数据的访问必须接受权限检查。
与 NSAID 使用和一致性相关的规则如下：</p><ul><li>当代理缓存使用特定 NSAID 值获取的数据行时，必须确保对主存储器的任何后续写入或对 Snooping 的任何响应使用相同的 NSAID 值。
该规则确保主机不能将数据缓存行从一个保护区域移动到另一个。</li><li>对于具有给定 NSAID 值的读请求，如果使用 Snooping 来获取数据：<ul><li>如果 Snooping 响应的 NSAID 值与读请求匹配，则可以直接提供数据。</li><li>如果 Snooping 响应的 NSAID 值与读请求不匹配，则必须首先使用通过 Snooping 响应获得的 NSAID 值将缓存行写入内存，
然后使用原始请求的 NSAID 值从内存中读取。写入和后续读取仅需达到权限检查的发生点。</li></ul></li><li>如果使用内存保护，则不得使用使缓存副本失效的 Snooping 事务，例如 MakeInvalid。
所有这些 Snooping 事务必须被替换为还会将缓存行清理到主存储器的事务，例如 CleanInvalid。</li><li>作为 Snooping 结果发生的对主存储器的任何互连生成写入必须使用从 Snooping 响应中获得的 NSAID 值。</li><li>如果单个主机能够发出具有多个 NSAID 值的事务，则必须确保对缓存副本的内部访问使用最初获取缓存行所使用的 NSAID 值：</li><li>如果访问有相同地址但不同 NSAID 值的缓存行命中，则必须在使用适当的 NSAID 值重新获取缓存行之前清理并使缓存行失效。此过程确保执行保护检查。</li><li>如果可以保证主机永远不会以不同的 NSAID 值访问相同的缓存行，则不需要清理和失效操作。这一保证可以通过设计实现或通过使用适当的缓存维护操作来确保。</li><li>在更改 NSAID 值的访问权限时，必须执行适当的缓存维护。
主机在没有写入权限的情况下写入缓存行是允许的。使用相同 NSAID 值将更新的缓存行传递给其他主机也是允许的。
然而，不允许该更新传播到主存储器或使用不同 NSAID 值的访问。</li></ul><h4 id=a-ida112-页面基础硬件属性a112-页面基础硬件属性a><a id="a11.2 页面基础硬件属性">A11.2 页面基础硬件属性</a></h4><p>页面基础硬件属性（PBHA）是与转换表条目相关的4位描述符，可注释到事务请求中。
此规范描述了它们如何传输，但它们的使用由实现定义。
以下信号用于读取和写入请求通道以传输PBHA值。</p><p><a id="表 a11.3">表 A11.3</a> <strong>AxPBHA</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWPBHA</strong><br><strong>ARPBHA</strong></td><td>4</td><td>−</td><td>一个与转换表条目相关的4b用户定义描述符，可以注释到事务请求上。</td></tr></tbody></table><p>PBHA_Support属性用于指示接口是否支持PBHA。</p><p><a id="表 a11.4">表 A11.4</a> PBHA_Support属性</p><table><thead><tr><th>PBHA_Support</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持PBHA。</td></tr><tr><td>False</td><td>Y</td><td>不支持PBHA。</td></tr></tbody></table><h5 id=a-ida1121-pbha值a1121-pbha值a><a id="a11.2.1 pbha值">A11.2.1 PBHA值</a></h5><p>PBHA值可以在地址转换过程中添加到请求中，并在系统中传播，如果下游组件支持它们。</p><p>在MMU中，对同一Page和物理地址空间的所有事务可能具有相同的值，但PBHA值的准确性在传递过程中可能会降低。
PBHA值可能变得不准确的情况包括：</p><ul><li>当一个互连组合来自不同源的事务时，有些可能附有PBHA值，而其他的可能取固定值。</li><li>在下游缓存中，PBHA值在所有情况下可能不会与数据一起缓存。</li><li>如果转换表中的PBHA值被更改，则正在进行的事务或缓存数据上的值可能变得不一致。可以使用适当的TLB失效或缓存维护操作来实现一致性。</li></ul><p>该列表并不详尽，设计师应记录PBHA在其组件内可能变得不准确的情况。
希望使用PBHA的系统集成商必须考虑源和目标之间的每个组件，以确定目标的要求是否可以满足。</p><h4 id=a-ida113-子系统标识a113-子系统标识a><a id="a11.3 子系统标识">A11.3 子系统标识</a></h4><p>子系统标识符（ID）是一个可以添加到事务请求中的字段，用于指示它们源自哪个子系统。
子系统ID可以用来限定事务地址，并在共享内存或设备的系统部分之间提供隔离。</p><p>用于传输子系统ID的信号显示在 <em><a href="#表 a11.5">表 A11.5</a></em> 中。</p><p><a id="表 a11.5">表 A11.5</a> <strong>AxSUBSYSID</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWSUBSYSID</strong><strong>ARSUBSYSID</strong></td><td>SUBSYSID_WIDTH</td><td>−</td><td>子系统标识符，指示请求源自哪个子系统。</td></tr></tbody></table><p>SUBSYSID_WIDTH属性用于定义子系统ID信号的宽度和存在性。如果该属性为零，则信号不为存在。</p><p><a id="表 a11.6">表 A11.6</a> SUBSYSID_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>SUBSYSID_WIDTH</td><td>0&mldr;8</td><td>0</td><td><strong>AxSUBSYSID</strong>信号的位宽。</td></tr></tbody></table><h5 id=a-ida1131-子系统id使用a1131-子系统id使用a><a id="a11.3.1 子系统id使用">A11.3.1 子系统id使用</a></h5><p>该规范未定义子系统ID的使用情况。
示例实现包括：</p><ul><li>一个或多个主机使用单个子系统ID，具有对共享内存或外设的共同访问权限。</li><li>一个互连，结合来自不同子系统主机的请求。在这种情况下，互连主机接口因此对不同请求使用不同的子系统ID。</li><li>将子系统ID用作防火墙或内存保护单元（MPU）中的查找，以出于安全或保护原因隔离子系统。</li><li>要求在一致域内的所有主机使用相同的子系统ID，以便在侦听过滤中使用。</li><li>使用子系统ID进行性能分析或监控。</li><li>一个通过某些接口而不是其他接口传播子系统ID的互连。</li></ul><h3 id=a-ida第12章-其他写事务a第12章-其他写事务a><a id="a第12章 其他写事务">A第12章 其他写事务</a></h3><p>本章描述了AXI协议中支持的其他写入事务。<br>它包含以下部分：</p><ul><li><em><a href="#a12.1 写0事务">A12.1 写0事务</a></em></li><li><em><a href="#a12.2 写延迟事务">A12.2 写延迟事务</a></em></li></ul><h4 id=a-ida121-写0事务a121-写0事务a><a id="a12.1 写0事务">A12.1 写0事务</a></h4><p>许多系统中的写操作，特别是来自中央处理器的操作，都是将数据设置为零。
例如，在初始化或分配内存时。这些零值写操作消耗了写数据带宽和互连功率，而采用无数据请求可以节省这些资源。</p><p>WriteZero事务用于将零值写入缓存行大小的数据位置。该事务包括写请求和写响应，但没有相关的写数据传输。
它在功能上等同于对同一位置进行常规写入，其中所有数据行都填充了零值。</p><p>WriteZero_Transaction属性用于指示一个接口是否支持WriteZero事务。</p><p><a id="表 a12.1">表 A12.1</a> WriteZero_Transaction属性</p><table><thead><tr><th>WriteZero_Transaction</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持写0事务</td></tr><tr><td>False</td><td>Y</td><td>不支持写0事务</td></tr></tbody></table><p>WriteZero事务的规则如下：</p><ul><li><p>WriteZero请求表示由地址、大小和长度属性指示的位置的数据必须设置为零。</p></li><li><p>WriteZero事务由AW通道上的请求和B通道上的单个响应组成。</p></li><li><p>WriteZero事务为缓存行大小并且是常规的，参见 <em><a href="#a4.1.8 常规事务">A4.1.8 常规事务</a></em></p></li><li><p><strong>AWSNOOP</strong>必须为0b0111或0b00111。</p></li><li><p><strong>AWLOCK</strong>必须为0b0，不能是专有访问。</p></li><li><p><strong>AWTAGOP</strong>必须为无效。</p></li><li><p><strong>AWID</strong>必须是唯一的，这意味着：</p><ul><li>仅当没有使用相同AWID值的未完成写事务时，才能发出WriteZero事务。</li><li>主机不得在写通道上发出与未完成WriteZero事务相同的AWID的请求。</li><li>如果存在，<strong>AWIDUNQ</strong>必须在WriteZero事务中被断言。</li></ul></li><li><p><strong>AWDOMAIN</strong>可以取任何值。如果域是可共享的，则WriteZero作为WriteUniqueFull，数据为零。</p></li><li><p>发出WriteZero请求的主机不能连接到不支持WriteZero的从机。</p></li></ul><h4 id=a-ida122-写延迟事务a122-写延迟事务a><a id="a12.2 写延迟事务">A12.2 写延迟事务</a></h4><p>在企业系统中，常常使用加速器，这些加速器通过芯片间连接使用64字节原子存储操作进行访问。
这些存储操作是在加速器内部的共享队列中执行的。
在某些情况下，由于队列已满，存储操作可能不会被接受，但如果稍后重试，可能会被接受。
这种类型的事务称为WriteDeferrable。</p><p>PCIe Gen5支持通过可延迟写入（Deferrable Memory Write，简称DMWr）事务进行可延迟写入。
这需要一个写入响应，因此DMWr是一个非发布写入。
预计AXI中的WriteDeferrable事务会转换为PCIe DMWr事务。</p><h5 id=a-ida1221-写延迟事务支持a1221-写延迟事务支持a><a id="a12.2.1 写延迟事务支持">A12.2.1 写延迟事务支持</a></h5><p>WriteDeferrable_Transaction属性用于指示接口是否支持WriteDeferrable事务。</p><p><a id="表 a12.2">表 A12.2</a> WriteDeferrable_Transaction属性</p><table><thead><tr><th>WriteDeferrable_Transaction</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持写延迟事务。</td></tr><tr><td>False</td><td>Y</td><td>不支持写延迟事务。</td></tr></tbody></table><p>发布WriteDeferrable请求的主机无法与不支持WriteDeferrable的从机连接。</p><h5 id=a-ida1222-写延迟信号a1222-写延迟信号a><a id="a12.2.2 写延迟信号">A12.2.2 写延迟信号</a></h5><p>当WriteDeferrable_Transaction属性为真时，<strong>AWSNOOP</strong>和<strong>BRESP</strong>必须足够宽以容纳额外的编码：</p><ul><li>AWSNOOP_WIDTH必须为5</li><li>BRESP_WIDTH必须为3</li></ul><p>一个WriteDeferrable事务由一个请求、64字节的写入数据和一个写入响应组成。</p><p>WriteDeferrable事务的规则是：</p><ul><li><p><strong>AWSNOOP</strong>为0b10000。</p></li><li><p><strong>AWDOMAIN</strong>为0b11（系统可共享）。</p></li><li><p><strong>AWCACHE</strong>为设备或正常非缓存。</p></li><li><p>长度和大小的合法组合为：</p><ul><li>1 x 64字节</li><li>2 x 32字节</li><li>4 x 16字节</li><li>8 x 8字节</li><li>16 x 4字节</li></ul></li><li><p><strong>WSTRB</strong>的所有位必须在64字节容器内设置。</p></li><li><p><strong>AWADDR</strong>对齐到64字节。</p></li><li><p><strong>AWBURST</strong>为INCR。</p></li><li><p><strong>AWLOCK</strong>为非断言，不是独占访问。</p></li><li><p><strong>AWATOP</strong>为非原子事务。</p></li><li><p><strong>AWTAGOP</strong>为无效。</p></li><li><p>对于所有事务，ID在传输中是唯一的，这意味着：</p><ul><li>仅当写通道上没有具有相同ID值的未完成事务时，才能发出WriteDeferrable事务。</li><li>主机不得在与待处理WriteDeferrable事务具有相同ID的写通道上发出请求。</li><li>如果存在，<strong>AWIDUNQ</strong>必须在WriteDeferrable事务中断言。</li></ul></li><li><p>WriteDeferrable事务必须被视为64字节原子，因此：</p><ul><li>它仅针对具有64字节或更大单副本原子性大小的位置。</li><li>请求不得与其他事务拆分或合并。</li></ul></li></ul><h5 id=a-ida1223-写延迟事务事务响应a1223-写延迟事务事务响应a><a id="a12.2.3 写延迟事务事务响应">A12.2.3 写延迟事务事务响应</a></h5><p>下表显示了对WriteDeferrable请求的响应含义。</p><p><a id="表 a12.3">表 A12.3</a></p><table><thead><tr><th><strong>BRESP[2:0]</strong></th><th>响应</th><th>描述</th></tr></thead><tbody><tr><td>0b00</td><td>OKAY</td><td>该写操作被一个支持WriteDeferrable事务的从属机构接受并成功完成。</td></tr><tr><td>0b001</td><td>EXOKAY</td><td>在WriteDeferrable事务中不允许的响应。</td></tr><tr><td>0b010</td><td>SLVERR</td><td>WriteDeferrable事务已经到达一个结束点但没有成功。</td></tr><tr><td>0b011</td><td>DECERR</td><td>尚未达到可以写入数据的阶段。</td></tr><tr><td>0b100</td><td>DEFER</td><td>写入未成功，因为此时无法进行服务，但如果稍后重新发送可能会成功。<br>位置未更新。此响应仅允许用于WriteDeferrable事务。</td></tr><tr><td>0b101</td><td>TRANSFAULT</td><td>写入被终止是因为转换错误，这可能通过PRI请求来解决。</td></tr><tr><td>0b110</td><td>RESERVED</td><td>-</td></tr><tr><td>0b111</td><td>UNSUPPORTED</td><td>写入未成功，因为目标不支持该事务类型。<br>位置未更新。此响应仅允许用于WriteDeferrable事务。</td></tr></tbody></table><p>如果一个互连检测到一个WriteDeferrable正在针对一个不支持WriteDeferrable事务的从机，它必须不传播该请求。</p><p>在这种情况下，预期会发送一个UNSUPPORTED响应，但也允许SLVERR或DECERR。</p><p>一个能够识别WriteDeferrable但无法处理它的从机，其WriteDeferrable_Transaction属性为True，但预期会以UNSUPPORTED响应。</p><h3 id=a-ida第13章-系统监控调试和用户扩展a第13章-系统监控调试和用户扩展a><a id="a第13章 系统监控、调试和用户扩展">A第13章 系统监控、调试、和用户扩展</a></h3><p>本章描述了用于系统监控和调试的AXI特性，还描述了如何向每个通道添加用户定义的扩展。
包含以下章节：</p><ul><li><em><a href="#a13.1 内存系统资源分区和监控">A13.1 内存系统资源分区和监控（MPAM）</a></em></li><li><em><a href="#a13.2 内存标签扩展">A13.2 内存标签扩展</a></em></li><li><em><a href="#a13.3 跟踪信号">A13.3 跟踪信号</a></em></li><li><em><a href="#a13.4 用户环回信号">A13.4 用户环回信号</a></em></li><li><em><a href="#a13.5 用户定义信号">A13.5 用户定义信号</a></em></li></ul><h4 id=a-ida131-内存系统资源分区a131-内存系统资源分区a><a id="a13.1 内存系统资源分区">A13.1 内存系统资源分区</a></h4><p>内存系统资源分区和监控（MPAM）是一种用于对物理和虚拟机器的内存系统资源进行分区和监控的技术。
完整的MPAM架构在Armv8.4扩展中进行了描述 <em><a href=#[6]>[6]</a></em> 。</p><p>每个MPAM启用的主机在其请求中添加MPAM信息。MPAM信息通过系统传播到内存组件，在那里可以用来影响资源分配决策。
基于MPAM信息监控内存使用情况还可以实现性能调优和机器之间的精准占用。</p><h5 id=a-ida1311-mpam信号a1311-mpam信号a><a id="a13.1.1 mpam信号">A13.1.1 MPAM信号</a></h5><p>MPAM_Support属性如 <em><a href="#表 a13.1">表 A13.1</a></em> 所示，用于指示接口是否支持MPAM。</p><p><a id="表 a13.1">表 A13.1</a> MPAM_Support属性</p><table><thead><tr><th>MPAM_Support</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>MPAM_12_1</td><td></td><td>接口已启用MPAM，并包括AW和AR频道上的MPAM信号。PARTID的宽度为12，PMG为1</td></tr><tr><td>MPAM_9_1</td><td></td><td>接口已启用MPAM，并包括AW和AR频道上的MPAM信号。PARTID的宽度为9，PMG为1</td></tr><tr><td>False</td><td>Y</td><td>MPAM不受支持，该接口未启用MPAM，并且接口上没有MPAM信号。</td></tr></tbody></table><p><a id="表 a13.2">表 A13.2</a> <strong>AxMPAM</strong>信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWMPAM</strong><br><strong>ARMPAM</strong></td><td>MPAM_WIDTH</td><td>−</td><td>内存系统资源分区和监控（MPAM）请求信息</td></tr></tbody></table><p>MPAM信息包含三个字段。位与字段的映射取决于接口是否支持RME。有关RME的更多信息，请参见 <em><a href=#a5.5内存保护和领域管理扩展>A5.5内存保护和领域管理扩展</a></em></p><p>MPAM_WIDTH的值由MPAM_Support和RME_Support属性确定。当MPAM_Support为False时，MPAM_WIDTH必须为零。</p><h5 id=a-ida1312-mpam字段a1312-mpam字段a><a id="a13.1.2 mpam字段">A13.1.2 MPAM字段</a></h5><p>MPAM字段在<strong>AxMPAM</strong>信号中编码，具体取决于MPAM_Support和RME_Support属性。</p><p>当MPAM_Support为MPAM_9_1且RME_Support为False时，MPAM_WIDTH必须为11，映射如 <em><a href="#表 a13.3">表 A13.3</a></em> 所示。</p><p><a id="表 a13.3">表 A13.3</a> 当RME_Support为False情况下的MPAM_9_1</p><table><thead><tr><th>字段</th><th>描述</th><th>位宽</th><th>映射</th></tr></thead><tbody><tr><td>MPAM_NS</td><td>安全标识</td><td>1</td><td><strong>AxMPAM[0]</strong></td></tr><tr><td>PARTID</td><td>分区标识</td><td>9</td><td><strong>AxMPAM[9:1]</strong></td></tr><tr><td>PMG</td><td>性能监控组</td><td>1</td><td><strong>AxMPAM[10]</strong></td></tr></tbody></table><p>当MPAM_Support为MPAM_9_1且RME_Support为真时，MPAM_WIDTH必须为12，并且映射如 <em><a href="#表 a13.4">表 A13.4</a></em> 所示。</p><p><a id="表 a13.4">表 A13.4</a> 当RME_Support为True情况下的MPAM_9_1</p><table><thead><tr><th>字段</th><th>描述</th><th>位宽</th><th>映射</th></tr></thead><tbody><tr><td>MPAM_SP</td><td>物理地址空间标识</td><td>2</td><td><strong>AxMPAM[1:0]</strong></td></tr><tr><td>PARTID</td><td>分区标识</td><td>9</td><td><strong>AxMPAM[10:2]</strong></td></tr><tr><td>PMG</td><td>性能监控组</td><td>1</td><td><strong>AxMPAM[11]</strong></td></tr></tbody></table><p>当MPAM_Support为MPAM_12_1且RME_Support为False时，MPAM_WIDTH必须为14，映射如 <em><a href="#表 a13.5">表 A13.5</a></em> 所示。</p><p><a id="表 a13.5">表 A13.5</a> 当RME_Support为False情况下的MPAM_12_1</p><table><thead><tr><th>字段</th><th>描述</th><th>位宽</th><th>映射</th></tr></thead><tbody><tr><td>MPAM_NS</td><td>安全标识</td><td>1</td><td><strong>AxMPAM[0]</strong></td></tr><tr><td>PARTID</td><td>分区标识</td><td>12</td><td><strong>AxMPAM[12:1]</strong></td></tr><tr><td>PMG</td><td>性能监控组</td><td>1</td><td><strong>AxMPAM[13]</strong></td></tr></tbody></table><p>当MPAM_Support为MPAM_12_1且RME_Support为真时，MPAM_WIDTH必须为14，并且映射如 <em><a href="#表 a13.6">表 A13.6</a></em> 所示。</p><p><a id="表 a13.6">表 A13.6</a> 当RME_Support为True情况下的MPAM_9_1</p><table><thead><tr><th>字段</th><th>描述</th><th>位宽</th><th>映射</th></tr></thead><tbody><tr><td>MPAM_SP</td><td>物理地址空间标识</td><td>2</td><td><strong>AxMPAM[1:0]</strong></td></tr><tr><td>PARTID</td><td>分区标识</td><td>12</td><td><strong>AxMPAM[12:2]</strong></td></tr><tr><td>PMG</td><td>性能监控组</td><td>1</td><td><strong>AxMPAM[13]</strong></td></tr></tbody></table><h5 id=a-ida1313-mpam-组件互联a1313-mpam-组件互联a><a id="a13.1.3 mpam 组件互联">A13.1.3 MPAM 组件互联</a></h5><p>MPAM技术的实施对主机、互连和从机产生影响。
如果在一个支持MPAM的系统中包含主机，但不支持MPAM信号，则系统必须添加MPAM信息。
默认情况下为实施定义，但其中一个选项是将请求的物理地址空间（AxNSE，AxPROT[1]）复制到最低有效的MPAM位，并对高位进行零扩展。</p><p><strong>主机</strong></p><p>支持MPAM的主机组件在对应的<strong>AxVALID</strong>被断言时必须驱动MPAM信号。
所有事务类型使用的值为实施定义。预计但不要求主机在读请求和写请求中使用相同的值集。
主机可能不会使用接口上可以发出信号的所有PARTID或PMG值。</p><p><strong>互连</strong></p><p>MPAM标识符具有全局范围。互连组件没有要求使MPAM标识符唯一。当互连主机接口连接到支持MPAM的从机时，可以使用传播的值或实施定义的值。</p><p><strong>从机</strong></p><p>支持MPAM的从机可以使用MPAM信息进行内存分区和监控。MPAM信号在对应的<strong>AxVALID</strong>断言时被采样。</p><h4 id=a-ida132-内存标签扩展a132-内存标签扩展mtea><a id="a13.2 内存标签扩展">A13.2 内存标签扩展MTE</a></h4><p>内存标记扩展（MTE）提供了一种机制，用于检测内存安全违规。</p><p>当为特定用途分配内存区域时，会为其分配一个分配标记值。
当随后访问内存时，会提供一个物理标记值，该值对应于访问的物理地址。
如果物理标记与分配标记不匹配，就会生成警告。</p><p>分配标记存储在内存系统中，可以像数据一样缓存。每个标记为4位，并与16字节对齐的地址位置相关联。支持以下操作：</p><ul><li>使用写事务更新分配标记值，无论是否更新相关的数据值。</li><li>读取与分配标记相关的数据。请求者可以对物理标记与分配标记进行检查。</li><li>向内存写入物理标记，以便与分配标记进行比较。结果在事务响应中指示。</li></ul><p>当系统支持内存标记时，并不要求每个事务都使用内存标记。系统中的每个组件也不必支持内存标记。</p><p>内存标记扩展在Arm A架构v8.5及更高版本上得到支持，并在Arm® A架构参考手册中进行了描述 <em><a href=#[3]>[3]</a></em> 。</p><h5 id=a-ida1321-mte支持a1321-mte支持a><a id="a13.2.1 mte支持">A13.2.1 MTE支持</a></h5><p>MTE_Support属性用于指示接口对MTE的支持级别。
可以根据不同的用例使用不同的支持级别。</p><p><a id="表 a13.7">表 A13.7</a> MTE_Support属性</p><table><thead><tr><th>MTE_Support</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>Standard</td><td></td><td>内存标记在接口上得到了全面支持，所有MTE信号均可用。</td></tr><tr><td>Simplified</td><td></td><td>内存标记被支持，除了MTE匹配操作。<br>不允许部分标签写入，因此当<strong>AWTAGOP</strong>更新时，事务容器内的所有对应于标签的<strong>WTAGUPDATE</strong>位必须被设定。<br>BTAGMATCH不存在。 BCOMP不是必需的。</td></tr><tr><td>Basic</td><td></td><td>内存标签在接口上以基本级别得到支持。允许有限的一组标签操作。<br>BTAGMATCH不存在。BCOMP不是必需的。</td></tr><tr><td>False</td><td>Y</td><td>内存标记在接口上不受支持，并且没有MTE信号存在。</td></tr></tbody></table><p>请注意在数据宽度小于32位的接口上MTE_Support必须为False。</p><p>主机与从机之间的兼容性根据MTE_Support属性的值显示在 <em><a href="#表 a13.8">表 A13.8</a></em> 。</p><p><a id="表 a13.8">表 A13.8</a> MTE_Support互联</p><table><thead><tr><th>MTE_Support</th><th>从机：False</th><th>从机：Basic</th><th>从机：Simplified</th><th>从机：Standard</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>主机：Basic</td><td>协议兼容。<br>从机忽略<strong>AxTAGOP</strong>，因此写标签丢失，读标签保持静态。</td><td>兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>主机：Simplified</td><td>协议兼容。<br>从机忽略<strong>AxTAGOP</strong>，因此写标签丢失，读标签保持静态。</td><td>不兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>主机：Standard</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>兼容</td></tr></tbody></table><h5 id=a-ida1322-mte信号a1322-mte信号a><a id="a13.2.2 mte信号">A13.2.2 MTE信号</a></h5><p>支持MTE所需的信号如 <em><a href="#表 a13.9">表 A13.9</a></em> 所示。</p><p><a id="表 a13.9">表 A13.9</a> MTE信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWTAGOP</strong></td><td>2</td><td>0b00</td><td>指示MTE标签是否与写入事务相关联.</td></tr><tr><td><strong>ARTAGOP</strong></td><td>2</td><td>0b00</td><td>指示MTE标签是否与读取事务相关联.</td></tr><tr><td><strong>WTAG</strong><br><strong>RTAG</strong></td><td>ceil（DATA_WIDTH/128）*4</td><td>-</td><td>与数据相关的内存标签。<br>每128位数据有一个4位标签，最少为4位。<br>与相关数据具有相同的有效性规则。建议将无效标签置为零。</td></tr><tr><td><strong>WTAGUPDATE</strong></td><td>ceil（DATA_WIDTH/128）</td><td>-</td><td>指示在<strong>AWTAGOP</strong>更新时哪些标签必须写入内存，每4位标签有1位控制位。</td></tr><tr><td><strong>BTAGMATCH</strong></td><td>2</td><td>-</td><td>指示写入事务中标签比较的结果。</td></tr><tr><td><strong>BCOMP</strong></td><td>1</td><td>0b1</td><td>断言HIGH以指示完成响应。</td></tr></tbody></table><h5 id=a-ida1323-缓存标签a1323-缓存标签a><a id="a13.2.3 缓存标签">A13.2.3 缓存标签</a></h5><p>缓存的分配标签必须保持硬件一致性。一致性机制与数据的一致性机制相同。
适用的标签缓存状态包括：Invalid、Clean和Dirty。状态为Clean或Dirty的行是有效的。</p><p>数据缓存状态和标签缓存状态组合的约束条件：</p><ul><li>只有在数据有效时，标签才能有效。</li><li>当数据有效时，标签可以无效。</li><li>当缓存行被驱逐且标签为Dirty时，允许将驱逐的Clean数据视为Dirty。</li><li>当Dirty标签从缓存中驱逐时，必须将其写回内存或以Dirty状态传递给另一个缓存。</li><li>当Clean标签从缓存驱逐时，可以将其发送到其他缓存或静默丢弃。</li><li>命中具有Valid标签的行的CMO适用于数据和标签。</li><li>当MakeInvalid或ROMI事务命中具有Dirty标签的行时，标签必须写回内存。</li></ul><h5 id=a-ida1324-传输标签a1324-传输标签a><a id="a13.2.4 传输标签">A13.2.4 传输标签</a></h5><p>标签值通过<strong>WTAG</strong>信号进行传输，当<strong>AWTAGOP</strong>不是无效时。</p><p>标签值通过<strong>RTAG</strong>信号进行传输，当<strong>ARTAGOP</strong>不是无效时。</p><p>在传输标签时，除了基于事务类型的其他约束外，适用以下规则：</p><ul><li>事务必须是缓存行大小或更小，并且不能跨越缓存行边界。</li><li><strong>AxBURST</strong>必须是INCR或WRAP，而不能是FIXED。</li><li>事务必须指向正常的写回内存，这意味着：<ul><li>CACHE_Present属性必须为真。</li><li>AxCACHE[3:2]不是0b00。</li><li>AxCACHE[1:0]是0b11。</li></ul></li><li>ID值必须在传输中唯一，这意味着：<ul><li>只有当没有使用相同<strong>ARID</strong>值的未完成读事务时，才能发出带有标签的读操作Transfer或Fetch。</li><li>主机不得在读取通道上发出与未完成的带标签Transfer或Fetch的读操作相同<strong>ARID</strong>的请求。</li><li>如果存在，读操作Transfer或Fetch必须断言<strong>ARIDUNQ</strong>。</li><li>只有当没有使用相同<strong>AWID</strong>值的未完成写事务时，才能发出带有标签的写操作Transfer、Update或Match。</li><li>主机不得在写入通道上发出与未完成的带标签Transfer、Update或Match的写操作相同<strong>AWID</strong>的请求。</li><li>如果存在，写操作Transfer、Update或Match必须断言<strong>AWIDUNQ</strong>。</li></ul></li><li>内存标签通过<strong>RTAG</strong>或<strong>WTAG</strong>进行传输，其中TAG[4n-1:4(n-1)]对应于DATA[128n-1:128(n-1)]。</li><li>对于宽度超过128位的数据，标签信号承载多个标签。标签根据所传输的数据驱动，最低有效的标签位用于传输最低有效的128位数据的标签。</li><li>对于使用读取数据分块的读事务，只有与有效块strobes相对应的标签需要有效。</li><li>对于多个传输地址相同标签的写事务，<strong>WTAG</strong>和<strong>WTAGUPDATE</strong>值必须对每个事务访问的4位标签保持一致。</li></ul><h5 id=a-ida1325-使用标签读a1325-使用标签读a><a id="a13.2.5 使用标签读">A13.2.5 使用标签读</a></h5><p>读取操作可以请求返回分配标签和数据，这由<strong>ARTAGOP</strong>的值来决定，如 <em><a href="#表 a13.10">表 A13.10</a></em> 所示。</p><p><a id="表 a13.10">表 A13.10</a> <strong>ARTAGOP</strong>编码</p><table><thead><tr><th><strong>ARTAGOP</strong></th><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>Invalid</td><td>标签不需要与数据一起返回。对此请求的响应中，<strong>RTAG</strong>无效且必须为零。</td></tr><tr><td>0b01</td><td>Transfer</td><td>每次读取数据的传输必须具有有效的标签值。<br>对于每一个访问的16字节粒度都必须发送标签，即使地址未对齐至16字节。</td></tr><tr><td>0b10</td><td>RESERVED</td><td>-</td></tr><tr><td>0b11</td><td>Fetch</td><td>只需提取标签。不要求数据有效且不得被主机使用。<br>使用提取的事务必须是缓存行大小和常规的，对于每个访问的16字节粒度必须发送标签。</td></tr></tbody></table><p>这里对可以与MTE标签传输一起使用的读取通道操作码有一些限制,
<em><a href="#表 a13.11">表 A13.11</a></em> 显示了每个MTE_Support配置的合法操作码和标签操作的组合.
无效的标签操作编码对所有操作码都是合法的.</p><p>星号（*）表示操作码的所有变体。</p><p><a id="表 a13.11">表 A13.11</a> 读传输中合法的标签操作</p><table><thead><tr><th>操作码</th><th>Basic-Transfer</th><th>Basic-Fetch</th><th>Simplified-Transfer</th><th>Simplified-Fetch</th><th>Standard-Transfer</th><th>Standard-Fetch</th></tr></thead><tbody><tr><td>ReadNoSnoop</td><td>Y</td><td>-</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>ReadOnce</td><td>Y</td><td>-</td><td>Y</td><td>-</td><td>Y</td><td>-</td></tr><tr><td>ReadShared</td><td>Y</td><td>-</td><td>Y</td><td>-</td><td>Y</td><td>-</td></tr><tr><td>ReadClean</td><td>Y</td><td>-</td><td>Y</td><td>-</td><td>Y</td><td>-</td></tr><tr><td>ReadOnceCleanInvalid</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>ReadOnceMakeInvalid</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>CleanInvalid*</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>CleanShared*</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>MakeInvalid</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>DVM Complete</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h5 id=a-ida1326-使用标签写a1326-使用标签写a><a id="a13.2.6 使用标签写">A13.2.6 使用标签写</a></h5><p>写入可以请求分配标签与数据一起写入，或者请求写入包括一个与内存中已经存储的分配标签进行比较的物理标签。
信号<strong>AWTAGOP</strong>指示要执行的标签操作。</p><p><a id="表 a13.12">表 A13.12</a> <strong>AWTAGOP</strong>编码</p><table><thead><tr><th><strong>AWTAGOP</strong></th><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>Invalid</td><td>标签无效；无需进行标签更新或检查。<br><strong>WTAGUPDATE</strong>必须被取消。<br><strong>WTAG</strong>必须为零。</td></tr><tr><td>0b01</td><td>Transfer</td><td>标签是Clean的。<br>不需要执行标签检查。<br>写入的完成者可以在分配数据时缓存标签。 <strong>WTAGUPDATE</strong>必须被去断言。<strong>WTAG</strong>位在事务容器中的每个字节都必须有效。</td></tr><tr><td>0b10</td><td>Update</td><td>标签值已更新并处于Dirty状态；内存中的标签必须根据<strong>WTAGUPDATE</strong>进行更新。 <strong>WTAGUPDATE</strong>可以有任意数量的位被断言，包括没有。<br>在传输中仅部分寻址的标签<strong>WTAGUPDATE</strong>必须去断言。<br>Write<em>Full</em>操作码必须有所有相关的<strong>WTAGUPDATE</strong>位被断言。<br>对于每一个被断言的<strong>WTAGUPDATE</strong>位，<strong>WTAG</strong>必须是有效的。</td></tr><tr><td>0b11</td><td>Match</td><td>在写入过程中必须检查标签与从内存中获得的分配标签值是否匹配。必须对所有写入数据选通被激活的标签执行匹配操作。<br>即使匹配失败，也需要用数据更新内存。<br>必须去断言<strong>WTAGUPDATE</strong>信号。<br><strong>WTAG</strong>位对于由<strong>WSTRB</strong>启用的字节通道必须有效。<br>对于具有超过4位标签的接口，只对对应于活动字节通道的标签执行匹配操作。</td></tr></tbody></table><p>对于带有标签更新的写入，<strong>WTAGUPDATE</strong> 指示必须写入哪些标签。它有以下规则：</p><ul><li><strong>WTAGUPDATE[n]</strong> 对应于 <strong>WTAG[4n+3:4n]</strong>。</li><li>如果一个位被设置，则必须将相应的标签写入内存。</li><li>如果一个位被清除，则相应的标签无效。</li><li>事务容器外的 <strong>WTAGUPDATE</strong> 位必须被清除。</li><li>对于除更新之外的操作 <strong>WTAGUPDATE</strong> 必须被清除。</li><li>仅标签写入可以通过设置 <strong>WTAGUPDATE</strong> 和清除 <strong>WSTRB</strong> 来实现。</li></ul><p>在MTE标签传输中，使用哪些写通道操作码是有限制的。
<em><a href="#表 a13.3">表 A13.3</a></em> 显示了每种MTE_Support配置下操作码和<strong>TAGOP</strong>的合法组合。</p><p>对于所有操作码，<strong>TAGOP</strong>编码为无效是合法的。</p><p>星号（*）表示操作码的所有变体。</p><p><a id="表 a13.3">表 A13.3</a> 写事务的合法标签操作码</p><table><thead><tr><th>操作码</th><th>Basic-Transfer</th><th>Basic-Update</th><th>Basic-Match</th><th>Simplified-Transfer</th><th>Simplified-Update <sup><em><a href=#a[13-1]>A[13-1]</a></em></sup></th><th>Simplified-Match</th><th>Standard-Transfer</th><th>Standard-Update</th><th>Standard-Match</th></tr></thead><tbody><tr><td>WriteNoSnoop</td><td>-</td><td>Y</td><td>-</td><td>-</td><td>Y</td><td>-</td><td>Y</td><td>Y</td><td>Y <sup><em><a href=#a[13-2]>A[13-2]</a></em></sup></td></tr><tr><td>WriteUnique*</td><td>-</td><td>Y</td><td>-</td><td>-</td><td>Y</td><td>-</td><td>-</td><td>Y</td><td>-</td></tr><tr><td>WriteNoSnoopFull</td><td>-</td><td>Y</td><td>-</td><td>Y</td><td>Y</td><td>-</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>WriteBackFull</td><td>-</td><td>Y</td><td>-</td><td>Y</td><td>Y</td><td>-</td><td>Y</td><td>Y</td><td>-</td></tr><tr><td>WriteEvictFull</td><td>Y</td><td>-</td><td>-</td><td>Y</td><td>-</td><td>-</td><td>Y</td><td>-</td><td>-</td></tr><tr><td>Atomic</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>Y</td></tr><tr><td>CMO</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>Write*CMO</td><td>-</td><td>-</td><td>-</td><td>Y <sup><em><a href=#a[13-4]>A[13-3]</a></em></sup></td><td>Y</td><td>-</td><td>Y <sup><em><a href=#a[13-4]>A[13-3]</a></em></sup></td><td>Y</td><td>-</td></tr><tr><td>WriteZero</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>WriteUnique*Stash</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>StashOnce*</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>StashTranslation</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>Prefetch</td><td>-</td><td>-</td><td>-</td><td>Y</td><td>-</td><td>-</td><td>Y</td><td>-</td><td>-</td></tr><tr><td>WriteDeferrable</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>UnstashTranslation</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>InvalidateHint</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p><a id=a[13-1]>A[13-1]</a> ：部分标签更新不受支持。
<a id=a[13-2]>A[13-2]</a> ：不独占写入。
<a id=a[13-3]>A[13-3]</a> ：域必须是非共享的。</p><p>写入带标签匹配操作的事务（<strong>AWTAGOP</strong> 为 0b11）有两个部分的响应：</p><ul><li>完成响应，指示写入可以被观察到。</li><li>匹配响应，指示标签比较是通过还是失败。</li></ul><p>两个部分的响应使得具有独立数据和标签存储部分的组件能够独立响应。</p><p>响应传输可以以任何顺序发送。这两个部分可以选择性地合并为一个单一的响应传输。</p><p>响应是通过 <strong>BCOMP</strong> 和 <strong>BTAGMATCH</strong> 进行信号传输的。
<em><a href="#表 a13.14">表 A13.14</a></em> 显示了 BTAGMATCH 的编码。</p><p><a id="表 a13.14">表 A13.14</a> <strong>BTAGMATCH</strong>编码</p><table><thead><tr><th><strong>BTAGMATCH</strong></th><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>None</td><td>没有匹配结果，因为不是匹配事务。</td></tr><tr><td>0b01</td><td>Separate</td><td>比较结果在另一个响应中传输。</td></tr><tr><td>0b10</td><td>Fail</td><td>标签匹配失败。</td></tr><tr><td>0b11</td><td>Pass</td><td>标签匹配成功。</td></tr></tbody></table><p><strong>完成响应</strong></p><p>完成响应表示写入是可观察的。它具有以下规则：</p><ul><li>必须断言<strong>BCOMP</strong>。</li><li><strong>BTAGMATCH</strong>必须为0b01（匹配结果在单独的响应中）。</li><li><strong>BID</strong>必须与<strong>AWID</strong>具有相同的值。</li><li>如果支持环回信号，则<strong>BLOOP</strong>必须与<strong>AWLOOP</strong>具有相同的值。</li><li><strong>BRESP</strong>可以取任何请求Opcode合法的值。</li><li>完成响应必须遵循正常的响应顺序规则。</li><li>当接收到该响应时，ID值可以重复使用。</li></ul><p><strong>匹配响应</strong></p><p>匹配响应表示对写入的标签比较结果。</p><ul><li>如果整个事务的每个传输的标签匹配，则响应为通过。</li><li>如果与活动写数据字节通道相关的任何标签与已有存储的标签不匹配，则响应为失败。</li></ul><p>匹配响应具有以下规则：</p><ul><li>必须取消断言<strong>BCOMP</strong>。</li><li><strong>BTAGMATCH</strong>必须为0b11（通过）或0b10（失败）。</li><li><strong>BID</strong>必须与<strong>AWID</strong>具有相同的值。</li><li><strong>BIDUNQ</strong>可以取任何值，不必与<strong>AWIDUNQ</strong>具有相同的值。</li><li><strong>BLOOP</strong>可以取任何值，不必与<strong>AWLOOP</strong>具有相同的值。</li><li><strong>BRESP</strong>可以取任何请求Opcode合法的值。</li></ul><p><strong>组合响应</strong></p><p>从机可以选择将两个响应组合成一个传输。以下规则适用：</p><ul><li>必须断言<strong>BCOMP</strong>。</li><li><strong>BTAGMATCH</strong>必须为0b11（通过）或0b10（失败）。</li><li><strong>BID</strong>必须与<strong>AWID</strong>具有相同的值。</li><li>如果支持环回信号，则<strong>BLOOP</strong>必须与<strong>AWLOOP</strong>具有相同的值。</li><li><strong>BRESP</strong>可以取任何请求Opcode合法的值。</li><li>组合响应必须遵循正常的响应顺序规则。</li><li>当接收到该响应时，ID值可以重复使用。</li></ul><p>匹配操作的可能响应如 <em><a href="#表 a13.15">表 A13.15</a></em> 所示。</p><p><a id="表 a13.15">表 A13.15</a> 匹配操作可能的响应</p><table><thead><tr><th><strong>BTAGMATCH</strong></th><th><strong>BCOMP</strong></th><th>描述</th></tr></thead><tbody><tr><td>0b00</td><td>0b0</td><td>对带有标签匹配的请求作出回应不合法。</td></tr><tr><td>0b00</td><td>0b1</td><td>对带有标签匹配的请求作出回应不合法。</td></tr><tr><td>0b01</td><td>0b0</td><td>对带有标签匹配的请求作出回应不合法。</td></tr><tr><td>0b01</td><td>0b1</td><td>完成响应，分开响应的一部分。</td></tr><tr><td>0b10</td><td>0b0</td><td>匹配失败，分开响应的一部分。</td></tr><tr><td>0b10</td><td>0b1</td><td>匹配失败或者mte匹配不支持，合并响应。</td></tr><tr><td>0b11</td><td>0b0</td><td>匹配通过，分开响应的一部分。</td></tr><tr><td>0b11</td><td>0b1</td><td>匹配通过，合并响应的一部分。</td></tr></tbody></table><h5 id=a-ida1327-内存标签的互操作性a1327-内存标签的互操作性a><a id="a13.2.7 内存标签的互操作性">A13.2.7 内存标签的互操作性</a></h5><p>当对不支持内存标记的内存位置执行MTE操作时，结果数据必须与对该位置执行非MTE操作的结果相同。</p><ul><li>对于传输或提取的读取，建议<strong>RTAG</strong>为零。</li><li>对于传输或更新的写入，数据必须正常写入，标签被丢弃。</li><li>对于匹配的写入，数据必须正常写入，并提供单个组合响应。
<strong>BTAGMATCH</strong>必须是0b10（失败） 。</li></ul><p>从机在执行MTE操作时预计会给出OKAY响应，除非它对等效的非MTE操作会给出不同的响应。</p><h5 id=a-ida1328-mte和原子事务a1328-mte和原子事务a><a id="a13.2.8 mte和原子事务">A13.2.8 MTE和原子事务</a></h5><p>原子事务可以对受内存标记保护的位置使用写匹配操作。</p><p>原子事务不能与Transfer或Update操作一起使用。</p><p>带匹配的原子比较事务可以是16字节或32字节。如果事务是32字节，则必须对与比较和交换字节相关联的标记位使用相同的标记值。</p><p>在原子事务中返回的读取数据没有有效的<strong>RTAG</strong>值，因此建议将<strong>RTAG</strong>设为零。</p><h5 id=a-ida1329-mte和预取事务a1329-mte和预取事务a><a id="a13.2.9 mte和预取事务">A13.2.9 MTE和预取事务</a></h5><p>带有Transfer的<strong>AWTAGOP</strong>的预取事务表示，如果可能，数据应该带标签地进行预取。
预取事务没有写数据，因此在事务内不会发生标签Transfer操作。</p><h5 id=a-ida13210-mte和中毒a13210-mte和中毒a><a id="a13.2.10 mte和中毒">A13.2.10 MTE和中毒</a></h5><p><em><a href="#a17.1 使用中毒的数据保护">A17.1 使用中毒的数据保护</a></em> 讨论了与读写数据相关的Poison概念。
与分配标签没有直接关联的中毒信号。当写入带有中毒数据的标签时，存储的标签可能会被标记为中毒。</p><p>具体机制由实现定义。实现可能选择以下一种，但也可能有其他实现：</p><ul><li>与数据相关的中毒导致标签被标记为中毒。根据与标签相关的中毒的粒度，可能无法使用清除与数据相关的中毒所用的相同技术来清除标签的中毒。</li><li>与数据相关的中毒不会导致标签被标记为中毒。这意味着损坏的标签可能随后在MTE匹配操作中使用，这可能会错误地失败。这种情况发生的频率应该显著低于数据损坏发生的频率。</li><li>可以根据使用的缓存或存储结构采用混合的方法。</li></ul><h4 id=a-ida133-跟踪信号a133-跟踪信号a><a id="a13.3 跟踪信号">A13.3 跟踪信号</a></h4><p>可选的跟踪信号可以与每个通道关联，以支持系统的调试、跟踪和性能测量。</p><p>Trace_Signals属性用于指示一个组件是否支持跟踪信号。</p><p><a id="表 a13.16">表 A13.16</a> Trace_Signals属性</p><table><thead><tr><th>Trace_Signals</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>所有通道支持跟踪信号。</td></tr><tr><td>False</td><td>Y</td><td>不支持跟踪信号。</td></tr></tbody></table><p>与每个通道相关的追踪信号显示在 <em><a href="#表 a13.17">表 A13.17</a></em> 中。</p><p>如果Trace_Signals属性为真，则必须为所有存在的通道提供适当的追踪信号。</p><p><a id="表 a13.17">表 A13.17</a> 跟踪信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWTRACE</strong></td><td>1</td><td>−</td><td>写请求通道跟踪信号。</td></tr><tr><td><strong>WTRACE</strong></td><td>1</td><td>−</td><td>写数据通道跟踪信号。</td></tr><tr><td><strong>BTRACE</strong></td><td>1</td><td>-</td><td>写响应通道跟踪信号。</td></tr><tr><td><strong>ARTRACE</strong></td><td>1</td><td>-</td><td>读请求通道跟踪信号。</td></tr><tr><td><strong>RTRACE</strong></td><td>1</td><td>-</td><td>读数据通道跟踪信号。</td></tr></tbody></table><p>Trace信号的确切使用在本规范中没有详细说明，但预计Trace信号的使用在系统中是协调的，并且在任何时候只会发生一次Trace信号的使用。
Trace信号的行为是实现定义的，但给出了以下建议：</p><ul><li>主机可以在一个事务的地址上同时断言Trace信号，该事务应在系统中被跟踪。</li><li>组件在处理带有请求中Trace信号断言的事务时应提供带有Trace信号的响应。</li><li>传递事务的组件应保留请求和响应的Trace属性。</li><li>如果下游组件不支持Trace信号，则互连可以在适当的传输上断言Trace。</li><li>接收到带有断言<strong>AWTRACE</strong>信号请求的从机应在响应中同时断言<strong>BTRACE</strong>信号。</li><li>如果接口包含<strong>BCOMP</strong>，则对于<strong>BCOMP</strong>未断言的响应，<strong>BTRACE</strong>可以取任何值。</li><li><strong>WTRACE</strong>应通过互连组件传播。</li><li>接收到带有断言<strong>ARTRACE</strong>信的请求的从机应在每次读取响应的传输中同时断言<strong>RTRACE</strong>信号。</li><li>对于需要在读取通道上响应的原子事务，如果<strong>AWTRACE</strong>被断言，则应断言<strong>RTRACE</strong>信号。</li></ul><h4 id=a-ida134-用户环回信号a134-用户环回信号a><a id="a13.4 用户环回信号">A13.4 用户环回信号</a></h4><p>用户环回信号允许发出请求的代理将与事务有关的信息存储在一个索引表中。
然后，事务响应可以使用快速表索引来获取所需信息，而不是要求使用事务ID进行更复杂的查找。</p><p>Loopback_Signals属性用于指示组件是否支持环回信号。</p><p><a id="表 a13.18">表 A13.18</a>Loopback_Signals属性</p><table><thead><tr><th>Loopback_Signals</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持环回信号。</td></tr><tr><td>False</td><td>Y</td><td>不支持环回信号。</td></tr></tbody></table><p>与每个通道相关的环回信号显示在 <em><a href="#表 a13.19">表 A13.19</a></em> 中。</p><p>如果Loopback_Signals属性为真，则所有通道必须存在适当的环回信号。</p><p><a id="表 a13.19">表 A13.19</a> 环回信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWLOOP</strong><br><strong>BLOOP</strong></td><td>LOOP_W_WIDTH</td><td>全0</td><td>用户定义的值必须从写请求反映到响应传输中。</td></tr><tr><td><strong>ARLOOP</strong><br><strong>RLOOP</strong></td><td>LOOP_R_WIDTH</td><td>全0</td><td>用户定义的值必须从读请求反映到响应传输中。</td></tr></tbody></table><p><a id="表 a13.20">表 A13.20</a> LOOP_W_WIDTH和LOOP_R_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>LOOP_W_WIDTH</td><td>0&mldr;8</td><td>−</td><td>在写通道上的环回信号宽度以位为单位，适用于<strong>AWLOOP</strong>和<strong>BLOOP</strong></td></tr><tr><td>LOOP_R_WIDTH</td><td>0&mldr;8</td><td>−</td><td>在写通道上的环回信号宽度以位为单位，适用于<strong>ARLOOP</strong>和<strong>RLOOP</strong></td></tr></tbody></table><p>环回宽度属性的规则是：</p><ul><li>如果 LOOP_W_WIDTH 为 0，则 <strong>AWLOOP</strong> 和 <strong>BLOOP</strong> 不存在。</li><li>如果 LOOP_R_WIDTH 为 0，则 <strong>ARLOOP</strong> 和 <strong>RLOOP</strong> 不存在。</li><li>如果 Loopback_Signals 为 False，则 LOOP_R_WIDTH 和 LOOP_W_WIDTH 必须为 0。</li></ul><p>使用规则是：</p><ul><li><strong>BLOOP</strong> 的值必须与 <strong>AWLOOP</strong> 的值相同。</li><li>如果接口包含 <strong>BCOMP</strong>，则在 <strong>BCOMP</strong> 去断言的响应中，<strong>BLOOP</strong> 可以取任何值。</li><li><strong>RLOOP</strong> 的值必须与所有读取数据传输中 <strong>ARLOOP</strong> 的值相同。</li><li>对于要求在读取通道上响应的原子事务，<strong>RLOOP</strong> 的值必须与 <strong>AWLOOP</strong> 上提供的值相同。
这意味着主机必须使用可以在 <strong>AWLOOP</strong> 和 <strong>RLOOP</strong> 上发出信号的回环值。</li></ul><p>回环值不要求唯一。允许来自同一主机的多个未完成事务使用相同的值。</p><p>不要求在事务通过系统的过程中保留回环值。中间组件被允许存储其接收到的请求的回环值，并使用其自身的值处理下游传播的请求。
当该组件收到下游事务的响应时，它可以检索原始事务的回环值。</p><h4 id=a-ida135-用户定义信号a135-用户定义信号a><a id="a13.5 用户定义信号">A13.5 用户定义信号</a></h4><p>AXI接口可以包括一组用户定义的信号，称为用户信号。这些信号可以用于增强事务的信息，在有需求未被现有AMBA规范覆盖的情况下。
信息可以添加到：</p><ul><li>事务请求</li><li>事务响应</li><li>事务中的每个读或写数据传输</li></ul><p>一般来说，建议避免使用用户信号。AXI协议没有定义这些信号的功能，如果两个组件以不兼容的方式使用相同的用户信号，这可能会导致互操作性问题。</p><h5 id=a-ida1351-配置a1351-配置a><a id="a13.5.1 配置">A13.5.1 配置</a></h5><p>用户信号的存在和宽度由 <em><a href="#表 a13.21">表 A13.21</a></em> 中的属性指定。</p><p><a id="表 a13.21">表 A13.21</a> 用户信号属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>USER_REQ_WIDTH</td><td>0&mldr;128</td><td>0</td><td>用户扩展请求的宽度以位为单位，适用于<strong>AWUSER</strong>和<strong>ARUSER</strong>。</td></tr><tr><td>USER_DATA_WIDTH</td><td>(0&mldr;DATA_WIDTH)/2</td><td>0</td><td>用户扩展数据的宽度以位为单位，适用于<strong>WUSER</strong>和<strong>RUSER</strong>。</td></tr><tr><td>USER_RESP_WIDTH</td><td>0&mldr;16</td><td>0</td><td>用户扩展响应的宽度以位为单位，适用于<strong>BUSER</strong>和<strong>RUSER</strong>。</td></tr></tbody></table><p>如果一个属性的值为零，则接口上不存在相关信号。</p><p>最大信号宽度仅供参考，用于为可配置接口设置合理的最大值。</p><h5 id=a-ida1352-用户信号a1352-用户信号a><a id="a13.5.2 用户信号">A13.5.2 用户信号</a></h5><p>可以添加到每个通道的用户信号显示在 <em><a href="#表 a13.22">表 A13.22</a></em> 。</p><p><a id="表 a13.22">表 A13.22</a> 用户信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWUSER</strong><strong>ARUSER</strong></td><td>USER_REQ_WIDTH</td><td>全0</td><td>用户定义请求。</td></tr><tr><td><strong>WUSER</strong></td><td>USER_DATA_WIDTH</td><td>全0</td><td>用户定义写数据。</td></tr><tr><td><strong>BUSER</strong></td><td>USER_RESP_WIDTH</td><td>全0</td><td>用户定义写响应。</td></tr><tr><td><strong>RUSER</strong></td><td>USER_DATA_WIDTH + USER_RESP_WIDTH</td><td>全0</td><td>用户定义读数据和响应</td></tr></tbody></table><h5 id=a-ida1353-用户考虑a1353-用户考虑a><a id="a13.5.3 用户考虑">A13.5.3 用户考虑</a></h5><p>用户信号的实现位置：</p><ul><li>并不要求所有通道都支持用户信号。</li><li>关于用户信号的存在和宽度的设计决策是独立于请求、数据和响应通道做出的。</li><li>并不要求请求的用户信号上的值在响应的用户信号上反映出来。</li></ul><p>为了帮助数据宽度和协议转换，建议：</p><ul><li>USER_DATA_WIDTH是数据通道宽度（以字节为单位）的整数倍。</li><li>用户响应位在每次读或写响应的传输中保持相同的值。</li><li><strong>RUSER</strong>的低位用于传输每个事务的响应信息。</li><li><strong>RUSER</strong>的高位用于传输每次传输读数据的信息。</li></ul><h3 id=a-ida第14章-未转换事务a第14章-未转换事务a><a id="a第14章 未转换事务">A第14章 未转换事务</a></h3><p>本章描述了AXI如何支持在系统内存管理单元(SMMU)上游的组件中使用虚拟地址和转换缓存提示。
它包含以下部分：</p><ul><li><em><a href="#a14.1 分布式虚拟内存介绍">A14.1 分布式虚拟内存介绍</a></em></li><li><em><a href="#a14.2 未转换事务支持">A14.2 未转换事务支持</a></em></li><li><em><a href="#a14.3 未转换事务信号">A14.3 未转换事务信号</a></em></li><li><em><a href="#a14.4 转换标识">A14.4 转换标识</a></em></li><li><em><a href="#a14.5 转换错误流程">A14.5 转换错误流程</a></em></li><li><em><a href="#a14.6 未转换事务限制">A14.6 未转换事务限制</a></em></li><li><em><a href="#a14.7 暂存转换操作码">A14.7 暂存转换操作码</a></em></li><li><em><a href="#a14.8 未暂存转换事务操作码">A14.8 未暂存转换事务操作码</a></em></li></ul><h4 id=a-ida141-分布式虚拟内存介绍a141-分布式虚拟内存介绍a><a id="a14.1 分布式虚拟内存介绍">A14.1 分布式虚拟内存介绍</a></h4><p><em><a href="#图 a14.1">图 A14.1</a></em> 中展示了一个使用分布式虚拟内存（DVM）的示例系统。</p><p><a id="图 a14.1">图 A14.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A14.1_Virtual_memory_system.png alt></a></p><p>在 <em><a href="#图 a14.1">图 A14.1</a></em> 中，系统内存管理单元（SMMU）将虚拟地址空间中的地址转换为物理地址空间中的地址。
虽然系统中的所有组件必须使用单一的物理地址空间，但SMMU组件使不同的管理组件能够在各自独立的虚拟地址或中间物理地址空间中操作。</p><p>在 <em><a href="#图 a14.1">图 A14.1</a></em> 所示的虚拟内存系统中，典型的过程可能如下进行：</p><ol><li>一个在虚拟地址（VA）空间中操作的管理组件发出一个使用VA的事务。</li><li>SMMU接收VA进行物理地址（PA）转换：<ul><li>如果SMMU最近执行过所请求的转换，则它可能会从其转换后备缓存（TLB）中获取该转换的缓存副本。</li><li>否则，SMMU必须执行转换表遍历，从内存中访问转换表以获取所需的VA到PA转换。</li></ul></li><li>SMMU使用PA为请求的组件发出事务。</li></ol><p>在该过程的第2步中，所需的VA转换可能不存在。在这种情况下，转换表遍历会生成一个故障，必须通知维护转换表的代理。
为了使所需的访问能够进行，该代理必须提供所需的VA到PA转换。通常，它会使用所需的信息更新转换表。</p><p>维护转换表可能需要对在TLB中缓存的转换表条目进行更改。为防止使用这些条目，可以使用DVM消息发出TLB失效操作。</p><p>当转换表被更新，并且所需的TLB失效操作执行后，使用DVM同步事务以确保所有所需的事务都已完成。</p><p>关于维护SMMU所使用的DVM消息的详细信息可以在 <em><a href="#a第15章 分布式虚拟内存">A第15章 分布式虚拟内存</a></em></p><h4 id=a-ida142-未转换事务的支持a142-未转换事务的支持a><a id="a14.2 未转换事务的支持">A14.2 未转换事务的支持</a></h4><p>AXI支持通过未转换事务扩展使用虚拟地址。未转换事务的规格随着时间的发展而变化，目前有三个不同版本。
建议使用虚拟内存的新设计使用规格的第3版。</p><p>Untranslated_Transactions属性用于指示接口支持的未转换事务的版本。</p><p><a id="表 a14.1">表 A14.1</a> Untranslated_Transactions属性</p><table><thead><tr><th>Untranslated_Transactions</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>v3</td><td></td><td>支持版本3</td></tr><tr><td>v2</td><td></td><td>支持版本2</td></tr><tr><td>v1</td><td></td><td>支持版本1</td></tr><tr><td>True</td><td></td><td>支持版本1</td></tr><tr><td>False</td><td>Y</td><td>未转换版本不支持</td></tr></tbody></table><p>地址转换是将输入地址根据地址映射和存储器属性信息转换为输出地址的过程，这些信息保存在转换表中。
这个过程允许系统中的代理使用他们自己的虚拟地址空间，但确保所有事务的地址最终都被转换为整个系统的单一物理地址空间。</p><p>使用单一物理地址空间是硬件一致性正常操作所必需的，因此SMMU功能通常位于一致性互连之前。</p><p>本节中指定的附加信号提供了足够的信息，使SMMU能够确定特定事务所需的转换，并允许在同一接口上使用不同转换方案的不同事务。</p><p>未转换事务扩展中的所有信号都以<strong>AWMMU</strong>为前缀用于写事务，以<strong>ARMMU</strong>为前缀用于读事务。</p><p>在本规范中，<strong>AxMMU</strong>表示<strong>AWMMU</strong>或<strong>ARMMU</strong>。</p><h4 id=a-ida143-未转换事务信号a143-未转换事务信号a><a id="a14.3 未转换事务信号">A14.3 未转换事务信号</a></h4><p>支持未转换事务的信号如 <em><a href="#表 a14.2">表 A14.2</a></em> 所示。
每个信号将在以下部分中进行描述，包括决定它们是否存在的属性值。</p><p><a id="表 a14.2">表 A14.2</a> 未转换事务信号</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>AWMMUSECSID</strong><br><strong>ARMMUSECSID</strong></td><td>SECSID_WIDTH</td><td>0b00<br>Non-secure</td><td>未转换事务的安全流ID。</td></tr><tr><td><strong>AWMMUSID</strong><br><strong>ARMMUSID</strong></td><td>SID_WIDTH</td><td>全0</td><td>未转换事务的流ID。</td></tr><tr><td><strong>AWMMUSSIDV</strong><br><strong>ARMMUSSIDV</strong></td><td>1</td><td>0b0</td><td>断言为高表明事务有一个有效的子流ID有效。</td></tr><tr><td><strong>AWMMUSSID</strong><br><strong>ARMMUSSID</strong></td><td>SSID_WIDTH</td><td>全0</td><td>未转换事务的子流ID。</td></tr><tr><td><strong>AWMMUATST</strong><br><strong>ARMMUATST</strong></td><td>1</td><td>0b0</td><td>表示事务已经经历了PCIe ATS转换。</td></tr><tr><td><strong>AWMMUFLOW</strong><br><strong>AWMMUFLOW</strong></td><td>2</td><td>0b00<br>Stall</td><td>指示此事务转换故障管理的SMMU流程。</td></tr><tr><td><strong>AWMMUVALID</strong><br><strong>AWMMUVALID&lt;/strong</td><td>1</td><td>0b0</td><td>MMU 限制信号。当未被使能时，事务地址是物理地址，并且不需要翻译。</td></tr></tbody></table><p>当Untranslated_Transactions为v2或v3时，<strong>RRESP</strong>和<strong>BRESP</strong>扩展为3位，以容纳TRANSFAULT响应的信号。
有关编码，请参见 <em><a href="#a4.3 事务响应">A4.3 事务响应</a></em> 。</p><p>在 <em><a href="#表 a14.3">表 A14.3</a></em> 中，有关未转换事务的不同版本，MMU信号的摘要如下：</p><ul><li>‘Y’表示该信号是强制性的。</li><li>‘C’表示存在是可配置的。</li><li>‘-’表示该信号不得存在。</li></ul><p><a id="表 a14.3">表 A14.3</a> 不同版本的未转换事务信号</p><table><thead><tr><th>信号</th><th>Version 1</th><th>Version 2</th><th>Version 3</th></tr></thead><tbody><tr><td><strong>AxMMUSECSID</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td><strong>AxMMUSID</td><td>C</td><td>C</td><td>C</td></tr><tr><td><strong>AxMMUSSIDV</td><td>C</td><td>C</td><td>C</td></tr><tr><td><strong>AxMMUSSID</td><td>C</td><td>C</td><td>C</td></tr><tr><td><strong>AxMMUATST</td><td>C</td><td>-</td><td>-</td></tr><tr><td><strong>AxMMUFLOW</td><td>-</td><td>C</td><td>C</td></tr><tr><td><strong>AxMMUVALID</td><td>-</td><td>-</td><td>Y</td></tr></tbody></table><h4 id=a-ida144-转换标识a144-转换标识a><a id="a14.4 转换标识">A14.4 转换标识</a></h4><p>使用虚拟寻址的请求可以有最多三个在地址转换过程中使用的标识符：</p><ul><li><em><a href="#a14.4.1 安全流标识符">A14.4.1 安全流标识符</a></em></li><li><em><a href="#a14.4.2 流标识符">A14.4.2 流标识符</a></em></li><li><em><a href="#a14.4.3 子流标识符">A14.4.3 子流标识符</a></em></li></ul><p>在构建系统的过程中，某个组件的流标识符可能有一些由组件提供的ID位，以及一些与该组件绑定的ID位。
这固定了该组件可以使用的流标识符命名空间中的值范围。通常，低位由组件提供，而高位则被绑定。</p><p>对于<strong>AxMMUSID</strong>或<strong>AxMMUSSID</strong>的任何额外标识符字段位，必须在组件未提供或互连未硬编码的情况下设置为低电平。</p><h5 id=a-ida1441-安全流标识a1441-安全流标识secsida><a id="a14.4.1 安全流标识">A14.4.1 安全流标识（SECSID）</a></h5><p>安全流标识符用于指示请求的虚拟地址空间。</p><p>它通过<strong>AxMMUSECSID</strong>信号进行传输，<em><a href="#表 a14.4">表 A14.4</a></em> 显示了编码方式。</p><p><a id="表 a14.4">表 A14.4</a> <strong>AxMMUSECSID</strong>信号</p><table><thead><tr><th><strong>AxMMUSECSID</strong></th><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>Non-secure</td><td>非安全地址空间</td></tr><tr><td>0b01</td><td>Secure</td><td>安全地址空间</td></tr><tr><td>0b10</td><td>Realm</td><td>领域地址空间</td></tr><tr><td>0b11</td><td>RESERVED</td><td>-</td></tr></tbody></table><p><strong>AxMMUSECSID</strong>的宽度由属性SECSID_WIDTH决定。</p><p><a id="表 a14.5">表 A14.5</a> SECSID_WIDTH属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>SECSID_WIDTH</td><td>0,1,2</td><td>0</td><td><strong>AxMMUSECSID<strong>信号的位宽。</td></tr></tbody></table><p>以下规则适用：</p><ul><li>当 Untranslated_Transactions 为 False 时 <strong>SECSID_WIDTH</strong> 必须为 0， <strong>AxMMUSECSID</strong> 信号不存在。</li><li>当 Untranslated_Transactions 不为 False 且 RME_Support 为 False 时 SECSID_WIDTH 必须为 1，只能使用非安全和安全地址空间。</li><li>当 Untranslated_Transactions 不为 False 且 RME_Support 为 True 时 SECSID_WIDTH 必须为 2。</li><li>当 <strong>AxMMUSECSID</strong> 为非安全时， <strong>AxNSE/AxPROT</strong> 必须指示为非安全。</li><li>当 <strong>AxMMUSECSID</strong> 为安全时。 <strong>AxNSE/AxPROT</strong> 必须指示为非安全或安全。</li><li>当 <strong>AxMMUSECSID</strong> 为领域时， <strong>AxNSE/AxPROT</strong> 必须指示为非安全或领域。</li></ul><h5 id=a-ida1442-流标识a1442-流标识a><a id="a14.4.2 流标识">A14.4.2 流标识</a></h5><p>StreamID可用于将请求映射到MMU中的转换上下文。
每个地址空间使用不同的名称空间，因此它们可以具有相同的Stream Identifier值。</p><p><strong>AxMMUSID</strong>的宽度由属性SID_WIDTH确定。</p><p><a id="表 a14.6">表 A14.6</a> SID_WIDTH属性</p><table><thead><tr><th>名字</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>SID_WIDTH</td><td>0&mldr;32</td><td>0</td><td>StreamID 位宽，应用于<strong>AWMMUSID</strong>和<strong>ARMMUSID</strong>。</td></tr></tbody></table><p>如果SID_WIDTH为0，则<strong>AxMMUSID</strong>信号不存在并使用默认值。</p><h5 id=a-ida1443-子流标识符a1443-子流标识符a><a id="a14.4.3 子流标识符">A14.4.3 子流标识符</a></h5><p>SubstreamID可以与具有相同StreamID的请求一起使用，以将不同的应用程序地址映射关联到不同的逻辑块。</p><p>SubstreamID有一个单独的使能信号<strong>AxMMUSSIDV</strong>，因此主机可以发出有或没有SubstreamID的请求。
<strong>AxMMUSSIDV</strong>未被激活时，<strong>AxMMUSSID</strong>必须为0。</p><blockquote><p>Note：</br>SubstreamID为0的流与没有有效子流的流不同（AxMMUSSIDV未被激活）。</br><strong>AxMMUSSID</strong>的宽度由属性SSID_WIDTH决定。</p></blockquote><p><a id="表 a14.7">表 A14.7</a> SSID_WIDTH 属性</p><table><thead><tr><th>属性名</th><th>值</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>SSID_WIDTH</td><td>0&mldr;20</td><td>0</td><td>子流ID位宽适用于<strong>AWMMUSSID</strong>和<strong>ARMMUSSID</strong></td></tr></tbody></table><p>当SSID_WIDTH为0时，接口上不存在<strong>AxMMUSSID</strong>和<strong>AxMMUSSIDV</strong>，并且没有有效的SubstreamID。</p><h5 id=a-ida1444-pcie考虑a1444-pcie考虑a><a id="a14.4.4 pcie考虑">A14.4.4 PCIE考虑</a></h5><p>当使用 Untranslated_Transactions 信号与PCIe Root Complex接口时，以下注意事项适用：</p><ul><li><strong>AxMMUSECSID</strong>必须为非安全或领域。</li><li><strong>AxMMUSID</strong>对应于PCIe请求者ID。</li><li><strong>AxMMUSSID</strong>对应于PCIe PASID。</li><li>如果事务具有PASID前缀，则<strong>AxMMUSSIDV</strong>被断言，否则为非断言。</li></ul><h4 id=a-ida145-转换错误流程a145-转换错误流程a><a id="a14.5 转换错误流程">A14.5 转换错误流程</a></h4><p>未转换的事务可以指示在SMMU遇到转换故障时可以使用哪个流。
如果没有指示任何流，则假定为Stall流。</p><p>属性MMUFLOW_Present用于指示是否支持其他SMMU流。</p><p><a id="表 a14.8">表 A14.8</a> MMUFLOW_Present 属性</p><table><thead><tr><th>MMUFLOW_Present</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td><strong>AxMMUFLOW&lt;/strong或<strong>AxMMUATST</strong>存在。</td></tr><tr><td>False</td><td>Y</td><td><strong>AxMMUFLOW&lt;/strong或<strong>AxMMUATST</strong>不存在。</td></tr></tbody></table><p>如果Untranslated_Transactions为False，MMUFLOW_Present必须为False。</p><p>如果MMUFLOW_Present为True，则：</p><ul><li>如果Untranslated_Transactions为True或v1，<strong>ARMMUATST</strong>和<strong>AWMMUATST</strong>在接口上存在。</li><li>如果Untranslated_Transactions为v2或v3，<strong>ARMMUFLOW</strong>和<strong>AWMMUFLOW</strong>在接口上存在。</li></ul><p>规格的版本1对未转换事务支持Stall和ATST流，使用<strong>AxMMUATST</strong>信号。</p><ul><li>当<strong>AxMMUATST</strong>被去断言为LOW时，使用Stall流。</li><li>当<strong>AxMMUATST</strong>被断言为HIGH时，使用ATST流。</li></ul><p>对于版本2及以上，使用<strong>AxMMUFLOW</strong>信号指示可以使用哪个流。</p><p><a id="表 a14.9">表 A14.9</a> <strong>AxMMUFLOW</strong>编码</p><table><thead><tr><th><strong>AxMMUFLOW</strong></th><th>流类型</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>Stall</td><td>The SMMU Stall flow can be used.</td></tr><tr><td>0b01</td><td>ATST</td><td>The SMMU ATST flow must be used.</td></tr><tr><td>0b10</td><td>NoStall</td><td>The SMMU NoStall flow must be used.</td></tr><tr><td>0b11</td><td>PRI</td><td>The SMMU PRI flow can be used.</td></tr></tbody></table><p>以下部分逐一描述每个流程。</p><h5 id=a-ida1451-stall流a1451-stall流a><a id="a14.5.1 stall流">A14.5.1 stall流</a></h5><p>当使用stall流时，软件可以配置SMMU在发生转换故障时采取以下操作之一：</p><ul><li>用SLVERR响应终止事务。</li><li>用OKAY响应终止事务，数据为RAZ/WI。</li><li>暂停转换并通知软件转换已暂停。
软件可以指示SMMU终止事务或更新转换表并重试转换。主机并不知道暂停的情况。</li></ul><p>这种流程使软件能够管理转换故障和需求分页，而主机并不知情。</p><p>然而，它有一些限制：</p><ul><li>主机可能会看到非常长的事务延迟，这可能触发超时。</li><li>由于软件活动的依赖，暂停流可能会导致某些系统中的死锁。</li></ul><p>例如，由于CPU向PCIe的外发事务与通过SMMU从PCIe来的内发事务之间的依赖，不建议与PCIe一起使用。</p><p>启用暂停流并不一定会在发生转换故障时导致暂停。只有在软件启用时才会发生暂停。软件通常不为PCIe端点启用暂停。</p><h5 id=a-ida1452-atst流a1452-atst流a><a id="a14.5.2 atst流">A14.5.2 atst流</a></h5><p>地址转换服务转换（ATST）流程表明该事务已经由ATS转换。
此流程仅由PCIe根端口使用。</p><p>当流程为ATST时，事务可能仍会根据SMMU的配置经历一些转换。有关更多信息，请参见Arm®系统内存管理单元架构规范 <em><a href=#a[7]>A[7]</a></em> 。
如果发生转换错误，事务必须以SLVERR响应终止。
当流程为ATST时，适用以下约束：</p><ul><li><strong>AxMMUSECSID</strong>必须是非安全或领域。</li><li>如果Untranslated_Transactions为真，且版本是v1或v2，则<strong>AxMMUSSIDV</strong>必须为低电平。</li></ul><p>当Untranslated_Transactions为v3时，允许在<strong>AxMMUFLOW</strong>指示ATST时触发<strong>AxMMUSSIDV</strong>。
这是为了实现使用<strong>AxMMUSSID</strong>信号从PCIe事务传输PASID和其他属性。</p><h5 id=a-ida1453-nostall流a1453-nostall流a><a id="a14.5.3 nostall流">A14.5.3 nostall流</a></h5><p>NoStall流用于无法被阻塞的主机。如果在使用此流时发生转换故障，子节点必须用SLVERR或OKAY响应终止事务，即使软件已将设备配置为在发生转换故障时被阻塞。</p><p>这个流推荐用于像PCIe根端口的主机，因为如果启用软件阻塞，可能会导致死锁。</p><h5 id=a-ida1454-pri流a1454-pri流a><a id="a14.5.4 pri流">A14.5.4 pri流</a></h5><p>PRI（Page Request Interface）流旨在与集成的PCIe终端使用。
主机使用PRI流使软件能够对转换故障作出响应，而不会导致死锁。</p><p>当流为PRI且发生转换故障时，事务将以TRANSFAULT响应终止。
然后，主机可以使用单独的机制请求释放Page，然后再重试该事务。
此机制通常为PCIe PRI。</p><p>当使用此流时，软件启用ATS，但硬件中不需要ATS功能。</p><p>如果由于无法通过PRI请求解决的原因，例如SMMU配置不正确，使用此流的事务仍可能会被SMMU以SLVERR终止。</p><p>以下规则适用于TRANSFAULT响应：</p><ul><li>TRANSFAULT通过将<strong>RRESP</strong>或<strong>BRESP</strong>设置为0b101来指示。
请参阅 <em><a href="#a4.3 事务响应">A4.3 事务响应</a></em> 以获取所有编码。</li><li>TRANSFAULT响应仅允许用于使用PRI流的请求。</li><li>如果TRANSFAULT用于一个响应传输，则必须对该事务的所有响应传输均使用TRANSFAULT。</li><li>如果<strong>RRESP</strong>为TRANSFAULT，则该传输中的读取数据无效。</li></ul><h4 id=a-ida146-未转换事务限制a146-未转换事务限制a><a id="a14.6 未转换事务限制">A14.6 未转换事务限制</a></h4><p>当Untranslated_Transactions属性为v3时，会在读写请求通道中添加一个限定信号<strong>AxMMUVALID</strong>。</p><p>当AxMMUVALID被去断言时，事务地址是物理地址，不需要翻译。
这使得主机能够发出转换和未转换事务的混合。</p><p>使用这些信号的规则如下：</p><ul><li>当<strong>AxMMUVALID</strong>被断言时，以下信号受到限制：<ul><li><strong>AxTAGOP</strong>必须为0b00（无效）</li></ul></li><li>当<strong>AxMMUVALID</strong>被去断言时，以下信号不适用，可以取任何值：<ul><li><strong>AxMMUSECSID</strong></li><li><strong>AxMMUSID</strong></li><li><strong>AxMMUSSIDV</strong></li><li><strong>AxMMUSSID</strong></li><li><strong>AxMMUFLOW</strong></li></ul></li></ul><h4 id=a-ida147-暂存转换操作码a147-暂存转换操作码a><a id="a14.7 暂存转换操作码">A14.7 暂存转换操作码</a></h4><p>StashTranslation 操作码是一个提示，表示 MMU 应该缓存处理给定地址所需的表项，以减少未来使用该表项的任何事务的延迟。</p><p>MMU 的要求取决于地址是虚拟地址还是物理地址，以及是否正在使用领域管理扩展（Realm Management Extension）：</p><ul><li>如果 <strong>AWMMUVALID</strong> 被断言，则 StashTranslation 请求具有虚拟地址，MMU 应该缓存相关的Page表项。</li><li>如果 <strong>AWMMUVALID</strong> 被去断言，则 StashTranslation 请求具有物理地址，MMU 应该缓存相关的粒度保护表项。</li></ul><p>如果 RME_Support 为 False，则 StashTranslation 请求必须将 <strong>AWMMUVALID</strong> 断言。</p><p>StashTranslation 操作码可以由主机使用，并由从机支持，如果满足以下属性条件：</p><ul><li>Untranslated_Transactions 为 v1、v2 或 v3。</li><li>Untranslated_Transactions 为 True 且 Cache_Stash_Transactions 为 True。</li></ul><p>StashTranslation 操作的规则是：</p><ul><li>StashTranslation 事务由 AW 通道上的请求和 B 通道上的单个响应传输组成。没有写数据传输。</li><li><strong>AWSNOOP</strong> 为 0b01110，以指示 StashTranslation，AWSNOOP_WIDTH 可以为 4 或 5。</li><li>不支持任何存储目标。如果存在，<strong>AWSTASHNID</strong>、<strong>AWSTASHNIDEN</strong>、<strong>AWSTASHLPID</strong> 和 <strong>AWSTASHLPIDEN</strong> 必须为 LOW。</li><li>允许任何合法的 <strong>AWCACHE</strong> 和 <strong>AWDOMAIN</strong> 值的组合。请参见 <em><a href="#表 a9.7">表 A9.7</a></em> 。</li><li><strong>AWATOP</strong> 为 0b000000（非原子事务）。</li><li><strong>AWTAGOP</strong> 为 0b00（无效）。</li><li>StashTranslation 请求不得使用与同时存在的非 StashTranslation 事务使用的相同 AXI ID 值。
这条规则确保 StashTranslation 事务与其他事务之间没有排序约束，因此不暂存转换的从机可以立即响应。</li><li>OKAY 响应表示 StashTranslation 请求已被接受，而不是转换已被存储。该请求是一个提示，并不保证会被完成者处理。</li></ul><h4 id=a-ida148-非暂存转换操作码a148-非暂存转换操作码a><a id="a14.8 非暂存转换操作码">A14.8 非暂存转换操作码</a></h4><p>UnstashTranslation操作码是一个提示，表示与给定事务地址和StreamID对应的Page表或粒度表条目不太可能再次使用。</p><p>对MMU的要求取决于地址是虚拟地址还是物理地址，以及是否正在使用Realm管理扩展：</p><ul><li>如果<strong>AWMMUVALID</strong>被置为真，则UnstashTranslation请求具有虚拟地址，MMU应该释放相关的Page表条目。</li><li>如果<strong>AWMMUVALID</strong>被置为假，则StashTranslation请求具有物理地址，MMU应该释放相关的粒度保护表条目。</li></ul><p>如果RME_Support为假，UnstashTranslation请求必须将<strong>AWMMUVALID置</strong>为真。</p><p>UnstashTranslation_Transaction属性用于指示接口是否支持UnstashTranslation操作码。</p><p><a id="表 a14.10">表 A14.10</a>UnstashTranslation_Transaction属性</p><table><thead><tr><th>UnstashTranslation_Transaction</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持非暂存转换。</td></tr><tr><td>False</td><td>Y</td><td>不支持非暂存转换。</td></tr></tbody></table><p>下表显示了根据UnstashTranslation_Transaction属性的值，主机和从机接口之间的兼容性。</p><table><thead><tr><th>UnstashTranslation_Transaction</th><th>从机：False</th><th>从机：True</th></tr></thead><tbody><tr><td>主机：False</td><td>兼容</td><td>兼容</td></tr><tr><td>主机：True</td><td>不兼容</td><td>兼容</td></tr></tbody></table><p>UnstashTranslation操作的规则是：</p><ul><li>UnstashTranslation事务由AW通道上的请求和B通道上的单个响应传输组成。没有写数据传输。</li><li><strong>AWSNOOP</strong>为0b10001以指示UnstashTranslation，AWSNOOP_WIDTH必须为5。</li><li>不支持任何stash目标。如果存在，<strong>AWSTASHNID</strong>、<strong>AWSTASHNIDEN</strong>、<strong>AWSTASHLPID</strong>和<strong>AWSTASHLPIDEN</strong>必须为LOW。</li><li>允许任何合法的<strong>AWCACHE</strong>和<strong>AWDOMAIN</strong>值的组合。见 <em><a href="#表 a9.7">表 A9.7</a></em> 。</li><li><strong>AWATOP</strong>为0b000000（非原子事务）。</li><li><strong>AWTAGOP</strong>为0b00（无效）。</li><li><strong>AWID</strong>在传输中是唯一的，这意味着：<ul><li>只有在写通道上没有使用相同ID值的未完成事务时，才能发出UnstashTranslation请求。</li><li>主机不得在写通道上发出与未完成UnstashTranslation事务具有相同ID的请求。</li><li>如果存在，<strong>AWIDUNQ</strong>必须在UnstashTranslation请求中被断言。</li></ul></li><li>OKAY响应表示UnstashTranslation请求已被接受，而不是指翻译已被释放。该请求是一个提示，并不保证由完成者执行。</li></ul><h3 id=a-ida第15章-分布式虚拟内存消息a第15章-分布式虚拟内存消息a><a id="a第15章 分布式虚拟内存消息">A第15章 分布式虚拟内存消息</a></h3><p>本章描述了AXI如何使用分布式虚拟内存DVM消息支持分布式系统MMU，以维护虚拟内存系统中的所有MMU。<br>它包含以下几个部分：</p><ul><li><em><a href="#a15.1 dvm事务介绍">A15.1 DVM事务介绍</a></em></li><li><em><a href="#a15.2 dvm消息支持">A15.2 DVM消息支持</a></em></li><li><em><a href="#a15.3 dvm消息">A15.3 DVM消息</a></em></li><li><em><a href="#a15.4 dvm消息传输">A15.4 DVM消息传输</a></em></li><li><em><a href="#a15.5 dvm同步与完成">A15.5 DVM同步与完成</a></em></li><li><em><a href="#a15.6 一致性连接信号">A15.6 一致性连接信号</a></em></li></ul><h4 id=a-ida151-dvm事务介绍a151-dvm事务介绍a><a id="a15.1 dvm事务介绍">A15.1 DVM事务介绍</a></h4><p>DVM事务是一个可选功能，用于传递支持虚拟内存系统维护的消息。有两种类型的DVM事务：DVM消息和DVM完成。<br>DVM消息支持以下操作：</p><ul><li>TLB失效</li><li>分支预测器失效</li><li>物理指令缓存失效</li><li>虚拟指令缓存失效</li><li>同步</li><li>提示</li></ul><p>DVM消息请求从从机发送，通常是在互连上，发送到主机接口，使用侦听请求（AC）通道。</p><p>DVM消息响应从主机发送到从机，使用侦听响应（CR）通道。</p><p>DVM完成事务是在读取请求通道（AR）上对DVM同步（Sync）消息发出的，以指示所有所需操作和任何相关事务已完成。</p><h4 id=a-ida152-dvm消息支持a152-dvm消息支持a><a id="a15.2 dvm消息支持">A15.2 DVM消息支持</a></h4><p>DVM_Message_Support 属性用于指示接口是否支持 DVM 消息。</p><p><a id="表 a15.1">表 A15.1</a> DVM_Message_Support属性</p><table><thead><tr><th>DVM_Message_Support</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>Receiver</td><td></td><td>支持DVM消息和同步事务在AC/CR通道上从从机到主机。<br>支持DVM完成事务在AR/R通道上从主机支持到从机。</td></tr><tr><td>False</td><td>Y</td><td>不支持DVM完成传输。</td></tr></tbody></table><blockquote><p>Note：</br>在本规范的先前版本中，DVM_Message_Support的双向选项已被弃用。</p></blockquote><p>DVM Complete消息要求<strong>ARDOMAIN</strong>设置为Shareable。
因此，当DVM_Message_Support为Receiver时，Shareable_Transactions属性必须为True。</p><p>DVM消息是在Armv7架构中引入的，并在Armv8、Armv8.1、Armv8.4和Armv9.2架构中进行了扩展。发起和接收DVM消息的接口必须支持相同的架构版本。<br>以下属性定义了接口支持的版本：</p><ul><li>DVM_v8</li><li>DVM_v8.1</li><li>DVM_v8.4</li><li>DVM_v9.2</li></ul><p>每个属性可以取值：True或False。如果属性未声明，则被视为False。</p><p>在 <em><a href="#表 a15.2">表 A15.2</a></em> 中指明了根据属性值支持哪些消息版本。支持特定版本DVM消息的组件还必须支持早期架构版本。</p><p><a id="表 a15.2">表 A15.2</a> DVM消息版本</p><table><thead><tr><th>DVM_v9.2</th><th>DVM_v8.4</th><th>DVM_v8.1</th><th>DVM_v8</th><th>Armv9.2</th><th>Armv8.4</th><th>Armv8.1</th><th>Armv8</th><th>Armv7</th></tr></thead><tbody><tr><td>True</td><td>True or False</td><td>True or False</td><td>True or False</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>False</td><td>True</td><td>True or False</td><td>True or False</td><td>-</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>False</td><td>False</td><td>True</td><td>True or False</td><td>-</td><td>-</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>False</td><td>False</td><td>False</td><td>True</td><td>-</td><td>-</td><td>-</td><td>Y</td><td>Y</td></tr><tr><td>False</td><td>False</td><td>False</td><td>False</td><td>-</td><td>-</td><td>-</td><td>-</td><td>Y</td></tr></tbody></table><h4 id=a-ida153-dvm消息a153-dvm消息a><a id="a15.3 dvm消息">A15.3 DVM消息</a></h4><p>以下 DVM 消息受到协议支持：</p><ul><li>TLB 失效</li><li>分支预测器失效</li><li>物理指令缓存失效</li><li>虚拟指令缓存失效</li><li>同步</li><li>提示</li></ul><p>DVM 事务仅在只读结构上操作，例如指令缓存、分支预测器和 TLB，因此只需要失效操作。
清除的概念不适用于只读结构。这意味着使更多条目无效在功能上是正确的，即使这不是DVM消息所要求的，虽然这些额外的失效可能会影响性能。</p><h5 id=a-ida1531-dvm消息字段a1531-dvm消息字段a><a id="a15.3.1 dvm消息字段">A15.3.1 DVM消息字段</a></h5><p>DVM消息中的字段如 <em><a href="#表 a15.3">表 A15.3</a></em> 所示。</p><p><a id="表 a15.3">表 A15.3</a> DVM消息字段</p><table><thead><tr><th>字段名</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>VA</td><td>32-57</td><td>虚拟地址。</td></tr><tr><td>PA</td><td>32-52</td><td>物理地址。</td></tr><tr><td>ASID</td><td>8或16</td><td>地址空间ID。</td></tr><tr><td>ASIDV</td><td>1</td><td>断言为HIGH，表示ASID字段有效；<br>断言为LOW，ASID字段必须为0。</td></tr><tr><td>VMID</td><td>8或16</td><td>虚拟机ID。</td></tr><tr><td>VMIDV</td><td>1</td><td>断言为HIGH，表示VMID字段有效；<br>断言为LOW，VMID字段必须为0。</td></tr><tr><td>DVMType</td><td>3</td><td>0b000：TLB无效（TLBI）。<br>0b001：分支预测无效（BPI）。<br>0b010：物理指令缓存无效（PICI）。<br>0b011：虚拟指令缓存无效（VICV）。<br>0b100：同步（Sync）<br>0b101：Reserved。<br>0b110：提示（Hint）。<br>0b111：Reserved。</td></tr><tr><td>Exception</td><td>2</td><td>表示事务的异常级别。<br>0b00：Hypervisor and all Guest OS。<br>0b01：EL3 <sup><em><a href=#a[15-1]>A[15-1]</a></em> </sup>。0b10：Guest OS。<br>0b11：Hypervisor。</td></tr><tr><td>Security</td><td>2</td><td>指示失效适用于哪个安全状态。见 <em><a href="#表 a15.6">表 A15.6</a></em></td></tr><tr><td>Leaf</td><td>1</td><td>仅指示Leaf条目是否无效。<br>0b0：所有相关的转换都无效。<br>0b1只有Leaf条目无效。</td></tr><tr><td>Stage</td><td>2</td><td>指示哪个阶段无效。<br>0b00：Armv7：失效的阶段根据失效的类型变化。<br>0b00：Armv8以及之后：阶段1和2失效。<br>0b01：阶段1失效。<br>0b10：阶段2失效。0b11：GPT <sup><em><a href=#a[15-2]>A[15-2]</a></em> </sup>。</td></tr><tr><td>Num</td><td>5</td><td>用于范围计算中的常数乘法因子。<br>所有二进制值都是有效的。</td></tr><tr><td>Scale</td><td>2</td><td>用于地址范围指数计算的常量。<br>所有二进制值都是有效的。</td></tr><tr><td>TTL</td><td>2</td><td>转换表级别(TTL)的提示，其中包括要使无效的地址。<br>详细信息见表 <em><a href="#表 a15.4">表 A15.4</a></em> 和 <em><a href="#表 a15.5">表 A15.5</a></em> 。</td></tr><tr><td>TG</td><td>2</td><td>转换粒度 (TG)。对于按范围的 TLB 无效化，TG 表示粒度大小：</br>0b00：Reserved。<br>0b01：4k。<br>0b10：16k。<br>0b11：64k。<br>对于非范围TLB失效，TG和TTL表示表级提示，参见 <em><a href="#表 a15.5">表 A15.5</a></em></td></tr><tr><td>VI</td><td>16</td><td>虚拟索引，用于PICI消息。</td></tr><tr><td>VIV</td><td>2</td><td>虚拟索引有效。<br>0b00：虚拟索引无效。<br>0b01：Reserved。<br>0b10：Reserved。<br>0b11：虚拟索引有效。</td></tr><tr><td>IS</td><td>4</td><td>GPT TLBI PA操作编码无效化的大小：0b000：4KB。<br>0b0001：16KB。<br>0b0010：64KB。<br>0b0011：2MB。<br>0b0100：32MB。<br>0b0101：512MB。<br>0b0110：1GB。<br>0b0111：16GB。<br>0b1000：。<br>0b01001：512GB。<br>0b1010-0b1111：Reserved。</td></tr><tr><td>Addr</td><td></td><td>消息是否包含地址。<br>0b0：没有地址信息。<br>0b1保护地址信息，而且是一个两部分的消息。</td></tr><tr><td>Range</td><td></td><td>断言为HIGH表示这是地址范围的第二部分。</td></tr><tr><td>Completion</td><td></td><td>断言为HIGH表示需要完成消息。</td></tr></tbody></table><p><a id=a[15-1]>A[15-1]</a> :Exception Level 3。EL3 是最高的特权级别，比 EL0（用户应用程序级别），EL1（操作系统内核级别），和 EL2（虚拟机管理程序级别）都要高。
<a id=a[15-2]>A[15-2]</a> :Granule Protection Tables。用于配置每个粒度关联的物理地址空间。</p><p><strong>TLB Invalidate level hint</strong></p><p>地址范围的TLB失效中，TTL字段表示哪一级转换表遍历持有要失效地址的Leaf条目。编码如 <em><a href="#表 a15.4">表 A15.4</a></em> 。</p><p><a id="表 a15.4">表 A15.4</a> TLB失效指示的Leaf条目。</p><table><thead><tr><th>TTL</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>没有Leaf被指示。</td></tr><tr><td>0b01</td><td>Leaf位于转换表的第1级。</td></tr><tr><td>0b10</td><td>Leaf位于转换表的第2级。</td></tr><tr><td>0b11</td><td>Leaf位于转换表的低3级</td></tr></tbody></table><p>对于非范围地址的TLB失效，TTL和TG字段指示转换表遍历的哪一级持有正在失效的地址的Leaf条目。编码如下</p><p><a id="表 a15.5">表 A15.5</a></p><table><thead><tr><th>TG</th><th>TTL</th><th>含义</th></tr></thead><tbody><tr><td>0b00</td><td>0b00</td><td>没有级别被指示。</td></tr><tr><td>0b00</td><td>0b01</td><td>Reserved</td></tr><tr><td>0b00</td><td>0b10</td><td>Reserved</td></tr><tr><td>0b00</td><td>0b11</td><td>Reserved</td></tr><tr><td>0b01</td><td>0b00</td><td>没有级别被指示。</td></tr><tr><td>0b01</td><td>0b01</td><td>失效的Leaf位于转换表的第1级。</td></tr><tr><td>0b01</td><td>0b10</td><td>失效的Leaf位于转换表的第2级。</td></tr><tr><td>0b01</td><td>0b11</td><td>失效的Leaf位于转换表的第3级。</td></tr><tr><td>0b10</td><td>0b00</td><td>没有级别被指示。</td></tr><tr><td>0b10</td><td>0b01</td><td>没有级别被指示。</td></tr><tr><td>0b10</td><td>0b10</td><td>失效的Leaf位于转换表的第2级。</td></tr><tr><td>0b10</td><td>0b11</td><td>失效的Leaf位于转换表的第3级。</td></tr><tr><td>0b11</td><td>0b00</td><td>没有级别被指示。</td></tr><tr><td>0b11</td><td>0b01</td><td>失效的Leaf位于转换表的第1级。</td></tr><tr><td>0b11</td><td>0b10</td><td>失效的Leaf位于转换表的第2级。</td></tr><tr><td>0b11</td><td>0b11</td><td>失效的Leaf位于转换表的第3级。</td></tr></tbody></table><p><strong>Security field</strong></p><p>安全字段根据DVM类型的不同有不同的含义，如 <em><a href="#表 a15.6">表 A15.6</a></em> 所示。</p><p><a id="表 a15.6">表 A15.6</a> 对于每个DVM类型安全字段的编码</p><table><thead><tr><th>安全</th><th>TLBI</th><th>BPI</th><th>PICI All</th><th>PICI by PA</th><th>VICI</th></tr></thead><tbody><tr><td>0b00</td><td>Realm</td><td>Secure<br>No-secure</td><td>Root<br>Realm<br>Secure<br>Non-secure</td><td>Root</td><td>Secure<br>Non-secure</td></tr><tr><td>0b01</td><td>Non-secure address from a Secure context</td><td>保留</td><td>Realm<br>Non-secure</td><td>Realm</td><td>保留</td></tr><tr><td>0b10</td><td>Secure</td><td>保留</td><td>Secure<br>Non-secure</td><td>Secure</td><td>Secure</td></tr><tr><td>0b11</td><td>Non-secure</td><td>保留</td><td>Non-secure</td><td>Non-secure</td><td>Non-secure</td></tr></tbody></table><p><strong>ASID 字段</strong></p><p>ASID 字段包含一个 8 位或 16 位的地址空间 ID。</p><ul><li>Armv7 仅支持 8 位 ASID。</li><li>Armv8 及以上版本支持 8 位和 16 位 ASID。</li></ul><p>无法从 DVM 消息中确定消息使用的是 8 位还是 16 位 ASID。所有 8 位 ASID 消息都需要将 ASID[15:8] 位设置为零。</p><p>预计大多数系统将在整个系统中使用单一 ASID 大小，要么为 8 位 ASID，要么为 16 位 ASID。</p><p>在包含混合 8 位 ASID 和 16 位 ASID 组件的系统中，预计所有维护都由使用 16 位 ASID 的代理完成。这确保代理能够对 8 位 ASID 和 16 位 ASID 组件执行维护。</p><p>互操作性要求如下：</p><ul><li>对于 8 位 ASID 代理向 16 位 ASID 代理发送消息，消息将显示为上 8 位设置为零的 16 位 ASID。</li><li>对于 16 位 ASID 代理向 8 位 VMID 代理发送消息：<ul><li>如果上 8 位为零，则消息已正确接收。</li><li>如果上 8 位不为零，则会发生过度失效，因为 8 位 ASID 代理会忽略上 8 位。</li></ul></li></ul><p><strong>VMID 字段</strong></p><p>VMID 字段包含一个 8 位或 16 位的虚拟机 ID。</p><ul><li>Armv7 和 Armv8 仅支持 8 位 VMID。</li><li>Armv8.1 及以上版本支持 8 位和 16 位 VMID。</li></ul><p>无法从 DVM 消息中确定消息使用的是 8 位还是 16 位 VMID。所有 8 位 VMID 消息都需要将 VMID[15:8] 字段设置为零。</p><p>预计大多数系统将在整个系统中使用单一 VMID 大小，要么为 8 位 VMID，要么为 16 位 VMID。</p><p>在包含混合 8 位 VMID 和 16 位 VMID 组件的系统中，预计所有维护都由使用 16 位 VMID 的代理完成。这确保代理能够对 8 位 VMID 和 16 位 VMID 组件执行维护。</p><p>互操作性要求如下：</p><ul><li>对于 8 位 VMID 代理向 16 位 VMID 代理发送消息，消息将显示为上 8 位设置为零的 16 位 VMID。</li><li>对于 16 位 VMID 代理向 8 位 VMID 代理发送消息：<ul><li>如果上 8 位为零，则消息已正确接收。</li><li>如果上 8 位不为零，则会发生过度失效，因为 8 位 VMID 代理会忽略上 8 位。</li></ul></li></ul><p>当 Armv8.1 及以上版本得到支持时，<strong>ACVMIDEXT</strong> 被包含在 AC 通道上以传输 16 位 VMID 的上字节。详情请参见 <em><a href="#a15.4 dvm消息传输">A15.4 DVM消息传输</a></em> 。</p><h5 id=a-ida1532-tlm失效消息a1532-tlm失效消息a><a id="a15.3.2 tlm失效消息">A15.3.2 tlm失效消息</a></h5><p>这一部分详细介绍了TLB无效（TLBI）消息。</p><p>对于TLBI消息，一些字段具有固定值，如 <em><a href="#表 a15.7">表 A15.7</a></em> 所示。</p><p><a id="表 a15.7">表 A15.7</a> 固定字段值的TLBI消息</p><table><thead><tr><th>字段名</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>DVMtype</td><td>0b000</td><td>TLB无效操作码。</td></tr><tr><td>Completion</td><td>0b0</td><td>不需要完成。</td></tr></tbody></table><p>TLBI必须操作的条目取决于消息中的字段，所有支持的TLBI操作如 <em><a href="#表 a15.8">表 A15.8</a></em> 所示。</p><p>Arm列指示支持该消息所需的最低Arm架构版本。</p><p>TLBI消息的字段到信号映射详细说明如 <em><a href="#表 a15.20">表 A15.20</a></em> 。</p><p><a id="表 a15.8">表 A15.8</a></p><table><thead><tr><th>Operation</th><th>Arm</th><th>Exception</th><th>Security</th><th>VMIDV</th><th>ASIDV</th><th>Leaf</th><th>Stage</th><th>Addr</th></tr></thead><tbody><tr><td>EL3 TLBI all</td><td>v8</td><td>0b01</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>EL3 TLBI by VA</td><td>v8</td><td>0b01</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>EL3 TLBI by VA, Leaf only</td><td>v8</td><td>0b01</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure Guest OS TLBI by Non-secure IPA</td><td>v8.4</td><td>0b10</td><td>0b01</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b10</td><td>0b1</td></tr><tr><td>Secure Guest OS TLBI by Non-secure IPA, Leaf only</td><td>v8.4</td><td>0b10</td><td>0b01</td><td>0b1</td><td>0b0</td><td>0b1</td><td>0b10</td><td>0b1</td></tr><tr><td>Secure TLBI all</td><td>v7</td><td>0b10</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Secure TLBI by VA</td><td>v7</td><td>0b10</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure TLBI by VA, Leaf only</td><td>v8</td><td>0b10</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure TLBI by ASID</td><td>v7</td><td>0b10</td><td>0b10</td><td>0b0</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Secure TLBI by ASID and VA</td><td>v7</td><td>0b10</td><td>0b10</td><td>0b0</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure TLBI by ASID and VA, Leaf only</td><td>v8</td><td>0b10</td><td>0b10</td><td>0b0</td><td>0b1</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure Guest OS TLBI all</td><td>v8.4</td><td>0b10</td><td>0b10</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Secure Guest OS TLBI by VA</td><td>v8.4</td><td>0b10</td><td>0b10</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure Guest OS TLBI all, Stage 1 only</td><td>v8.4</td><td>0b10</td><td>0b10</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b01</td><td>0b0</td></tr><tr><td>Secure Guest OS TLBI by Secure IPA</td><td>v8.4</td><td>0b10</td><td>0b10</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b10</td><td>0b1</td></tr><tr><td>Secure Guest OS TLBI by VA, Leaf only</td><td>v8.4</td><td>0b10</td><td>0b10</td><td>0b1</td><td>0b0</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure Guest OS TLBI by Secure IPA,Leaf only</td><td>v8.4</td><td>0b10</td><td>0b10</td><td>0b1</td><td>0b0</td><td>0b1</td><td>0b10</td><td>0b1</td></tr><tr><td>Secure Guest OS TLBI by ASID</td><td>v8.4</td><td>0b10</td><td>0b10</td><td>0b1</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Secure Guest OS TLBI by ASID and VA</td><td>v8.4</td><td>0b10</td><td>0b10</td><td>0b1</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure Guest OS TLBI by ASID and VA,Leaf only</td><td>v8.4</td><td>0b10</td><td>0b10</td><td>0b1</td><td>0b1</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>All OS TLBI all</td><td>v7</td><td>0b10</td><td>0b11</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Guest OS TLBI all, Stage 1 and 2</td><td>v7</td><td>0b10</td><td>0b11</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Guest OS TLBI by VA</td><td>v7</td><td>0b10</td><td>0b11</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Guest OS TLBI all, Stage 1 only</td><td>v8</td><td>0b10</td><td>0b11</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b01</td><td>0b0</td></tr><tr><td>Guest OS TLBI by IPA</td><td>v8</td><td>0b10</td><td>0b11</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b10</td><td>0b1</td></tr><tr><td>Guest OS TLBI by VA, Leaf only</td><td>v8</td><td>0b10</td><td>0b11</td><td>0b1</td><td>0b0</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Guest OS TLBI by IPA, Leaf only</td><td>v8</td><td>0b10</td><td>0b11</td><td>0b1</td><td>0b0</td><td>0b1</td><td>0b10</td><td>0b1</td></tr><tr><td>Guest OS TLBI by ASID</td><td>v7</td><td>0b10</td><td>0b11</td><td>0b1</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Guest OS TLBI by ASID and VA</td><td>v7</td><td>0b10</td><td>0b11</td><td>0b1</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Guest OS TLBI by ASID and VA, Leaf only</td><td>v8</td><td>0b10</td><td>0b11</td><td>0b1</td><td>0b1</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure Hypervisor TLBI all</td><td>v8.4</td><td>0b11</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Secure Hypervisor TLBI by VA</td><td>v8.4</td><td>0b11</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure Hypervisor TLBI by VA, Leaf only</td><td>v8.4</td><td>0b11</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure Hypervisor TLBI by ASID</td><td>v8.4</td><td>0b11</td><td>0b10</td><td>0b0</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Secure Hypervisor TLBI by ASID and VA</td><td>v8.4</td><td>0b11</td><td>0b10</td><td>0b0</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Secure Hypervisor TLBI by ASID and VA, Leaf only</td><td>v8.4</td><td>0b11</td><td>0b10</td><td>0b0</td><td>0b1</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Hypervisor TLBI all</td><td>v7</td><td>0b11</td><td>0b11</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Hypervisor TLBI by VA</td><td>v7</td><td>0b11</td><td>0b11</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Hypervisor TLBI by VA, Leaf only</td><td>v8</td><td>0b11</td><td>0b11</td><td>0b0</td><td>0b0</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Hypervisor TLBI by ASID</td><td>v8.1</td><td>0b11</td><td>0b11</td><td>0b0</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Hypervisor TLBI by ASID and VA</td><td>v8.1</td><td>0b11</td><td>0b11</td><td>0b0</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Hypervisor TLBI by ASID and VA, Leaf only</td><td>v8.1</td><td>0b11</td><td>0b11</td><td>0b0</td><td>0b1</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Realm TLBI all</td><td>v9.2</td><td>0b10</td><td>0b00</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Realm Guest OS TLBI all, Stage 1 only</td><td>v9.2</td><td>0b10</td><td>0b00</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b01</td><td>0b0</td></tr><tr><td>Realm Guest OS TLBI all, Stage 1 and 2</td><td>v9.2</td><td>0b10</td><td>0b00</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Realm Guest OS TLBI by VA</td><td>v9.2</td><td>0b10</td><td>0b00</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Realm Guest OS TLBI by VA, Leaf only</td><td>v9.2</td><td>0b10</td><td>0b00</td><td>0b1</td><td>0b0</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Realm Guest OS TLBI by ASID</td><td>v9.2</td><td>0b10</td><td>0b00</td><td>0b1</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Realm Guest OS TLBI by ASID and VA</td><td>v9.2</td><td>0b10</td><td>0b00</td><td>0b1</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Realm Guest OS TLBI by ASID and VA, Leaf only</td><td>v9.2</td><td>0b10</td><td>0b00</td><td>0b1</td><td>0b1</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Realm Guest OS TLBI by IPA</td><td>v9.2</td><td>0b10</td><td>0b00</td><td>0b1</td><td>0b0</td><td>0b0</td><td>0b10</td><td>0b1</td></tr><tr><td>Realm Guest OS TLBI by IPA, Leaf only</td><td>v9.2</td><td>0b10</td><td>0b00</td><td>0b1</td><td>0b0</td><td>0b1</td><td>0b10</td><td>0b1</td></tr><tr><td>Realm Hypervisor TLBI all</td><td>v9.2</td><td>0b11</td><td>0b00</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Realm Hypervisor TLBI by VA</td><td>v9.2</td><td>0b11</td><td>0b00</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Realm Hypervisor TLBI by VA, Leaf only</td><td>v9.2</td><td>0b11</td><td>0b00</td><td>0b0</td><td>0b0</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>Realm Hypervisor TLBI by ASID</td><td>v9.2</td><td>0b11</td><td>0b00</td><td>0b0</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b0</td></tr><tr><td>Realm Hypervisor TLBI by ASID and VA</td><td>v9.2</td><td>0b11</td><td>0b00</td><td>0b0</td><td>0b1</td><td>0b0</td><td>0b00</td><td>0b1</td></tr><tr><td>Realm Hypervisor TLBI by ASID and VA, Leaf only</td><td>v9.2</td><td>0b11</td><td>0b00</td><td>0b0</td><td>0b1</td><td>0b1</td><td>0b00</td><td>0b1</td></tr><tr><td>GPT TLBI by PA</td><td>v9.2</td><td>0b01</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b11</td><td>0b1</td></tr><tr><td>GPT TLBI by PA, Leaf only</td><td>v9.2</td><td>0b01</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b1</td><td>0b11</td><td>0b1</td></tr><tr><td>GPT TLBI all</td><td>v9.2</td><td>0b01</td><td>0b10</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b11</td><td>0b0</td></tr></tbody></table><p><strong>TLB Invalidate by Range</strong></p><p>当支持 Armv8.4 或更高版本时，如果 Range 字段为 0b1，则可以选择按 IPA 或 VA 进行 TLBI 操作。</p><p>如果出现以下情况，Range 字段必须为 0b0：</p><ul><li>不支持 Armv8.4。</li><li>消息类型不是按 IPA 或 VA 进行的 TLB 无效。</li></ul><p>当 Range 字段为 0b1 时，无效的地址范围按以下公式计算：</br></p><p><strong>BaseAddr ≤ AddressRange &lt; BaseAddr + ((Num + 1) × 2 <sup>(5×Scale+1)</sup> × TG)</strong></p><p>其中：</p><ul><li>TG 是消息中提供的事务粒度。编码见 <em><a href="#表 a15.3">表 A15.3</a></em> 。</li><li>Scale 在消息中提供，可以取 0-3 之间的任何值。</li><li>Num 在消息中提供，可以取 0-31 之间的任何值。</li><li>BaseAddr 是基于 TG 的范围的基地址：</li><li>4K：BaseAddr 是 VA[MaxVA:12]。</li><li>16K：BaseAddr 是 VA[MaxVA:14]，VA[13:12] 必须为零。</li><li>64K：BaseAddr 是 VA[MaxVA:16]，VA[15:12] 必须为零。</li></ul><p>按范围的 TLBI 是带有字段映射的两部分消息，如 <em><a href="#表 a15.20">表 A15.20</a></em> 所述。</p><p><strong>GPT TLB Invalidate</strong></p><p>按 PA 操作的粒度保护表 (GPT) TLBI 执行基于范围的无效操作，
并使从 PA 开始的 TLB 条目在无效大小 (IS) 字段中指定的范围内无效。编码见表 <em><a href="#表 a15.3">表 A15.3</a></em> 。</p><p>如果 PA 未与 IS 值对齐，则不需要使任何 TLB 条目无效。</p><p>IS 字段仅适用于 GPT 按 PA 操作的 TLBI。</p><ul><li><p>使用设为 0b0 的 Range 字段，通过一部分消息发出 GPT TLBI 所有消息。</p></li><li><p>使用设为 0b1 的 Range 字段，通过两部分消息发出 GPT 按 PA 消息。</p></li><li><p>GPT TLBI 消息的字段信号映射见表 <em><a href="#表 a15.20">表 A15.20</a></em> 。</p></li></ul><h5 id=a-ida1533-分支预测失效消息a1533-分支预测失效消息a><a id="a15.3.3 分支预测失效消息">A15.3.3 分支预测失效消息</a></h5><p>分支预测器无效 (BPI) 消息用于使分支预测器中的虚拟地址无效。</p><p>BPI 消息使用一部分或两部分消息进行信号传输，其字段信号映射详见 <em><a href="#表 a15.21">表 A15.21</a></em> 。</p><p>BPI消息的固定字段值如 <em><a href="#表 a15.9">表 A15.9</a></em> 所示</p><p><em><a href="#表 a15.9">表 A15.9</a></em> 固定字段值的BPI消息</p><table><thead><tr><th>字段名</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>DVMType</td><td>0b001</td><td>Branch Predictor Invalidate opcode</td></tr><tr><td>Completion</td><td>0b0</td><td>Completion not required</td></tr><tr><td>Range</td><td>0b0</td><td>Address is not a range</td></tr><tr><td>VMIDV</td><td>0b0</td><td>VMID field not valid</td></tr><tr><td>ASIDV</td><td>0b0</td><td>ASID field not valid</td></tr><tr><td>Exception</td><td>0b00</td><td>Hypervisor and all Guest OS</td></tr><tr><td>Security</td><td>0b00</td><td>Secure and Non-secure</td></tr><tr><td>Leaf</td><td>0b0</td><td>Leaf information is N/A</td></tr><tr><td>Stage</td><td>0b00</td><td>Stage information is N/A</td></tr></tbody></table><p>所有支持的BPI操作显示在 <em><a href="#表 a15.10">表 A15.10</a></em> 中。</p><p>Arm栏表示支持该消息所需的最低Arm架构版本。</p><p><a id="表 a15.10">表 A15.10</a> BPI消息</p><table><thead><tr><th>操作</th><th>Arm</th><th>Addr</th></tr></thead><tbody><tr><td>BPI All</td><td>v7</td><td>0b0</td></tr><tr><td>BPI by VA</td><td>v7</td><td>0b1</td></tr></tbody></table><h5 id=a-ida1534a1534a-指令缓存无效><a id=a15.3.4>A15.3.4</a> 指令缓存无效</h5><p>指令缓存可以使用物理地址或虚拟地址来标记其包含的数据。一个系统可能包含这两种形式的缓存的混合体。</p><p>DVM协议包括使用物理地址的指令缓存失效操作和使用虚拟地址的操作。
接收DVM消息的组件必须支持这两种形式的消息，与所实现的指令缓存类型无关。</p><p>在接收到一种非缓存类型原生格式的消息时，可能需要进行过度失效。</p><p><strong>Physical Instruction Cache Invalidate（PICI）</strong></p><p>本节列出了DVM消息支持的物理指令缓存失效（PICI）操作。
此消息类型也用于虚拟索引物理标记（VIPT）的指令缓存。</p><p>使用一部分或两部分消息来发出PICI消息，
信号到字段的映射详见 <em><a href="#表 a15.22">表 A15.22</a></em> 。
PICI消息的固定字段值显示在 <em><a href="#表 a15.11">表 A15.11</a></em> .</p><p><a id="表 a15.11">表 A15.11</a> 固定字段值的PICI消息</p><table><thead><tr><th>字段名</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>DVMType</td><td>0b010</td><td>Physical Instruction Cache Invalidate opcode</td></tr><tr><td>Completion</td><td>0b0</td><td>Completion not required</td></tr><tr><td>Range</td><td>0b0</td><td>Address is not a range</td></tr><tr><td>Exception</td><td>0b00</td><td>Hypervisor and all Guest OS</td></tr><tr><td>Leaf</td><td>0b0</td><td>Leaf information is N/A</td></tr><tr><td>Stage</td><td>0b00</td><td>Stage information is N/A</td></tr></tbody></table><p>所有支持的PICI操作见 <em><a href="#表 a15.12">表 A15.12</a></em> 。</p><p><a id="表 a15.12">表 A15.12</a> PICI消息</p><table><thead><tr><th>Operation</th><th>Arm</th><th>Security</th><th>VIV</th><th>Addr</th></tr></thead><tbody><tr><td>PICI all Root, Realm, Secure and Non-secure</td><td>v9.2</td><td>0b00</td><td>0b00</td><td>0b0</td></tr><tr><td>PICI by PA without Virtual Index, Root only</td><td>v9.2</td><td>0b00</td><td>0b00</td><td>0b1</td></tr><tr><td>PICI by PA with Virtual Index, Root only</td><td>v9.2</td><td>0b00</td><td>0b11</td><td>0b1</td></tr><tr><td>PICI all Realm and Non-secure</td><td>v9.2</td><td>0b01</td><td>0b00</td><td>0b0</td></tr><tr><td>PICI by PA without Virtual Index, Realm only</td><td>v9.2</td><td>0b01</td><td>0b00</td><td>0b1</td></tr><tr><td>PICI by PA with Virtual Index, Realm only</td><td>v9.2</td><td>0b01</td><td>0b11</td><td>0b1</td></tr><tr><td>PICI all Secure and Non-secure</td><td>v7</td><td>0b10</td><td>0b00</td><td>0b0</td></tr><tr><td>PICI by PA without Virtual Index, Secure only</td><td>v7</td><td>0b10</td><td>0b00</td><td>0b1</td></tr><tr><td>PICI by PA with Virtual Index, Secure only</td><td>v7</td><td>0b10</td><td>0b11</td><td>0b1</td></tr><tr><td>PICI all, Non-secure only</td><td>v7</td><td>0b11</td><td>0b00</td><td>0b0</td></tr><tr><td>PICI by PA without Virtual Index, Non-secure only</td><td>v7</td><td>0b11</td><td>0b00</td><td>0b1</td></tr><tr><td>PICI by PA with Virtual Index, Non-secure only</td><td>v7</td><td>0b11</td><td>0b11</td><td>0b1</td></tr></tbody></table><p>当虚拟索引有效（VIV）字段为0b11时，VI[27:12]被用作物理地址的一部分。</p><blockquote><p>Note：</br>在本规范的以前版本中，具有0b10安全值的PICI被错误地标记为仅安全，而实际上它应该是安全和非安全的。</p></blockquote><p><strong>Virtual Instruction Cache Invalidate（VICI）</strong></p><p>本节列出了DVM消息支持的虚拟指令缓存失效（VICI）操作。</p><p>VICI消息通过一部分或两部分消息进行信号传递，其字段到信号的映射详细信息见 <em><a href="#表 a15.22">表 A15.22</a></em> 。</p><p>VICI消息的固定字段值如 <em><a href="#表 a15.13">表 A15.13</a></em> 所示。</p><p><a id="表 a15.13">表 A15.13</a> 固定字段值的VICI消息</p><table><thead><tr><th>字段名</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>DVMType</td><td>0b011</td><td>Virtual Instruction Cache Invalidate opcode</td></tr><tr><td>Completion</td><td>0b0</td><td>Completion not required</td></tr><tr><td>Range</td><td>0b0</td><td>Address is not a range</td></tr><tr><td>Leaf</td><td>0b0</td><td>Leaf information is N/A</td></tr><tr><td>Stage</td><td>0b00</td><td>Stage information is N/A</td></tr></tbody></table><p>所有支持的VICI操作如 <em><a href="#表 a15.14">表 A15.14</a></em> 所示。</p><p>Arm列表示支持该消息所需的最低Arm架构版本。</p><p><a id="表 a15.14">表 A15.14</a> VICI消息</p><table><thead><tr><th>Operation</th><th>Arm</th><th>Exception</th><th>Security</th><th>VMIDV</th><th>ASIDV</th><th>Addr</th></tr></thead><tbody><tr><td>Hypervisor and all Guest OS VICI all, Secure and Non-secure</td><td>v7</td><td>0b00</td><td>0b00</td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td>Hypervisor and all Guest OS VICI all, Non-secure only</td><td>v7</td><td>0b00</td><td>0b11</td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td>All Guest OS VICI by ASID and VA, Secure only</td><td>v7</td><td>0b10</td><td>0b10</td><td>0b0</td><td>0b1</td><td>0b1</td></tr><tr><td>All Guest OS VICI by VMID, Secure only</td><td>v8.4</td><td>0b10</td><td>0b10</td><td>0b1</td><td>0b0</td><td>0b0</td></tr><tr><td>All Guest OS VICI by ASID, VA and VMID, Secure only</td><td>v8.4</td><td>0b10</td><td>0b10</td><td>0b1</td><td>0b1</td><td>0b1</td></tr><tr><td>All Guest OS VICI by VMID, Non-secure only</td><td>v7</td><td>0b10</td><td>0b11</td><td>0b1</td><td>0b0</td><td>0b0</td></tr><tr><td>All Guest OS VICI by ASID, VA and VMID, Non-secure only</td><td>v7</td><td>0b10</td><td>0b11</td><td>0b1</td><td>0b1</td><td>0b1</td></tr><tr><td>Hypervisor VICI by VA, Non-secure only</td><td>v7</td><td>0b11</td><td>0b11</td><td>0b0</td><td>0b0</td><td>0b1</td></tr><tr><td>Hypervisor VICI by ASID and VA, Non-secure only</td><td>v8.1</td><td>0b11</td><td>0b11</td><td>0b0</td><td>0b1</td><td>0b1</td></tr></tbody></table><h5 id=a-ida1535a1535a-同步消息><a id=a15.3.5>A15.3.5</a> 同步消息</h5><p>同步(Sync)消息用于请求者需要知道所有先前的失效操作何时完成。
有关如何使用同步消息的更多信息，请参见 <em><a href="#a15.5 dvm同步与完成">A15.5 DVM同步与完成</a></em> 。</p><p>同步消息使用一部分消息进行信号传递，字段到信号的映射详见 <em><a href="#表 a15.21">表 A15.21</a></em> 。同步消息的固定字段值如下所示</p><p><a id="表 a15.15">表 A15.15</a> 固定字段值的同步消息</p><table><thead><tr><th>字段名</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>DVMType</td><td>0b100</td><td>Sync opcode</td></tr><tr><td>Completion</td><td>0b1</td><td>Completion required</td></tr><tr><td>ASIDV</td><td>0b0</td><td>No ASID information</td></tr><tr><td>VMIDV</td><td>0b0</td><td>No VMID information</td></tr><tr><td>Addr</td><td>0b0</td><td>No address information</td></tr><tr><td>Range</td><td>0b0</td><td>No address range</td></tr><tr><td>Exception</td><td>0b00</td><td>Exception information is N/A</td></tr><tr><td>Security</td><td>0b00</td><td>Security information is N/A</td></tr><tr><td>Leaf</td><td>0b0</td><td>Leaf information is N/A</td></tr><tr><td>Stage</td><td>0b00</td><td>Stage information is N/A</td></tr></tbody></table><h5 id=a-ida1536-提示消息a1536-提示消息a><a id="a15.3.6 提示消息">A15.3.6 提示消息</a></h5><p>为未来提示消息预留了一个消息地址空间。</p><p>提示消息的固定字段值显示在 <em><a href="#表 a15.16">表 A15.16</a></em> 。</p><p><a id="表 a15.16">表 A15.16</a> 固定字段值的提示消息</p><table><thead><tr><th>字段名</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>DVMType</td><td>0b110</td><td>Hint opcode</td></tr><tr><td>Completion</td><td>0b0</td><td>Completion not required</td></tr></tbody></table><h4 id=a-ida154-dvm消息传输a154-dvm消息传输a><a id="a15.4 dvm消息传输">A15.4 DVM消息传输</a></h4><p>DVM 消息事务包括在侦听请求（AC）通道上的一个请求传输和在侦听响应（CR）通道上的一个响应。</p><p>每条消息可以有一到两个事务，第一条请求中的 Addr 字段指示是否需要另一个事务。</p><p>不包括地址的 DVM 消息通过一个事务发送。</p><p>包括地址的 DVM 消息通过两个事务发送。</p><p>通常使用互连来复制和分发给参与管理组件的 DVM 消息请求。
主机可以使用一致性连接信号在运行时选择接收消息，详见 <em><a href="#a15.6 一致性连接信号">A15.6 一致性连接信号</a></em> 。</p><p>单部分和双部分消息的流程如 <em><a href="#图 a15.1">图 A15.1</a></em> 所示。</p><p><a id="图 a15.1">图 A15.1
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A15.1_DVM_message_flows.png alt></a></p><p>以下规则适用于两部分的DVM消息</p><ul><li>请求总是作为连续传输发送，中间没有其他消息请求。</li><li>发出两部分DVM消息的组件必须能够在不需要对消息的第一部分进行响应的情况下发出消息的第二部分。</li></ul><h5 id=a-ida1541-dvm消息信号a1541-dvm消息信号a><a id="a15.4.1 dvm消息信号">A15.4.1 DVM消息信号</a></h5><p>从从机到主机的侦听请求通道上传输一个DVM请求。
<em><a href="#表 a15.17">表 A15.17</a></em> 显示了侦听请求通道的信号。</p><p><a id="表 a15.17">表 A15.17</a> 侦听请求通道</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>ACVALID</strong></td><td>1</td><td>−</td><td>断言为高表明AC通道上的信号有效。</td></tr><tr><td><strong>ACREADY</strong></td><td>1</td><td>−</td><td>断言为高表明AC通道可以接受传输。</td></tr><tr><td><strong>ACADDR</strong></td><td>ADDR_WIDTH</td><td>−</td><td>用于DVM信息请求的地址。</td></tr><tr><td><strong>ACVMIDEXT</strong></td><td>4</td><td>−</td><td>扩展以支持DVM消息中的16位VMID。</td></tr><tr><td><strong>ACTRACE</strong></td><td>1</td><td>−</td><td>侦听请求通道上的跟踪信号。</td></tr></tbody></table><p>对DVM请求的响应通过从主机到从机的侦听响应通道传输。
<em><a href="#表 a15.18">表 A15.18</a></em> 显示了构成窥探响应通道的信号。</p><p><a id="表 a15.18">表 A15.18</a> 侦听响应通道</p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>CRVALID</strong></td><td>1</td><td>−</td><td>断言为高表明CR通道上的信号有效。</td></tr><tr><td><strong>CRREADY</strong></td><td>1</td><td>−</td><td>断言为高表明CR通道接受一个传输。</td></tr><tr><td><strong>CRTRACE</strong></td><td>1</td><td>−</td><td>侦听响应通道上的跟踪信号。</td></tr></tbody></table><p>DVM响应表示请求已被接收，但不表示DVM消息的成功或失败。
AC或CR通道不支持重新排序，因此响应与AC请求发出的顺序相同。</p><p><strong>ACTRACE</strong>和<strong>CRTRACE</strong>信号的作用与其他通道上的跟踪信号相同，
详见 <em><a href="#a13.3 跟踪信号">A13.3 跟踪信号</a></em> 。</p><blockquote><p>Note：</br>该规范的早期版本包含一个侦听响应指示器CRRESP，以指示错误响应。
由于使用不广泛，作为简化规范的一部分，现已弃用。</p></blockquote><p><strong>Rules for snoop channels</strong></p><p>侦听通道信号的规则与其他通道相似：</p><ul><li>只有在存在有效的地址和控制信息时，从机才应断言ACVALID。</li><li>当<strong>ACVALID</strong>被断言时，必须保持断言状态，直到主机断言ACREADY信号后的上升沿。</li><li><strong>CRVALID</strong>被断言以表示主机已确认DVM消息。</li><li>当<strong>CRVALID</strong>被断言时，必须保持断言状态，直到从机断言CRREADY信号后的上升沿。</li></ul><p>侦听请求和响应通道之间的依赖关系规则列示如下，并在 <em><a href="#图 a15.2">图 A15.2</a></em> 中进行了说明。</p><ul><li>从机在断言<strong>ACVALID</strong>之前，不应等待主机断言<strong>ACREADY</strong>。</li><li>主机可以在断言<strong>ACREADY</strong>之前等待<strong>ACVALID</strong>断言。</li><li>主机可以在<strong>ACVALID</strong>断言之前断言<strong>ACREADY</strong>。</li><li>主机必须在<strong>ACVALID</strong>和<strong>ACREADY</strong>都被断言之前等待，
然后才断言<strong>CRVALID</strong>以表示有效响应可用。</li><li>主机不能等待从机断言<strong>CRREADY</strong>后才断言<strong>CRVALID</strong>。</li><li>从机可以在<strong>CRVALID</strong>被断言之前等待断言<strong>CRREADY</strong>。</li><li>从机可以在<strong>CRVALID</strong>被断言之前断言<strong>CRREADY</strong>。</li></ul><p><a id="图 a15.2">图 A15.2
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A15.2_Snoop_transaction_handshake_dependencies.png alt></a></p><h5 id=a-ida1542-dvm消息的地址位宽a1542-dvm消息的地址位宽a><a id="a15.4.2 dvm消息的地址位宽">A15.4.2 DVM消息的地址位宽</a></h5><p>属性ADDR_WIDTH用于指定<strong>ARADDR</strong>、<strong>AWADDR</strong>和<strong>ACADDR</strong>的宽度。这将设置接口使用的物理地址宽度。</p><p><strong>ACADDR</strong>信号也用于传输虚拟地址（VA），
因此所需的VA宽度也对ADDR_WIDTH设置了最小限制。
<em><a href="#表 a15.19">表 A15.19</a></em> 显示了一些常见的VA宽度和所需的最小ADDR_WIDTH。</p><p><a id="表 a15.19">表 A15.19</a> 常见的VA宽度和最小ADDR_WIDTH</p><table><thead><tr><th>VA位宽</th><th>最小的ADDR_WIDTH</th></tr></thead><tbody><tr><td>32</td><td>32</td></tr><tr><td>41</td><td>40</td></tr><tr><td>49</td><td>44</td></tr><tr><td>53</td><td>48</td></tr><tr><td>57</td><td>48</td></tr></tbody></table><p>VA宽度超过57位不被支持。</p><p>如果PA宽度超过VA宽度，则虚拟地址操作可能会在DVM消息中接收到额外的地址信息。
在这种情况下任何额外的地址信息必须被忽略并且操作必须仅使用支持的地址位。</p><p>如果一个组件支持比其PA宽度更大的VA宽度那么组件必须对额外的物理地址位采取适当的措施。
关于不匹配的地址宽度的更多细节请参见 <em><a href="#a4.1.5 传输地址">A4.1.5 传输地址</a></em></p><h5 id=a-ida1543-消息字段到信号的映射a1543-消息字段到信号的映射a><a id="a15.4.3 消息字段到信号的映射">A15.4.3 消息字段到信号的映射</a></h5><p>DVM消息中的字段是使用<strong>ACADDR</strong>和<strong>ACVMIDEXT</strong>信号的比特传输的。</p><p>不同消息类型有不同的映射，如 <em><a href="#表 a15.20">表 A15.20</a></em> 所示。
比特位置分配可能看起来不规则，但用于简化不同地址宽度实现之间的转换。</p><p>对于Hint消息，Completion（0b0）和DVMType（0b110）字段分别位于<strong>ACADDR[15]</strong>和<strong>ACADDR[14:12]</strong>。
其他映射是实现定义的。TLB Invalidate消息的映射如 <em><a href="#表 a15.20">表 A15.20</a></em> 所示。</p><p><a id="表 a15.20">表 A15.20</a> TLB失效信息的字段映射</p><table><thead><tr><th>Signal</th><th>TLBI 1-part</th><th>TLBI 1st of 2-part</th><th>TLBI 2nd part by VA</th><th>TLBI 2nd part by range</th><th>GPT TLBI 1st part</th><th>GPT TLBI 2nd part</th></tr></thead><tbody><tr><td><strong>ACADDR[51]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>PA[51]</td></tr><tr><td><strong>ACADDR[50]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>PA[50]</td></tr><tr><td><strong>ACADDR[49]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>PA[49]</td></tr><tr><td><strong>ACADDR[48]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>PA[48]</td></tr><tr><td><strong>ACADDR[47]</strong></td><td>0b0</td><td>VA[56]</td><td>VA[52]</td><td>VA[52]</td><td>0b0</td><td>PA[47]</td></tr><tr><td><strong>ACADDR[46]</strong></td><td>0b0</td><td>VA[55]</td><td>VA[51]</td><td>VA[51]</td><td>0b0</td><td>PA[46]</td></tr><tr><td><strong>ACADDR[45]</strong></td><td>0b0</td><td>VA[54]</td><td>VA[50]</td><td>VA[50]</td><td>0b0</td><td>PA[45]</td></tr><tr><td><strong>ACADDR[44]</strong></td><td>0b0</td><td>VA[53]</td><td>VA[49]</td><td>VA[49]</td><td>0b0</td><td>PA[44]</td></tr><tr><td><strong>ACADDR[43]</strong></td><td>VMID[15]</td><td>VA[48]</td><td>VA[44]</td><td>VA[44]</td><td>0b0</td><td>PA[43]</td></tr><tr><td><strong>ACADDR[42]</strong></td><td>VMID[14]</td><td>VA[47]</td><td>VA[43]</td><td>VA[43]</td><td>0b0</td><td>PA[42]</td></tr><tr><td><strong>ACADDR[41]</strong></td><td>VMID[13]</td><td>VA[46]</td><td>VA[42]</td><td>VA[42]</td><td>0b0</td><td>PA[41]</td></tr><tr><td><strong>ACADDR[40]</strong></td><td>VMID[12]</td><td>VA[45]</td><td>VA[41]</td><td>VA[41]</td><td>0b0</td><td>PA[40]</td></tr><tr><td><strong>ACADDR[39]</strong></td><td>ASID[15]</td><td>ASID[15]</td><td>VA[39]</td><td>VA[39]</td><td>0b0</td><td>PA[39]</td></tr><tr><td><strong>ACADDR[38]</strong></td><td>ASID[14]</td><td>ASID[14]</td><td>VA[38]</td><td>VA[38]</td><td>0b0</td><td>PA[38]</td></tr><tr><td><strong>ACADDR[37]</strong></td><td>ASID[13]</td><td>ASID[13]</td><td>VA[37]</td><td>VA[37]</td><td>0b0</td><td>PA[37]</td></tr><tr><td><strong>ACADDR[36]</strong></td><td>ASID[12]</td><td>ASID[12]</td><td>VA[36]</td><td>VA[36]</td><td>0b0</td><td>PA[36]</td></tr><tr><td><strong>ACADDR[35]</strong></td><td>ASID[11]</td><td>ASID[11]</td><td>VA[35]</td><td>VA[35]</td><td>0b0</td><td>PA[35]</td></tr><tr><td><strong>ACADDR[34]</strong></td><td>ASID[10]</td><td>ASID[10]</td><td>VA[34]</td><td>VA[34]</td><td>0b0</td><td>PA[34]</td></tr><tr><td><strong>ACADDR[33]</strong></td><td>ASID[9]</td><td>ASID[9]</td><td>VA[33]</td><td>VA[33]</td><td>0b0</td><td>PA[33]</td></tr><tr><td><strong>ACADDR[32]</strong></td><td>ASID[8]</td><td>ASID[8]</td><td>VA[32]</td><td>VA[32]</td><td>0b0</td><td>PA[32]</td></tr><tr><td><strong>ACADDR[31]</strong></td><td>VMID[7]</td><td>VMID[7]</td><td>VA[31]</td><td>VA[31]</td><td>0b0</td><td>PA[31]</td></tr><tr><td><strong>ACADDR[30]</strong></td><td>VMID[6]</td><td>VMID[6]</td><td>VA[30]</td><td>VA[30]</td><td>0b0</td><td>PA[30]</td></tr><tr><td><strong>ACADDR[29]</strong></td><td>VMID[5]</td><td>VMID[5]</td><td>VA[29]</td><td>VA[29]</td><td>0b0</td><td>PA[29]</td></tr><tr><td><strong>ACADDR[28]</strong></td><td>VMID[4]</td><td>VMID[4]</td><td>VA[28]</td><td>VA[28]</td><td>0b0</td><td>PA[28]</td></tr><tr><td><strong>ACADDR[27]</strong></td><td>VMID[3]</td><td>VMID[3]</td><td>VA[27]</td><td>VA[27]</td><td>0b0</td><td>PA[27]</td></tr><tr><td><strong>ACADDR[26]</strong></td><td>VMID[2]</td><td>VMID[2]</td><td>VA[26]</td><td>VA[26]</td><td>0b0</td><td>PA[26]</td></tr><tr><td><strong>ACADDR[25]</strong></td><td>VMID[1]</td><td>VMID[1]</td><td>VA[25]</td><td>VA[25]</td><td>0b0</td><td>PA[25]</td></tr><tr><td><strong>ACADDR[24]</strong></td><td>VMID[0]</td><td>VMID[0]</td><td>VA[24]</td><td>VA[24]</td><td>0b0</td><td>PA[24]</td></tr><tr><td><strong>ACADDR[23]</strong></td><td>ASID[7]</td><td>ASID[7]</td><td>VA[23]</td><td>VA[23]</td><td>0b0</td><td>PA[23]</td></tr><tr><td><strong>ACADDR[22]</strong></td><td>ASID[6]</td><td>ASID[6]</td><td>VA[22]</td><td>VA[22]</td><td>0b0</td><td>PA[22]</td></tr><tr><td><strong>ACADDR[21]</strong></td><td>ASID[5]</td><td>ASID[5]</td><td>VA[21]</td><td>VA[21]</td><td>0b0</td><td>PA[21]</td></tr><tr><td><strong>ACADDR[20]</strong></td><td>ASID[4]</td><td>ASID[4]</td><td>VA[20]</td><td>VA[20]</td><td>0b0</td><td>PA[20]</td></tr><tr><td><strong>ACADDR[19]</strong></td><td>ASID[3]</td><td>ASID[3]</td><td>VA[19]</td><td>VA[19]</td><td>0b0</td><td>PA[19]</td></tr><tr><td><strong>ACADDR[18]</strong></td><td>ASID[2]</td><td>ASID[2]</td><td>VA[18]</td><td>VA[18]</td><td>0b0</td><td>PA[18]</td></tr><tr><td><strong>ACADDR[17]</strong></td><td>ASID[1]</td><td>ASID[1]</td><td>VA[17]</td><td>VA[17]</td><td>0b0</td><td>PA[17]</td></tr><tr><td><strong>ACADDR[16]</strong></td><td>ASID[0]</td><td>ASID[0]</td><td>VA[16]</td><td>VA[16]</td><td>0b0</td><td>PA[16]</td></tr><tr><td><strong>ACADDR[15]</strong></td><td>0b0(Completion)</td><td>0b0(Completion)</td><td>VA[15]</td><td>VA[15]</td><td>0b0(Completion)</td><td>PA[15]</td></tr><tr><td><strong>ACADDR[14]</strong></td><td>0b0(DVMType[2])</td><td>0b0(DVMType[2])</td><td>VA[14]</td><td>VA[14]</td><td>0b0(DVMType[2])</td><td>PA[14]</td></tr><tr><td><strong>ACADDR[13]</strong></td><td>0b0(DVMType[1])</td><td>0b0(DVMType[1])</td><td>VA[13]</td><td>VA[13]</td><td>0b0(DVMType[1])</td><td>PA[13]</td></tr><tr><td><strong>ACADDR[12]</strong></td><td>0b0(DVMType[0])</td><td>0b0(DVMType[0])</td><td>VA[12]</td><td>VA[12]</td><td>0b0(DVMType[0])</td><td>PA[12]</td></tr><tr><td><strong>ACADDR[11]</strong></td><td>Exception[1]</td><td>Exception[1]</td><td>TG[1]</td><td>TG[1]</td><td>Exception[1]</td><td>IS[3]</td></tr><tr><td><strong>ACADDR[10]</strong></td><td>Exception[0]</td><td>Exception[0]</td><td>TG[0]</td><td>TG[0]</td><td>Exception[0]</td><td>IS[2]</td></tr><tr><td><strong>ACADDR[9]</strong></td><td>Security[1]</td><td>Security[1]</td><td>TTL[1]</td><td>TTL[1]</td><td>Security[1]</td><td>IS[1]</td></tr><tr><td><strong>ACADDR[8]</strong></td><td>Security[0]</td><td>Security[0]</td><td>TTL[0]</td><td>TTL[0]</td><td>Security[0]</td><td>IS[0]</td></tr><tr><td><strong>ACADDR[7]</strong></td><td>0b0 (Range)</td><td>Range</td><td>0b0</td><td>Scale[1]</td><td>Range</td><td>0b0</td></tr><tr><td><strong>ACADDR[6]</strong></td><td>VMIDV</td><td>VMIDV</td><td>0b0</td><td>Scale[0]</td><td>0b0(VMIDV)</td><td>0b0</td></tr><tr><td><strong>ACADDR[5]</strong></td><td>ASIDV</td><td>ASIDV</td><td>0b0</td><td>Num[4]</td><td>0b0 (ASIDV)</td><td>0b0</td></tr><tr><td><strong>ACADDR[4]</strong></td><td>Leaf</td><td>Leaf</td><td>0b0</td><td>Num[3]</td><td>Leaf</td><td>0b0</td></tr><tr><td><strong>ACADDR[3]</strong></td><td>Stage[1]</td><td>Stage[1]</td><td>VA[40]</td><td>VA[40]</td><td>Stage[1]</td><td>0b0</td></tr><tr><td><strong>ACADDR[2]</strong></td><td>Stage[0]</td><td>Stage[0]</td><td>0b0</td><td>Num[2]</td><td>Stage[0]</td><td>0b0</td></tr><tr><td><strong>ACADDR[1]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td><td>Num[1]</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACADDR[0]</strong></td><td>0b0 (Addr)</td><td>0b1 (Addr)</td><td>0b0</td><td>Num[0]</td><td>Addr</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[3]</strong></td><td>VMID[11]</td><td>VMID[11]</td><td>VMID[15]</td><td>VMID[15]</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[2]</strong></td><td>VMID[10]</td><td>VMID[10]</td><td>VMID[14]</td><td>VMID[14]</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[1]</strong></td><td>VMID[9]</td><td>VMID[9]</td><td>VMID[13]</td><td>VMID[13]</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[0]</strong></td><td>VMID[8]</td><td>VMID[8]</td><td>VMID[12]</td><td>VMID[12]</td><td>0b0</td><td>0b0</td></tr></tbody></table><p>分支预测器无效和同步消息的映射如 <em><a href="#表 a15.21">表 A15.21</a></em> 所示.</p><p><a id="表 a15.21">表 A15.21</a> BPI和Sync消息的字段映射</p><table><thead><tr><th>Signal</th><th>BPI all or Sync</th><th>BPI by VA 1st part</th><th>BPI by VA 2nd part</th></tr></thead><tbody><tr><td><strong>ACADDR[51]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACADDR[50]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACADDR[49]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACADDR[48]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACADDR[47]</strong></td><td>0b0</td><td>VA[56]</td><td>VA[52]</td></tr><tr><td><strong>ACADDR[46]</strong></td><td>0b0</td><td>VA[55]</td><td>VA[51]</td></tr><tr><td><strong>ACADDR[45]</strong></td><td>0b0</td><td>VA[54]</td><td>VA[50]</td></tr><tr><td><strong>ACADDR[44]</strong></td><td>0b0</td><td>VA[53]</td><td>VA[49]</td></tr><tr><td><strong>ACADDR[43]</strong></td><td>0b0</td><td>VA[48]</td><td>VA[44]</td></tr><tr><td><strong>ACADDR[42]</strong></td><td>0b0</td><td>VA[47]</td><td>VA[43]</td></tr><tr><td><strong>ACADDR[41]</strong></td><td>0b0</td><td>VA[46]</td><td>VA[42]</td></tr><tr><td><strong>ACADDR[40]</strong></td><td>0b0</td><td>VA[45]</td><td>VA[41]</td></tr><tr><td><strong>ACADDR[39]</strong></td><td>0b0</td><td>0b0</td><td>VA[39]</td></tr><tr><td><strong>ACADDR[38]</strong></td><td>0b0</td><td>0b0</td><td>VA[38]</td></tr><tr><td><strong>ACADDR[37]</strong></td><td>0b0</td><td>0b0</td><td>VA[37]</td></tr><tr><td><strong>ACADDR[36]</strong></td><td>0b0</td><td>0b0</td><td>VA[36]</td></tr><tr><td><strong>ACADDR[35]</strong></td><td>0b0</td><td>0b0</td><td>VA[35]</td></tr><tr><td><strong>ACADDR[34]</strong></td><td>0b0</td><td>0b0</td><td>VA[34]</td></tr><tr><td><strong>ACADDR[33]</strong></td><td>0b0</td><td>0b0</td><td>VA[33]</td></tr><tr><td><strong>ACADDR[32]</strong></td><td>0b0</td><td>0b0</td><td>VA[32]</td></tr><tr><td><strong>ACADDR[31]</strong></td><td>0b0</td><td>0b0</td><td>VA[31]</td></tr><tr><td><strong>ACADDR[30]</strong></td><td>0b0</td><td>0b0</td><td>VA[30]</td></tr><tr><td><strong>ACADDR[29]</strong></td><td>0b0</td><td>0b0</td><td>VA[29]</td></tr><tr><td><strong>ACADDR[28]</strong></td><td>0b0</td><td>0b0</td><td>VA[28]</td></tr><tr><td><strong>ACADDR[27]</strong></td><td>0b0</td><td>0b0</td><td>VA[27]</td></tr><tr><td><strong>ACADDR[26]</strong></td><td>0b0</td><td>0b0</td><td>VA[26]</td></tr><tr><td><strong>ACADDR[25]</strong></td><td>0b0</td><td>0b0</td><td>VA[25]</td></tr><tr><td><strong>ACADDR[24]</strong></td><td>0b0</td><td>0b0</td><td>VA[24]</td></tr><tr><td><strong>ACADDR[23]</strong></td><td>0b0</td><td>0b0</td><td>VA[23]</td></tr><tr><td><strong>ACADDR[22]</strong></td><td>0b0</td><td>0b0</td><td>VA[22]</td></tr><tr><td><strong>ACADDR[21]</strong></td><td>0b0</td><td>0b0</td><td>VA[21]</td></tr><tr><td><strong>ACADDR[20]</strong></td><td>0b0</td><td>0b0</td><td>VA[20]</td></tr><tr><td><strong>ACADDR[19]</strong></td><td>0b0</td><td>0b0</td><td>VA[19]</td></tr><tr><td><strong>ACADDR[18]</strong></td><td>0b0</td><td>0b0</td><td>VA[18]</td></tr><tr><td><strong>ACADDR[17]</strong></td><td>0b0</td><td>0b0</td><td>VA[17]</td></tr><tr><td><strong>ACADDR[16]</strong></td><td>0b0</td><td>0b0</td><td>VA[16]</td></tr><tr><td><strong>ACADDR[15]</strong></td><td>Completion</td><td>0b0 (Completion)</td><td>VA[15]</td></tr><tr><td><strong>ACADDR[14]</strong></td><td>DVMType[2]</td><td>0b0 (DVMType[2])</td><td>VA[14]</td></tr><tr><td><strong>ACADDR[13]</strong></td><td>DVMType[1]</td><td>0b0 (DVMType[1])</td><td>VA[13]</td></tr><tr><td><strong>ACADDR[12]</strong></td><td>DVMType[0]</td><td>0b1 (DVMType[0])</td><td>VA[12]</td></tr><tr><td><strong>ACADDR[11]</strong></td><td>0b0 (Exception[1])</td><td>0b0 (Exception[1])</td><td>VA[11]</td></tr><tr><td><strong>ACADDR[10]</strong></td><td>0b0 (Exception[0])</td><td>0b0 (Exception[0])</td><td>VA[10]</td></tr><tr><td><strong>ACADDR[9]</strong></td><td>0b0 (Security[1])</td><td>0b0 (Security[1])</td><td>VA[9]</td></tr><tr><td><strong>ACADDR[8]</strong></td><td>0b0 (Security[0])</td><td>0b0 (Security[0])</td><td>VA[8]</td></tr><tr><td><strong>ACADDR[7]</strong></td><td>0b0 (Range)</td><td>0b0 (Range)</td><td>VA[7]</td></tr><tr><td><strong>ACADDR[6]</strong></td><td>0b0 (VMIDV)</td><td>0b0 (VMIDV)</td><td>VA[6]</td></tr><tr><td><strong>ACADDR[5]</strong></td><td>0b0 (ASIDV)</td><td>0b0 (ASIDV)</td><td>VA[5]</td></tr><tr><td><strong>ACADDR[4]</strong></td><td>0b0 (Leaf)</td><td>0b0 (Leaf)</td><td>VA[4]</td></tr><tr><td><strong>ACADDR[3]</strong></td><td>0b0 (Stage[1])</td><td>0b0 (Stage[1])</td><td>VA[40]</td></tr><tr><td><strong>ACADDR[2]</strong></td><td>0b0 (Stage[0])</td><td>0b0 (Stage[0])</td><td>0b0</td></tr><tr><td><strong>ACADDR[1]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACADDR[0]</strong></td><td>0b0 (Addr)</td><td>0b1 (Addr)</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[3]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[2]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[1]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[0]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td></tr></tbody></table><p>指令缓存失效消息的映射见 <em><a href="#表 a15.22">表 A15.22</a></em> 。</p><p><a id="表 a15.22">表 A15.22</a> |VICI和PICI消息的字段映射</p><table><thead><tr><th>Signal</th><th>VICI all</th><th>VICI by VA 1st part</th><th>VICI by VA 2nd part</th><th>PICI 1st part</th><th>PICI 2nd part</th></tr></thead><tbody><tr><td><strong>ACADDR[51]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>PA[51]</td></tr><tr><td><strong>ACADDR[50]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>PA[50]</td></tr><tr><td><strong>ACADDR[49]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>PA[49]</td></tr><tr><td><strong>ACADDR[48]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>PA[48]</td></tr><tr><td><strong>ACADDR[47]</strong></td><td>0b0</td><td>VA[56]</td><td>VA[52]</td><td>0b0</td><td>PA[47]</td></tr><tr><td><strong>ACADDR[46]</strong></td><td>0b0</td><td>VA[55]</td><td>VA[51]</td><td>0b0</td><td>PA[46]</td></tr><tr><td><strong>ACADDR[45]</strong></td><td>0b0</td><td>VA[54]</td><td>VA[50]</td><td>0b0</td><td>PA[45]</td></tr><tr><td><strong>ACADDR[44]</strong></td><td>0b0</td><td>VA[53]</td><td>VA[49]</td><td>0b0</td><td>PA[44]</td></tr><tr><td><strong>ACADDR[43]</strong></td><td>VMID[15]</td><td>VA[48]</td><td>VA[44]</td><td>0b0</td><td>PA[43]</td></tr><tr><td><strong>ACADDR[42]</strong></td><td>VMID[14]</td><td>VA[47]</td><td>VA[43]</td><td>0b0</td><td>PA[42]</td></tr><tr><td><strong>ACADDR[41]</strong></td><td>VMID[13]</td><td>VA[46]</td><td>VA[42]</td><td>0b0</td><td>PA[41]</td></tr><tr><td><strong>ACADDR[40]</strong></td><td>VMID[12]</td><td>VA[45]</td><td>VA[41]</td><td>0b0</td><td>PA[40]</td></tr><tr><td><strong>ACADDR[39]</strong></td><td>ASID[15]</td><td>ASID[15]</td><td>VA[39]</td><td>0b0</td><td>PA[39]</td></tr><tr><td><strong>ACADDR[38]</strong></td><td>ASID[14]</td><td>ASID[14]</td><td>VA[38]</td><td>0b0</td><td>PA[38]</td></tr><tr><td><strong>ACADDR[37]</strong></td><td>ASID[13]</td><td>ASID[13]</td><td>VA[37]</td><td>0b0</td><td>PA[37]</td></tr><tr><td><strong>ACADDR[36]</strong></td><td>ASID[12]</td><td>ASID[12]</td><td>VA[36]</td><td>0b0</td><td>PA[36]</td></tr><tr><td><strong>ACADDR[35]</strong></td><td>ASID[11]</td><td>ASID[11]</td><td>VA[35]</td><td>0b0</td><td>PA[35]</td></tr><tr><td><strong>ACADDR[34]</strong></td><td>ASID[10]</td><td>ASID[10]</td><td>VA[34]</td><td>0b0</td><td>PA[34]</td></tr><tr><td><strong>ACADDR[33]</strong></td><td>ASID[9]</td><td>ASID[9]</td><td>VA[33]</td><td>0b0</td><td>PA[33]</td></tr><tr><td><strong>ACADDR[32]</strong></td><td>ASID[8]</td><td>ASID[8]</td><td>VA[32]</td><td>0b0</td><td>PA[32]</td></tr><tr><td><strong>ACADDR[31]</strong></td><td>VMID[7]</td><td>VMID[7]</td><td>VA[31]</td><td>VI[27]</td><td>PA[31]</td></tr><tr><td><strong>ACADDR[30]</strong></td><td>VMID[6]</td><td>VMID[6]</td><td>VA[30]</td><td>VI[26]</td><td>PA[30]</td></tr><tr><td><strong>ACADDR[29]</strong></td><td>VMID[5]</td><td>VMID[5]</td><td>VA[29]</td><td>VI[25]</td><td>PA[29]</td></tr><tr><td><strong>ACADDR[28]</strong></td><td>VMID[4]</td><td>VMID[4]</td><td>VA[28]</td><td>VI[24]</td><td>PA[28]</td></tr><tr><td><strong>ACADDR[27]</strong></td><td>VMID[3]</td><td>VMID[3]</td><td>VA[27]</td><td>VI[23]</td><td>PA[27]</td></tr><tr><td><strong>ACADDR[26]</strong></td><td>VMID[2]</td><td>VMID[2]</td><td>VA[26]</td><td>VI[22]</td><td>PA[26]</td></tr><tr><td><strong>ACADDR[25]</strong></td><td>VMID[1]</td><td>VMID[1]</td><td>VA[25]</td><td>VI[21]</td><td>PA[25]</td></tr><tr><td><strong>ACADDR[24]</strong></td><td>VMID[0]</td><td>VMID[0]</td><td>VA[24]</td><td>VI[20]</td><td>PA[24]</td></tr><tr><td><strong>ACADDR[23]</strong></td><td>ASID[7]</td><td>ASID[7]</td><td>VA[23]</td><td>VI[19]</td><td>PA[23]</td></tr><tr><td><strong>ACADDR[22]</strong></td><td>ASID[6]</td><td>ASID[6]</td><td>VA[22]</td><td>VI[18]</td><td>PA[22]</td></tr><tr><td><strong>ACADDR[21]</strong></td><td>ASID[5]</td><td>ASID[5]</td><td>VA[21]</td><td>VI[17]</td><td>PA[21]</td></tr><tr><td><strong>ACADDR[20]</strong></td><td>ASID[4]</td><td>ASID[4]</td><td>VA[20]</td><td>VI[16]</td><td>PA[20]</td></tr><tr><td><strong>ACADDR[19]</strong></td><td>ASID[3]</td><td>ASID[3]</td><td>VA[19]</td><td>VI[15]</td><td>PA[19]</td></tr><tr><td><strong>ACADDR[18]</strong></td><td>ASID[2]</td><td>ASID[2]</td><td>VA[18]</td><td>VI[14]</td><td>PA[18]</td></tr><tr><td><strong>ACADDR[17]</strong></td><td>ASID[1]</td><td>ASID[1]</td><td>VA[17]</td><td>VI[13]</td><td>PA[17]</td></tr><tr><td><strong>ACADDR[16]</strong></td><td>ASID[0]</td><td>ASID[0]</td><td>VA[16]</td><td>VI[12]</td><td>PA[16]</td></tr><tr><td><strong>ACADDR[15]</strong></td><td>0b0(Completion)</td><td>0b0(Completion)</td><td>VA[15]</td><td>0b0(Completion)</td><td>PA[15]</td></tr><tr><td><strong>ACADDR[14]</strong></td><td>0b0(DVMType[2])</td><td>0b0(DVMType[2])</td><td>VA[14]</td><td>0b0(DVMType[2])</td><td>PA[14]</td></tr><tr><td><strong>ACADDR[13]</strong></td><td>0b1(DVMType[1])</td><td>0b1(DVMType[1])</td><td>VA[13]</td><td>0b1(DVMType[1])</td><td>PA[13]</td></tr><tr><td><strong>ACADDR[12]</strong></td><td>0b1(DVMType[0])</td><td>0b1(DVMType[0])</td><td>VA[12]</td><td>0b0(DVMType[0])</td><td>PA[12]</td></tr><tr><td><strong>ACADDR[11]</strong></td><td>Exception[1]</td><td>Exception[1]</td><td>VA[11]</td><td>0b0(Exception[1])</td><td>PA[11]</td></tr><tr><td><strong>ACADDR[10]</strong></td><td>Exception[0]</td><td>Exception[0]</td><td>VA[10]</td><td>0b0(Exception[0])</td><td>PA[10]</td></tr><tr><td><strong>ACADDR[9]</strong></td><td>Security[1]</td><td>Security[1]</td><td>VA[9]</td><td>Security[1]</td><td>PA[9]</td></tr><tr><td><strong>ACADDR[8]</strong></td><td>Security[0]</td><td>Security[0]</td><td>VA[8]</td><td>Security[0]</td><td>PA[8]</td></tr><tr><td><strong>ACADDR[7]</strong></td><td>0b0 (Range)</td><td>0b0 (Range)</td><td>VA[7]</td><td>0b0 (Range)</td><td>PA[7]</td></tr><tr><td><strong>ACADDR[6]</strong></td><td>VMIDV</td><td>VMIDV</td><td>VA[6]</td><td>VIV[1]</td><td>PA[6]</td></tr><tr><td><strong>ACADDR[5]</strong></td><td>ASIDV</td><td>ASIDV</td><td>VA[5]</td><td>VIV[0]</td><td>PA[5]</td></tr><tr><td><strong>ACADDR[4]</strong></td><td>0b0 (Leaf)</td><td>0b0 (Leaf)</td><td>VA[4]</td><td>0b0</td><td>PA[4]</td></tr><tr><td><strong>ACADDR[3]</strong></td><td>0b0 (Stage[1])</td><td>0b0 (Stage[1])</td><td>VA[40]</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACADDR[2]</strong></td><td>0b0 (Stage[0])</td><td>0b0 (Stage[0])</td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACADDR[1]</strong></td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACADDR[0]</strong></td><td>0b0 (Addr)</td><td>0b1 (Addr)</td><td>0b0</td><td>Addr</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[3]</strong></td><td>VMID[11]</td><td>VMID[11]</td><td>VMID[15]</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[2]</strong></td><td>VMID[10]</td><td>VMID[10]</td><td>VMID[14]</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[1]</strong></td><td>VMID[9]</td><td>VMID[9]</td><td>VMID[13]</td><td>0b0</td><td>0b0</td></tr><tr><td><strong>ACVMIDEXT[0]</strong></td><td>VMID[8]</td><td>VMID[8]</td><td>VMID[12]</td><td>0b0</td><td>0b0</td></tr></tbody></table><h4 id=a-ida155-dvm同步与完成a155-dvm同步与完成a><a id="a15.5 dvm同步与完成">A15.5 DVM同步与完成</a></h4><p>DVM同步消息在请求者需要知道所有先前的无效操作何时完成时使用。</p><p>在组件接收到DVM同步消息并且所有之前的无效操作完成后，会发送DVM完成请求。
判定操作何时完成的规则如下：</p><ul><li>TLB无效<ul><li>当主机不能再使用无效的转换且所有可能使用无效转换的先前事务都完成时，标记为完成。</li></ul></li><li>分支预测器无效<ul><li>当预测指令获取的缓存副本已被无效并且相关主机不能再访问时，标记为完成。无效的缓存副本可能来自任何虚拟地址或指定虚拟地址。</li></ul></li><li>指令缓存无效<ul><li>当缓存指令已被无效并且相关主机不能再访问时，标记为完成。</li></ul></li></ul><p><em><a href="#图 a15.3">图 A15.3</a></em> 展示了互连和一个接收主机之间的同步流程。</p><p><a id="图 a15.3">图 A15.3
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A15.3_DVM_Synchronization_flow.png alt></a></p><p>此过程为：</p><ol><li>主机使用侦听响应（CR）通道确认收到DVM同步消息。此响应不能依赖于AR或AW通道上任何事务的前向进展。</li><li>主机必须在完成所有必要操作后，通过AR通道发出DVM完成请求。这必须在同一主机的侦听请求通道上完成关联的DVM同步握手之后进行。
即使主机持续接收到更多的DVM无效操作和更多的DVM同步消息，也必须及时发送DVM完成。</li><li>互连组件通过发出DVM完成的组件的读取数据（R）通道响应DVM完成请求。此响应中的读取数据无效。</li></ol><p>一个DVM完成请求在AR通道上被发出，<em><a href="#表 a15.23">表 A15.23</a></em> 展示了在其他AR通道信号存在时的限制条件。</p><p><a id="表 a15.23">表 A15.23</a> DVM 完成请求约束</p><table><thead><tr><th>Signal</th><th>Constraint</th></tr></thead><tbody><tr><td><strong>ARSNOOP</strong></td><td>Must be 0b1110.</td></tr><tr><td><strong>ARADDR</strong></td><td>Must be zero.</td></tr><tr><td><strong>ARID</strong></td><td>必须与读取通道上任何未完成的非 DVM 事务不同。</td></tr><tr><td><strong>ARBURST</strong></td><td>Must be INCR (0b01).</td></tr><tr><td><strong>ARLEN</strong></td><td>Must be 1 transfer (0x00).</td></tr><tr><td><strong>ARSIZE</strong></td><td>Must be equal to the data channel width.</td></tr><tr><td><strong>ARDOMAIN</strong></td><td>Must be Shareable (0b01 or 0b10).</td></tr><tr><td><strong>ARCACHE</strong></td><td>Must be Modifiable, Non-cacheable (0b0010).</td></tr><tr><td><strong>ARCHUNKEN</strong></td><td>Must be 0b0.</td></tr><tr><td><strong>ARMMUVALID</strong></td><td>Must be 0b0.</td></tr><tr><td><strong>ARMMUATST</strong></td><td>Must be 0b0.</td></tr><tr><td><strong>ARMMUFLOW</strong></td><td>Must be 0b00.</td></tr><tr><td><strong>ARTAGOP</strong></td><td>Must be 0b00.</td></tr><tr><td><strong>ARLOCK</strong></td><td>Must be 0b0.</td></tr></tbody></table><h4 id=a-ida156-一致性连接信号a156-一致性连接信号a><a id="a15.6 一致性连接信号">A15.6 一致性连接信号</a></h4><p>DVM消息请求从从机传输到主机，这是与其他请求相反的方向。
空闲的主机可能会关闭电源，无法接受任何DVM请求。</p><p>可以使用一致性连接信号使主机控制是否接收DVM消息请求。</p><p>Coherency_Connection_Signals属性用于指示组件是否支持一致性连接信号。</p><p><a id="表 a15.24">表 A15.24</a> Coherency_Connection_Signals属性</p><table><thead><tr><th>Coherency_Connection_Signals</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>True</td><td></td><td>支持一致性连接信号。</td></tr><tr><td>False</td><td>Y</td><td>不支持一致性连接信号。</td></tr></tbody></table><p>当Coherency_Connection_Signals为真时，以下信号包括在接口上。</p><p><a id="表 a15.25">表 A15.25</a></p><table><thead><tr><th>信号名</th><th>位宽</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><strong>SYSCOREQ</strong></td><td>1</td><td>−</td><td>主机输出。<br>被置于高电平以请求在AC通道上接收DVM消息。</td></tr><tr><td><strong>SYSCOACK</strong></td><td>1</td><td>−</td><td>从机输出。<br>断言高电平以确认所附主机可能会在AC通道上接收DVM消息。</td></tr></tbody></table><p>一致性连接信号没有默认值，因此连接的接口必须同时支持或不支持连贯连接信号。</p><p>一致性连接信号使用四相方案可以安全地跨越时钟域。</p><p>在进入无法处理DVM请求的低功耗状态之前通常会断开DVM消息。</p><h5 id=a-ida1561-一致性连接握手a1561-一致性连接握手a><a id="a15.6.1 一致性连接握手">A15.6.1 一致性连接握手</a></h5><p><strong>SYSCOREQ</strong>和<strong>SYSCOACK</strong>在<strong>ARESETn</strong>被断言时必须解除断言。
当不处于复位状态时，允许以下请求</p><ul><li>主机通过将<strong>SYSCOREQ</strong>设为高电平请求接收DVM消息。互连通过将<strong>SYSCOACK</strong>设为高电平表示DVM消息已启用。</li><li>主机通过将<strong>SYSCOREQ</strong>设为低电平请求停止接收DVM消息。互连通过将<strong>SYSCOACK</strong>设为低电平表示DVM消息已禁用。</li></ul><p>握手时序显示在 <em><a href="#图 a15.4">图 A15.4</a></em> 。</p><p><a id="图 a15.4">图 A15.4
<img src=https://icjj.github.io/icer/img/post/axi/Figure_A15.4_Coherency_Connection_handshake_timing.png alt></a></p><p>连接信号遵循四相握手规则：</p><ul><li>主机只能在<strong>SYSCOACK</strong>处于同一水平时更改<strong>SYSCOREQ</strong>。ack不变可以更改req。</li><li>从机只能在<strong>SYSCOREQ</strong>处于相反水平时更改<strong>SYSCOACK</strong>。req改变才能更改ack。</li></ul><p>各状态下主机和从机的规则如 <em><a href="#表 a15.26">表 A15.26</a></em> 。</p><table><thead><tr><th>状态</th><th><strong>SYSCOREQ</strong></th><th><strong>SYSCOACK</strong></th><th>规则</th></tr></thead><tbody><tr><td>Disable</td><td>0</td><td>0</td><td>主机：</br>- 不得获取和使用DVM管理的转换表数据来执行翻译。</br>- 如果需要执行DVM管理的转换，则断言SYSCOREQ。</br>从机：</br>- 不得发出任何DVM消息请求。<br>- 不得发出任何DVM同步请求，这些假定立即完成。</td></tr><tr><td>Connect</td><td>1</td><td>0</td><td>主机：</br>- 不得获取和使用DVM管理的转换表数据进行转换。</br>- 必须能够接收和响应DVM消息请求。</br>- 在使用DVM管理的转换之前等待<strong>SYSCOACK</strong>被断言。</br>从机：</br>- 启用DVM消息到附加主机时断言<strong>SYSCOACK</strong>。</td></tr><tr><td>Enable</td><td>1</td><td>1</td><td>主机：</br>- 可以获取和使用DVM管理的转换表数据。</br>- 必须能够接收和响应DVM消息请求。</br>- 如果在使用DVM管理的转换表数据后希望进入低功耗状态，则取消<strong>SYSCOREQ</strong>。在此之前，任何使用先前获取数据的事务必须完成。</br>从机：<br>- 可以向附属的主机发送DVM消息。</td></tr><tr><td>Disconnect</td><td>0</td><td>1</td><td>主机：</br>- 不得获取或使用任何 DVM 管理的转换表数据。</br>- 必须能够接收和响应 DVM 消息请求。</br>- 在禁用 DVM 管理的逻辑之前等待 <strong>SYSCOACK</strong> 被去断言。</br>从机：</br>- 必须等待所有未完成的 DVM 消息接收到响应后才能去断言 <strong>SYSCOACK</strong>。</br>- 不得发出任何新的 DVM 消息，</br>- 如果第一部分已经发布，必须发布两部分 DVM 消息的第二部分。</td></tr></tbody></table><p>如果互连发送了一条需要在AR通道上接收DVM完成消息的DVM同步消息，那么在接收到DVM完成请求之前互连被允许去断言<strong>SYSCOACK</strong>。</p><p>即使DVM消息被禁用，主机也可以在AR通道上发送DVM完成请求。</p><p>一致性连接信号的转换可能依赖于AWAKEUP被断言，详情请参见 <em><a href="#a16.2.1 awakeup和一致性信号">A16.2.1 AWAKEUP和一致性信号</a></em> 。</p><h4 id=a-ida第16章-唤醒信号a第16章-唤醒信号a><a id="a第16章 唤醒信号">A第16章 唤醒信号</a></h4><hr><ul class=pager><li class=previous><a href=/icer/post/git%E5%B0%8F%E7%9F%A5%E8%AF%86/ data-toggle=tooltip data-placement=top title="Git 小知识">&larr;
Previous Post</a></li><li class=next><a href=/icer/post/amba5-apb-%E7%9F%A5%E8%AF%86%E6%8F%90%E7%BA%B2/ data-toggle=tooltip data-placement=top title="AMBA5 APB 知识提纲">Next
Post &rarr;</a></li></ul><script src=https://giscus.app/client.js data-repo=ICJJ/icer data-repo-id=R_kgDOMWEQRg data-category=General data-category-id=DIC_kwDOMWEQRs4CgyrH data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light data-lang=en crossorigin=anonymous async></script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/icer/tags/ahb title=ahb>ahb
</a><a href=/icer/tags/amba title=amba>amba
</a><a href=/icer/tags/amba5 title=amba5>amba5
</a><a href=/icer/tags/apb title=apb>apb
</a><a href=/icer/tags/axi title=axi>axi
</a><a href=/icer/tags/bus title=bus>bus
</a><a href=/icer/tags/git title=git>git
</a><a href=/icer/tags/html title=html>html
</a><a href=/icer/tags/i2c title=i2c>i2c
</a><a href=/icer/tags/multi-layer-ahb title=multi-layer-ahb>multi-layer-ahb
</a><a href=/icer/tags/nxp title=nxp>nxp
</a><a href=/icer/tags/spi title=spi>spi
</a><a href=/icer/tags/uart title=uart>uart
</a><a href=/icer/tags/%E4%B8%B2%E5%8F%A3 title=串口>串口
</a><a href=/icer/tags/%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91 title=协议翻译>协议翻译
</a><a href=/icer/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF title=大小端>大小端
</a><a href=/icer/tags/%E5%AD%97%E8%8A%82%E5%BA%8F title=字节序>字节序
</a><a href=/icer/tags/%E7%9F%A5%E8%AF%86%E6%8F%90%E7%BA%B2 title=知识提纲>知识提纲</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://zhaozhihan.com>Linda的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:chengjj9527@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/icjj><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/ICJJ><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-gitlab fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://stackoverflow.com/users/26381389><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="ICJJ Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; ICJJ Blog 2024<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/icer/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script><script src=https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js integrity="sha256-Qsk2KRBCN5qVZX7B+8+2IvQl1Aqc723qV1tBCQaVoqo=" crossorigin=anonymous></script><script>(function(){let e="language-plantuml";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.parentNode.insertBefore(t,e.parentNode),e.parentNode.style.display="none"})})()</script></body></html>